Index: ICT397-Project-Engine/Scene.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Scene.h\"\nScene::Scene(std::string name, std::string fs, std::string vs, std::string t)\n{\n\tthis->sceneName = name;\n\n\tif (!Init(fs, vs, t))\n\t{\n\t\tstd::cout << \"SHADER::ERROR::INIT\" << std::endl;\n\t}\n}\n\n\nScene::~Scene()\n{\n\n}\n\nvoid Scene::Run()\n{\n\n}\n\nbool Scene::Init(std::string fs, std::string vs, std::string t)\n{\n\tgameTerrain = new Terrain();\n\tShader s(vs.c_str(), fs.c_str());\n\tgameTerrain->attachShader(s);\n\tgameTerrain->LoadHeightField(\"test-heightmap.raw\", 512);\n\tgameTerrain->setScalingFactor(1, 3, 1);\n\n\tunsigned int grassTexture = textureLoader.loadTexture(\"grassTile.jpg\");\n\tunsigned int dirtTexture = textureLoader.loadTexture(\"dirtTile.jpg\");\n\tunsigned int mountainTexture = textureLoader.loadTexture(\"mountainTile.jpg\");\n\tunsigned int snowTexture = textureLoader.loadTexture(\"snowTile.jpg\");\n\tunsigned int detailMapTexture = textureLoader.loadTexture(\"detailMap.jpg\");\n\tgameTerrain->setTextures(grassTexture, dirtTexture, mountainTexture, snowTexture, detailMapTexture);\n\tPlayer p;\n\tplayer = p;\n\tGameObject g = MakeGameObject(\"./res/models/tokens/fbx/Free_Hit.fbx\", \"./res/shader/modelV.glsl\", \"./res/shader/modelF.glsl\");\n\tgameObjects = g;\n\tgameTerrain->generateTerrain();\n\tgameTerrain->modelSetup(); \n\tgameSkybox = new GladSkybox();\n\tgameSkybox->Init(\"./res/images/skybox/right.jpg\", \"./res/images/skybox/left.jpg\", \"./res/images/skybox/top.jpg\", \"./res/images/skybox/bottom.jpg\", \"./res/images/skybox/front.jpg\", \"./res/images/skybox/back.jpg\", \"./res/shader/skybox_vert.txt\", \"./res/shader/skybox_frag.txt\");\n    return true;\n}\n\nvoid Scene::UpdatePlayer(Camera playerCam)\n{\n\tglm::vec3 pos = playerCam.Position;\n\tfloat worldx, worldz;\n\n\tworldx = (pos.x / 100.0f) * (float)gameTerrain->getSize();\n\tworldz = (pos.z / 100.0f) * (float)gameTerrain->getSize();\n\t\n\tpos.y = 1.5f + ((gameTerrain->getAverageHeight(worldx, worldz) / gameTerrain->getSize()) * 100.0f);\n\n\tif (gameTerrain->getAverageHeight(worldx, worldz) >= 10.0f)\n\t{\n\t\tpos.x = player.GetPos().x;\n\t\tpos.y = player.GetPos().y;\n\t\tpos.z = player.GetPos().z;\n\t}\n\n\t\n\tstd::cout << \"Terrain Height at player position: \" << gameTerrain->getAverageHeight(worldx, worldz) << \" With Player XYZ: \" << pos.x << \"  -  \" << pos.y << \"  -  \" << pos.z << std::endl;\n\tplayer.SetPos(pos);\n}\n\nGameObject Scene::MakeGameObject(std::string modelName, std::string shaderV, std::string shaderF)\n{\n\tShader ourShader(shaderV.c_str(), shaderF.c_str());\n\tModel ourModel(modelName);\n\tGameObject obj;\n\tobj.model = ourModel;\n\tobj.shader = ourShader;\n\tobj.SetPos(glm::vec3(0.0f, 0.0f, 0.0f));\n\tobj.SetScale(0.2);\n\n\treturn obj;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICT397-Project-Engine/Scene.cpp b/ICT397-Project-Engine/Scene.cpp
--- a/ICT397-Project-Engine/Scene.cpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/ICT397-Project-Engine/Scene.cpp	(date 1617534685000)
@@ -1,4 +1,5 @@
 #include "Scene.h"
+#include <filesystem>
 Scene::Scene(std::string name, std::string fs, std::string vs, std::string t)
 {
 	this->sceneName = name;
@@ -22,26 +23,47 @@
 
 bool Scene::Init(std::string fs, std::string vs, std::string t)
 {
+    std::cout << std::__fs::filesystem::current_path() <<std::endl;
 	gameTerrain = new Terrain();
 	Shader s(vs.c_str(), fs.c_str());
 	gameTerrain->attachShader(s);
+#if _WIN32
 	gameTerrain->LoadHeightField("test-heightmap.raw", 512);
-	gameTerrain->setScalingFactor(1, 3, 1);
-
 	unsigned int grassTexture = textureLoader.loadTexture("grassTile.jpg");
 	unsigned int dirtTexture = textureLoader.loadTexture("dirtTile.jpg");
 	unsigned int mountainTexture = textureLoader.loadTexture("mountainTile.jpg");
 	unsigned int snowTexture = textureLoader.loadTexture("snowTile.jpg");
 	unsigned int detailMapTexture = textureLoader.loadTexture("detailMap.jpg");
+#else
+    gameTerrain->LoadHeightField("../ICT397-Project-Engine/test-heightmap.raw", 512);
+    unsigned int grassTexture = textureLoader.loadTexture(".../ICT397-Project-Engine/grassTile.jpg");
+    unsigned int dirtTexture = textureLoader.loadTexture("../ICT397-Project-Engine/dirtTile.jpg");
+    unsigned int mountainTexture = textureLoader.loadTexture("../ICT397-Project-Engine/mountainTile.jpg");
+    unsigned int snowTexture = textureLoader.loadTexture(".../ICT397-Project-Engine/snowTile.jpg");
+    unsigned int detailMapTexture = textureLoader.loadTexture("../ICT397-Project-Engine/detailMap.jpg");
+#endif
+	gameTerrain->setScalingFactor(1, 3, 1);
 	gameTerrain->setTextures(grassTexture, dirtTexture, mountainTexture, snowTexture, detailMapTexture);
 	Player p;
 	player = p;
+#if _WIN32
 	GameObject g = MakeGameObject("./res/models/tokens/fbx/Free_Hit.fbx", "./res/shader/modelV.glsl", "./res/shader/modelF.glsl");
+#else
+    GameObject g = MakeGameObject("../ICT397-Project-Engine/res/models/tokens/fbx/Free_Hit.fbx", "../ICT397-Project-Engine/res/shader/modelV.glsl", "../ICT397-Project-Engine/res/shader/modelF.glsl");
+#endif
+
 	gameObjects = g;
 	gameTerrain->generateTerrain();
 	gameTerrain->modelSetup(); 
 	gameSkybox = new GladSkybox();
-	gameSkybox->Init("./res/images/skybox/right.jpg", "./res/images/skybox/left.jpg", "./res/images/skybox/top.jpg", "./res/images/skybox/bottom.jpg", "./res/images/skybox/front.jpg", "./res/images/skybox/back.jpg", "./res/shader/skybox_vert.txt", "./res/shader/skybox_frag.txt");
+
+#if _WIN32
+    gameSkybox->Init("./res/images/skybox/right.jpg", "./res/images/skybox/left.jpg", "./res/images/skybox/top.jpg", "./res/images/skybox/bottom.jpg", "./res/images/skybox/front.jpg", "./res/images/skybox/back.jpg", "./res/shader/skybox_vert.txt", "./res/shader/skybox_frag.txt");
+
+#else
+    gameSkybox->Init("../res/images/skybox/right.jpg", "../res/images/skybox/left.jpg", "../res/images/skybox/top.jpg", "../res/images/skybox/bottom.jpg", "../res/images/skybox/front.jpg", "../res/images/skybox/back.jpg", "../res/shader/skybox_vert.txt", "../res/shader/skybox_frag.txt");
+
+#endif
     return true;
 }
 
Index: ICT397-Project-Engine/Model.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <glad/glad.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include<glm/gtx/matrix_decompose.hpp>\n#include \"stb_image.h\"\n#include <assimp/Importer.hpp>\n#include <assimp/scene.h>\n#include <assimp/postprocess.h>\n\n#include \"Mesh.h\"\n#include \"shader.h\"\n#include \"Texture.h\"\n\n\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <map>\n#include <vector>\n\n\n#include \"Callbacks.h\"\n\n\nclass Model\n{\npublic:\n    // model data \n    std::vector<TextureMesh> textures_loaded;\t// stores all the textures loaded so far, optimization to make sure textures aren't loaded more than once.\n    std::vector<Mesh>    meshes;\n    std::string directory;\n    bool gammaCorrection;\n    glm::mat4 globalInverseTransform = {};\n    \n    Model()\n    {\n\n    }\n\n    // constructor, expects a filepath to a 3D model.\n    Model(std::string const& path, bool gamma = false) : gammaCorrection(gamma)\n    {\n        loadModel(path);\n    }\n\n    // draws the model, and thus all its meshes\n    void Draw(Shader& shader, glm::mat4 model)\n    {\n        for (unsigned int i = 0; i < meshes.size(); i++)\n        {\n            glm::mat4 newModel = model * meshes[i].transform;\n            shader.setMat4(\"model\", newModel);\n            meshes[i].Draw(shader);\n        }\n    }\nprivate:\n    // loads a model with supported ASSIMP extensions from file and stores the resulting meshes in the meshes vector.\n\n    glm::mat4 to_glm(aiMatrix4x4t<float> m) {\n        return glm::mat4{ m.a1, m.b1, m.c1, m.d1,  //\n                    m.a2, m.b2, m.c2, m.d2,  //\n                    m.a3, m.b3, m.c3, m.d3,  //\n                    m.a4, m.b4, m.c4, m.d4 }; //\n    }\n\n    glm::vec3 to_glm(aiVector3t<float> v) {\n        return glm::vec3{ v.x, v.y, v.z };\n    }\n\n    glm::quat to_glm(aiQuaterniont<float> q) {\n        return glm::quat{ q.w, q.x, q.y, q.z };\n    }\n\n    void loadModel(std::string const& path)\n    {\n        // read file via ASSIMP\n        directory = path.substr(0, path.find_last_of('/'));\n        Assimp::Importer importer;\n        const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenSmoothNormals | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);\n\n        // check for errors\n        if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) // if is Not Zero\n        {\n            std::cout << \"ERROR::ASSIMP:: \" << importer.GetErrorString() << std::endl;\n            return;\n        }\n        // retrieve the directory path of the filepath\n        directory = path.substr(0, path.find_last_of('/'));\n        std::cout << \"Dir: \" << directory << \", number of meshes: \" << scene->mNumMeshes << std::endl;\n\n        //globalInverseTransform = glm::inverse(mat4_cast(scene->mRootNode->mTransformation));\n        // process ASSIMP's root node recursively\n        //processNode(scene->mRootNode, scene);\n        processNode(scene->mRootNode, scene, to_glm(scene->mRootNode->mTransformation));\n    }\n    // add transform\n    // processes a node in a recursive fashion. Processes each individual mesh located at the node and repeats this process on its children nodes (if any).\n    void processNode(aiNode* node, const aiScene* scene, glm::mat4 transform)// glm trasform\n    {\n        // process each mesh located at the current node\n        for (unsigned int i = 0; i < node->mNumMeshes; i++)\n        {\n            // the node object only contains indices to index the actual objects in the scene. \n            // the scene contains all the data, node is just to keep stuff organized (like relations between nodes).\n            aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];\n            meshes.push_back(processMesh(mesh, scene, transform * to_glm(node->mTransformation))); // transform * to glm (node-> transformation)\n        }\n        // after we've processed all of the meshes (if any) we then recursively process each of the children nodes\n        for (unsigned int i = 0; i < node->mNumChildren; i++)\n        {\n            processNode(node->mChildren[i], scene, transform * to_glm(node->mTransformation)); // transform * to glm (node-> transformation)\n        }\n    }\n\n    Mesh processMesh(aiMesh* mesh, const aiScene* scene, glm::mat4 transform)\n    {\n        // data to fill\n        std::vector<Vertex> vertices;\n        std::vector<unsigned int> indices;\n        std::vector<TextureMesh> textures;\n\n        //vertices.reserve(mesh->mNumVertices);\n\n        // walk through each of the mesh's vertices\n        for (unsigned int i = 0; i < mesh->mNumVertices; i++)\n        {\n            //const bool uvs = mesh->HasTextureCoords(0);\n            Vertex vertex;\n            glm::vec3 vector; // we declare a placeholder vector since assimp uses its own vector class that doesn't directly convert to glm's vec3 class so we transfer the data to this placeholder glm::vec3 first.\n            // positions\n            if (mesh->HasPositions())\n            {\n                vector.x = mesh->mVertices[i].x;\n                vector.y = mesh->mVertices[i].y;\n                vector.z = mesh->mVertices[i].z;\n                vertex.Position = vector;\n            }\n\n            // normals\n            if (mesh->HasNormals()) {\n                vector.x = mesh->mNormals[i].x;\n                vector.y = mesh->mNormals[i].y;\n                vector.z = mesh->mNormals[i].z;\n                vertex.Normal = vector;\n            }\n            // texture coordinates\n            if (mesh->mTextureCoords[0]) // does the mesh contain texture coordinates?\n            {\n                glm::vec2 vec;\n                // a vertex can contain up to 8 different texture coordinates. We thus make the assumption that we won't \n                // use models where a vertex can have multiple texture coordinates so we always take the first set (0).\n                vec.x = mesh->mTextureCoords[0][i].x;\n                vec.y = mesh->mTextureCoords[0][i].y;\n                vertex.TexCoords = vec;\n            }\n            else\n                vertex.TexCoords = glm::vec2(0.0f, 0.0f);\n\n            if (mesh->HasTangentsAndBitangents())\n            {\n                // tangent\n                vector.x = mesh->mTangents[i].x;\n                vector.y = mesh->mTangents[i].y;\n                vector.z = mesh->mTangents[i].z;\n                vertex.Tangent = vector;\n                // bitangent\n                vector.x = mesh->mBitangents[i].x;\n                vector.y = mesh->mBitangents[i].y;\n                vector.z = mesh->mBitangents[i].z;\n                vertex.Bitangent = vector;\n            }\n            vertices.push_back(vertex);\n        }\n\n        //indices.reserve(mesh->mNumVertices);\n        // now wak through each of the mesh's faces (a face is a mesh its triangle) and retrieve the corresponding vertex indices.\n        for (unsigned int i = 0; i < mesh->mNumFaces; i++)\n        {\n            aiFace face = mesh->mFaces[i];\n            // retrieve all indices of the face and store them in the indices vector\n            for (unsigned int j = 0; j < face.mNumIndices; j++)\n            {\n                indices.push_back(face.mIndices[j]);\n            }\n        }\n\n\n\n        // process materials\n        aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];\n\n        //textures = GetTextures(material);\n        // we assume a convention for sampler names in the shaders. Each diffuse texture should be named\n        // as 'texture_diffuseN' where N is a sequential number ranging from 1 to MAX_SAMPLER_NUMBER. \n        // Same applies to other texture as the following list summarizes:\n        // diffuse: texture_diffuseN\n        // specular: texture_specularN\n        // normal: texture_normalN\n\n        // 1. diffuse maps\n        std::vector<TextureMesh> diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, \"texture_diffuse\");\n        textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());\n        // 2. specular maps\n        std::vector<TextureMesh> specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, \"texture_specular\");\n        textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());\n        // 3. normal maps\n        std::vector<TextureMesh> normalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, \"texture_normal\");\n        textures.insert(textures.end(), normalMaps.begin(), normalMaps.end());\n        // 4. height maps\n        std::vector<TextureMesh> heightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, \"texture_height\");\n        textures.insert(textures.end(), heightMaps.begin(), heightMaps.end());\n\n        // return a mesh object created from the extracted mesh data\n        return Mesh(vertices, indices, textures, transform);\n    }\n\n    //vector<Texture> GetTextures(aiMaterial* material)\n    //{\n\n    //}\n\n\n    // checks all material textures of a given type and loads the textures if they're not loaded yet.\n    // the required info is returned as a Texture struct.\n    std::vector<TextureMesh> loadMaterialTextures(aiMaterial* mat, aiTextureType type, std::string typeName)\n    {\n        std::vector<TextureMesh> textures;\n        int count = mat->GetTextureCount(type);\n        std::cout << typeName << \" \" << count << std::endl;\n\n        for (unsigned int i = 0; i < mat->GetTextureCount(type); i++)\n        {\n            aiString str;\n            mat->GetTexture(type, i, &str);\n            // check if texture was loaded before and if so, continue to next iteration: skip loading a new texture\n            bool skip = false;\n            for (unsigned int j = 0; j < textures_loaded.size(); j++)\n            {\n                if (std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0)\n                {\n                    textures.push_back(textures_loaded[j]);\n                    skip = true; // a texture with the same filepath has already been loaded, continue to next one. (optimization)\n                    break;\n                }\n            }\n            if (!skip)\n            {   // if texture hasn't been loaded already, load it\n\n                TextureMesh texture;\n                texture.id = TextureFromFile(str.C_Str(), this->directory);\n\n                texture.type = typeName;\n                texture.path = str.C_Str();\n                textures.push_back(texture);\n                textures_loaded.push_back(texture);  // store it as texture loaded for entire model, to ensure we won't unnecesery load duplicate textures.\n            }\n        }\n        return textures;\n    }\n\n\n\n\n    unsigned int TextureFromFile(const char* path, const std::string& directory)//, bool gamma)\n    {\n        std::string filename = std::string(path);\n\n        std::cout << filename << std::endl; //debug\n\n        filename = directory + '/' + filename;\n\n        std::cout << filename << std::endl; //debug\n\n        stbi_set_flip_vertically_on_load(false);\n        unsigned int textureID;\n        glGenTextures(1, &textureID);\n\n        int width, height, nrComponents;\n        unsigned char* data = stbi_load(filename.c_str(), &width, &height, &nrComponents, 0);\n        if (data)\n        {\n            GLenum format;\n            if (nrComponents == 1)\n                format = GL_RED;\n            else if (nrComponents == 3)\n                format = GL_RGB;\n            else if (nrComponents == 4)\n                format = GL_RGBA;\n\n            glBindTexture(GL_TEXTURE_2D, textureID);\n            glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);\n            glGenerateMipmap(GL_TEXTURE_2D);\n\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n            stbi_image_free(data);\n        }\n        else\n        {\n            std::cout << \"Texture failed to load at path: \" << path << std::endl;\n            stbi_image_free(data);\n        }\n\n        return textureID;\n    }\n\n\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICT397-Project-Engine/Model.h b/ICT397-Project-Engine/Model.h
--- a/ICT397-Project-Engine/Model.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/ICT397-Project-Engine/Model.h	(date 1617529672000)
@@ -8,7 +8,7 @@
 #include <assimp/postprocess.h>
 
 #include "Mesh.h"
-#include "shader.h"
+#include "Shader.h"
 #include "Texture.h"
 
 
@@ -31,7 +31,8 @@
     std::vector<Mesh>    meshes;
     std::string directory;
     bool gammaCorrection;
-    glm::mat4 globalInverseTransform = {};
+    //glm::mat4 globalInverseTransform = {};
+    glm::mat4 globalInversTransform;
     
     Model()
     {
@@ -58,18 +59,18 @@
     // loads a model with supported ASSIMP extensions from file and stores the resulting meshes in the meshes vector.
 
     glm::mat4 to_glm(aiMatrix4x4t<float> m) {
-        return glm::mat4{ m.a1, m.b1, m.c1, m.d1,  //
+        return glm::mat4( m.a1, m.b1, m.c1, m.d1,  //
                     m.a2, m.b2, m.c2, m.d2,  //
                     m.a3, m.b3, m.c3, m.d3,  //
-                    m.a4, m.b4, m.c4, m.d4 }; //
+                    m.a4, m.b4, m.c4, m.d4 ); //
     }
 
     glm::vec3 to_glm(aiVector3t<float> v) {
-        return glm::vec3{ v.x, v.y, v.z };
+        return glm::vec3( v.x, v.y, v.z );
     }
 
     glm::quat to_glm(aiQuaterniont<float> q) {
-        return glm::quat{ q.w, q.x, q.y, q.z };
+        return glm::quat( q.w, q.x, q.y, q.z );
     }
 
     void loadModel(std::string const& path)
Index: ICT397-Project-Engine/Engine.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Engine.h\"\n\nEngine::Engine()\n{\n\tif (glfwInit())\n\t{\n\t\twindow = new GlfwWindow();\n\t\twindow->Init(\"Engine\", 600, 800);\n\t\twindow->FrameBuffer();\n\t\trunning = true;\n\t}\n\telse\n\t{\n\t\trunning = false;\n\t}\n\n\tif (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n\t{\n\t\tstd::cout << \"Failed to initialize GLAD\" << std::endl;\n\t}\n\telse\n\t{\n\t\trender = new GladRenderer();\n\t\trender->DepthTest();\n\t}\n\n\tcurrentScene = 0;\n\n\n\n\n\tScene one(\"Game\", \"fragment.glsl\", \"vertex.glsl\", \"grass.jpg\");\n\tgameScenes.push_back(one);\n}\n\nEngine::~Engine()\n{\n\tif (window != NULL)\n\t\tdelete[] window;\n}\n\nvoid Engine::Run()\n{\n\tfloat deltaTime;\n\tfloat lastFrame = 0;\n\twhile (running)\n\t{\n\t\tfloat currentFrame = glfwGetTime();\n\t\tdeltaTime = currentFrame - lastFrame;\n\t\tlastFrame = currentFrame;\n\t\twindow->Clear();\n\n\t\t//Scene projection\n\t\twindow->Projection();\n\t\twindow->Restart();\n\t\tif (gameScenes[currentScene].GetSceneName() == \"menu\")\n\t\t{\n\t\t\tstd::cout << \"This is a menu\" << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTerrain* t = gameScenes[currentScene].GetTerrain();\n\t\t\tSkybox* s = gameScenes[currentScene].GetSkybox();\n\n\t\t\tGameObject testObject = gameScenes[currentScene].GetGameObject();\n\n\t\t\t//Terrain\n\t\t\twindow->SetShader(t->GetShader());\n\t\t\trender->BindTexture(t->GetTextIds());\n\t\t\trender->RenderTerrain(t->GetVAO(), t->GetIndicesSize());\n\t\t\t\n\t\t\twindow->SetShaderSkybox(s->GetShader());\n\t\t\trender->RenderSkybox(s->GetVAO(), s->GetTexture());\n\n\t\t\twindow->SetShader(testObject.shader);\n\t\t\tfor (int i = 0; i < testObject.model.meshes.size(); i++)\n\t\t\t{\n\t\t\t\trender->RenderModel(testObject.shader, testObject.GenerateMatFourForMesh(i), testObject.model.meshes[i]);\n\t\t\t}\n\t\t\tgameScenes[currentScene].UpdatePlayer(window->GetCamera());\n\t\t\twindow->UpdateCamera(gameScenes[currentScene].player.GetPos());\n\t\t\t//gameScenes[currentScene].player.Info();\n\t\t\trunning = window->GameInput(deltaTime);\n\t\t\twindow->MouseMove();\n\t\t}\n\n\t\twindow->Buffer();\n\t}\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICT397-Project-Engine/Engine.cpp b/ICT397-Project-Engine/Engine.cpp
--- a/ICT397-Project-Engine/Engine.cpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/ICT397-Project-Engine/Engine.cpp	(date 1617534724000)
@@ -28,8 +28,11 @@
 
 
 
-
+#if _WIN32
 	Scene one("Game", "fragment.glsl", "vertex.glsl", "grass.jpg");
+#else
+    Scene one("Game", "../ICT397-Project-Engine/fragment.glsl", "../ICT397-Project-Engine/vertex.glsl", "../ICT397-Project-Engine/grass.jpg");
+#endif
 	gameScenes.push_back(one);
 }
 
Index: include/assimp/Macros.h
===================================================================
diff --git a/include/assimp/Macros.h b/include/assimp/Macros.h
deleted file mode 100644
--- a/include/assimp/Macros.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ /dev/null	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
@@ -1,49 +0,0 @@
-/*
----------------------------------------------------------------------------
-Open Asset Import Library (assimp)
----------------------------------------------------------------------------
-
-Copyright (c) 2006-2019, assimp team
-
-All rights reserved.
-
-Redistribution and use of this software in source and binary forms,
-with or without modification, are permitted provided that the following
-conditions are met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the above
-  copyright notice, this list of conditions and the
-  following disclaimer in the documentation and/or other
-  materials provided with the distribution.
-
-* Neither the name of the assimp team, nor the names of its
-  contributors may be used to endorse or promote products
-  derived from this software without specific prior
-  written permission of the assimp team.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----------------------------------------------------------------------------
-*/
-
-/* Helper macro to set a pointer to NULL in debug builds
- */
-#if (defined ASSIMP_BUILD_DEBUG)
-#   define AI_DEBUG_INVALIDATE_PTR(x) x = NULL;
-#else
-#   define AI_DEBUG_INVALIDATE_PTR(x)
-#endif
-
Index: include/assimp/Defines.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2012, assimp team\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n// We need those constants, workaround for any platforms where nobody defined them yet\n#if (!defined SIZE_MAX)\n#   define SIZE_MAX (~((size_t)0))\n#endif\n\n#if (!defined UINT_MAX)\n#   define UINT_MAX (~((unsigned int)0))\n#endif\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Defines.h b/include/assimp/Defines.h
--- a/include/assimp/Defines.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Defines.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2012, assimp team
+Copyright (c) 2006-2020, assimp team
 All rights reserved.
 
 Redistribution and use of this software in source and binary forms,
@@ -38,6 +38,14 @@
 ----------------------------------------------------------------------
 */
 
+#pragma once
+#ifndef AI_DEFINES_H_INC
+#define AI_DEFINES_H_INC
+
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 // We need those constants, workaround for any platforms where nobody defined them yet
 #if (!defined SIZE_MAX)
 #   define SIZE_MAX (~((size_t)0))
@@ -47,3 +55,4 @@
 #   define UINT_MAX (~((unsigned int)0))
 #endif
 
+#endif // AI_DEINES_H_INC
Index: include/assimp/SGSpatialSort.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** Small helper classes to optimize finding vertices close to a given location\n */\n#ifndef AI_D3DSSPATIALSORT_H_INC\n#define AI_D3DSSPATIALSORT_H_INC\n\n#include <assimp/types.h>\n#include <vector>\n#include <stdint.h>\n\nnamespace Assimp    {\n\n// ----------------------------------------------------------------------------------\n/** Specialized version of SpatialSort to support smoothing groups\n *  This is used in by the 3DS, ASE and LWO loaders. 3DS and ASE share their\n *  normal computation code in SmoothingGroups.inl, the LWO loader has its own\n *  implementation to handle all details of its file format correctly.\n */\n// ----------------------------------------------------------------------------------\nclass ASSIMP_API SGSpatialSort\n{\npublic:\n\n    SGSpatialSort();\n\n    // -------------------------------------------------------------------\n    /** Construction from a given face array, handling smoothing groups\n     *  properly\n     */\n    explicit SGSpatialSort(const std::vector<aiVector3D>& vPositions);\n\n    // -------------------------------------------------------------------\n    /** Add a vertex to the spatial sort\n     * @param vPosition Vertex position to be added\n     * @param index Index of the vrtex\n     * @param smoothingGroup SmoothingGroup for this vertex\n     */\n    void Add(const aiVector3D& vPosition, unsigned int index,\n        unsigned int smoothingGroup);\n\n    // -------------------------------------------------------------------\n    /** Prepare the spatial sorter for use. This step runs in O(logn)\n     */\n    void Prepare();\n\n    /** Destructor */\n    ~SGSpatialSort();\n\n    // -------------------------------------------------------------------\n    /** Returns an iterator for all positions close to the given position.\n     * @param pPosition The position to look for vertices.\n     * @param pSG Only included vertices with at least one shared smooth group\n     * @param pRadius Maximal distance from the position a vertex may have\n     *   to be counted in.\n     * @param poResults The container to store the indices of the found\n     *   positions. Will be emptied by the call so it may contain anything.\n     * @param exactMatch Specifies whether smoothing groups are bit masks\n     *   (false) or integral values (true). In the latter case, a vertex\n     *   cannot belong to more than one smoothing group.\n     * @return An iterator to iterate over all vertices in the given area.\n     */\n    // -------------------------------------------------------------------\n    void FindPositions( const aiVector3D& pPosition, uint32_t pSG,\n        float pRadius, std::vector<unsigned int>& poResults,\n        bool exactMatch = false) const;\n\nprotected:\n    /** Normal of the sorting plane, normalized. The center is always at (0, 0, 0) */\n    aiVector3D mPlaneNormal;\n\n    // -------------------------------------------------------------------\n    /** An entry in a spatially sorted position array. Consists of a\n     *  vertex index, its position and its pre-calculated distance from\n     *  the reference plane */\n    // -------------------------------------------------------------------\n    struct Entry {\n        unsigned int mIndex;    ///< The vertex referred by this entry\n        aiVector3D mPosition;   ///< Position\n        uint32_t mSmoothGroups;\n        float mDistance;        ///< Distance of this vertex to the sorting plane\n\n        Entry() AI_NO_EXCEPT\n        : mIndex(0)\n        , mPosition()\n        , mSmoothGroups(0)\n        , mDistance(0.0f) {\n            // empty\n        }\n\n        Entry( unsigned int pIndex, const aiVector3D& pPosition, float pDistance,uint32_t pSG)\n        : mIndex( pIndex)\n        , mPosition( pPosition)\n        , mSmoothGroups(pSG)\n        , mDistance( pDistance) {\n            // empty\n        }\n\n        bool operator < (const Entry& e) const {\n            return mDistance < e.mDistance;\n        }\n    };\n\n    // all positions, sorted by distance to the sorting plane\n    std::vector<Entry> mPositions;\n};\n\n} // end of namespace Assimp\n\n#endif // AI_SPATIALSORT_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SGSpatialSort.h b/include/assimp/SGSpatialSort.h
--- a/include/assimp/SGSpatialSort.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SGSpatialSort.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -42,9 +42,14 @@
 
 /** Small helper classes to optimize finding vertices close to a given location
  */
+#pragma once
 #ifndef AI_D3DSSPATIALSORT_H_INC
 #define AI_D3DSSPATIALSORT_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
 #include <vector>
 #include <stdint.h>
Index: include/assimp/cexport.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2011, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  cexport.h\n*  @brief Defines the C-API for the Assimp export interface\n*/\n#pragma once\n#ifndef AI_EXPORT_H_INC\n#define AI_EXPORT_H_INC\n\n#ifndef ASSIMP_BUILD_NO_EXPORT\n\n// Public ASSIMP data structures\n#include <assimp/types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct aiScene;  // aiScene.h\nstruct aiFileIO; // aiFileIO.h\n\n// --------------------------------------------------------------------------------\n/** Describes an file format which Assimp can export to. Use #aiGetExportFormatCount() to\n* learn how many export formats the current Assimp build supports and #aiGetExportFormatDescription()\n* to retrieve a description of an export format option.\n*/\nstruct aiExportFormatDesc\n{\n    /// a short string ID to uniquely identify the export format. Use this ID string to\n    /// specify which file format you want to export to when calling #aiExportScene().\n    /// Example: \"dae\" or \"obj\"\n    const char* id;\n\n    /// A short description of the file format to present to users. Useful if you want\n    /// to allow the user to select an export format.\n    const char* description;\n\n    /// Recommended file extension for the exported file in lower case.\n    const char* fileExtension;\n};\n\n\n// --------------------------------------------------------------------------------\n/** Returns the number of export file formats available in the current Assimp build.\n * Use aiGetExportFormatDescription() to retrieve infos of a specific export format.\n */\nASSIMP_API size_t aiGetExportFormatCount(void);\n\n// --------------------------------------------------------------------------------\n/** Returns a description of the nth export file format. Use #aiGetExportFormatCount()\n * to learn how many export formats are supported. The description must be released by\n * calling aiReleaseExportFormatDescription afterwards.\n * @param pIndex Index of the export format to retrieve information for. Valid range is\n *    0 to #aiGetExportFormatCount()\n * @return A description of that specific export format. NULL if pIndex is out of range.\n */\nASSIMP_API const C_STRUCT aiExportFormatDesc* aiGetExportFormatDescription( size_t pIndex);\n\n// --------------------------------------------------------------------------------\n/** Release a description of the nth export file format. Must be returned by\n* aiGetExportFormatDescription\n* @param desc Pointer to the description\n*/\nASSIMP_API void aiReleaseExportFormatDescription( const C_STRUCT aiExportFormatDesc *desc );\n\n// --------------------------------------------------------------------------------\n/** Create a modifiable copy of a scene.\n *  This is useful to import files via Assimp, change their topology and\n *  export them again. Since the scene returned by the various importer functions\n *  is const, a modifiable copy is needed.\n *  @param pIn Valid scene to be copied\n *  @param pOut Receives a modifyable copy of the scene. Use aiFreeScene() to\n *    delete it again.\n */\nASSIMP_API void aiCopyScene(const C_STRUCT aiScene* pIn,\n    C_STRUCT aiScene** pOut);\n\n\n// --------------------------------------------------------------------------------\n/** Frees a scene copy created using aiCopyScene() */\nASSIMP_API void aiFreeScene(const C_STRUCT aiScene* pIn);\n\n// --------------------------------------------------------------------------------\n/** Exports the given scene to a chosen file format and writes the result file(s) to disk.\n* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n*   The scene is expected to conform to Assimp's Importer output format as specified\n*   in the @link data Data Structures Page @endlink. In short, this means the model data\n*   should use a right-handed coordinate systems, face winding should be counter-clockwise\n*   and the UV coordinate origin is assumed to be in the upper left. If your input data\n*   uses different conventions, have a look at the last parameter.\n* @param pFormatId ID string to specify to which format you want to export to. Use\n* aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.\n* @param pFileName Output file to write\n* @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated\n*   flags, but in reality only a subset of them makes sense here. Specifying\n*   'preprocessing' flags is useful if the input scene does not conform to\n*   Assimp's default conventions as specified in the @link data Data Structures Page @endlink.\n*   In short, this means the geometry data should use a right-handed coordinate systems, face\n*   winding should be counter-clockwise and the UV coordinate origin is assumed to be in\n*   the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n*   #aiProcess_FlipWindingOrder flags are used in the import side to allow users\n*   to have those defaults automatically adapted to their conventions. Specifying those flags\n*   for exporting has the opposite effect, respectively. Some other of the\n*   #aiPostProcessSteps enumerated values may be useful as well, but you'll need\n*   to try out what their effect on the exported file is. Many formats impose\n*   their own restrictions on the structure of the geometry stored therein,\n*   so some preprocessing may have little or no effect at all, or may be\n*   redundant as exporters would apply them anyhow. A good example\n*   is triangulation - whilst you can enforce it by specifying\n*   the #aiProcess_Triangulate flag, most export formats support only\n*   triangulate data so they would run the step anyway.\n*\n*   If assimp detects that the input scene was directly taken from the importer side of\n*   the library (i.e. not copied using aiCopyScene and potetially modified afterwards),\n*   any postprocessing steps already applied to the scene will not be applied again, unless\n*   they show non-idempotent behaviour (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n*   #aiProcess_FlipWindingOrder).\n* @return a status code indicating the result of the export\n* @note Use aiCopyScene() to get a modifiable copy of a previously\n*   imported scene.\n*/\nASSIMP_API aiReturn aiExportScene( const C_STRUCT aiScene* pScene,\n    const char* pFormatId,\n    const char* pFileName,\n    unsigned int pPreprocessing);\n\n\n// --------------------------------------------------------------------------------\n/** Exports the given scene to a chosen file format using custom IO logic supplied by you.\n* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n* @param pFormatId ID string to specify to which format you want to export to. Use\n* aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.\n* @param pFileName Output file to write\n* @param pIO custom IO implementation to be used. Use this if you use your own storage methods.\n*   If none is supplied, a default implementation using standard file IO is used. Note that\n*   #aiExportSceneToBlob is provided as convenience function to export to memory buffers.\n* @param pPreprocessing Please see the documentation for #aiExportScene\n* @return a status code indicating the result of the export\n* @note Include <aiFileIO.h> for the definition of #aiFileIO.\n* @note Use aiCopyScene() to get a modifiable copy of a previously\n*   imported scene.\n*/\nASSIMP_API aiReturn aiExportSceneEx( const C_STRUCT aiScene* pScene,\n    const char* pFormatId,\n    const char* pFileName,\n    C_STRUCT aiFileIO* pIO,\n    unsigned int pPreprocessing );\n\n// --------------------------------------------------------------------------------\n/** Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an\n* exported scene. The memory referred by this structure is owned by Assimp.\n* to free its resources. Don't try to free the memory on your side - it will crash for most build configurations\n* due to conflicting heaps.\n*\n* Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.\n* This is used when exporters write more than one output file for a given #aiScene. See the remarks for\n* #aiExportDataBlob::name for more information.\n*/\nstruct aiExportDataBlob\n{\n    /// Size of the data in bytes\n    size_t size;\n\n    /// The data.\n    void* data;\n\n    /** Name of the blob. An empty string always\n        indicates the first (and primary) blob,\n        which contains the actual file data.\n        Any other blobs are auxiliary files produced\n        by exporters (i.e. material files). Existence\n        of such files depends on the file format. Most\n        formats don't split assets across multiple files.\n\n        If used, blob names usually contain the file\n        extension that should be used when writing\n        the data to disc.\n     */\n    C_STRUCT aiString name;\n\n    /** Pointer to the next blob in the chain or NULL if there is none. */\n    C_STRUCT aiExportDataBlob * next;\n\n#ifdef __cplusplus\n    /// Default constructor\n    aiExportDataBlob() { size = 0; data = next = NULL; }\n    /// Releases the data\n    ~aiExportDataBlob() { delete [] static_cast<unsigned char*>( data ); delete next; }\n\nprivate:\n    // no copying\n    aiExportDataBlob(const aiExportDataBlob& );\n    aiExportDataBlob& operator= (const aiExportDataBlob& );\n#endif // __cplusplus\n};\n\n// --------------------------------------------------------------------------------\n/** Exports the given scene to a chosen file format. Returns the exported data as a binary blob which\n* you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()\n* to free the resources associated with the export.\n* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n* @param pFormatId ID string to specify to which format you want to export to. Use\n* #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.\n* @param pPreprocessing Please see the documentation for #aiExportScene\n* @return the exported data or NULL in case of error\n*/\nASSIMP_API const C_STRUCT aiExportDataBlob* aiExportSceneToBlob( const C_STRUCT aiScene* pScene, const char* pFormatId,\n    unsigned int pPreprocessing );\n\n// --------------------------------------------------------------------------------\n/** Releases the memory associated with the given exported data. Use this function to free a data blob\n* returned by aiExportScene().\n* @param pData the data blob returned by #aiExportSceneToBlob\n*/\nASSIMP_API void aiReleaseExportBlob( const C_STRUCT aiExportDataBlob* pData );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // ASSIMP_BUILD_NO_EXPORT\n#endif // AI_EXPORT_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/cexport.h b/include/assimp/cexport.h
--- a/include/assimp/cexport.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/cexport.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2011, assimp team
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -46,6 +46,10 @@
 #ifndef AI_EXPORT_H_INC
 #define AI_EXPORT_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifndef ASSIMP_BUILD_NO_EXPORT
 
 // Public ASSIMP data structures
Index: include/assimp/SmoothingGroups.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2012, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, \nwith or without modification, are permitted provided that the following \nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Generation of normal vectors basing on smoothing groups */\n\n#ifndef AI_SMOOTHINGGROUPS_INL_INCLUDED\n#define AI_SMOOTHINGGROUPS_INL_INCLUDED\n\n// internal headers\n#include <assimp/SGSpatialSort.h>\n\n// CRT header\n#include <algorithm>\n\nusing namespace Assimp;\n\n// ------------------------------------------------------------------------------------------------\ntemplate <class T>\nvoid ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh)\n{\n    // First generate face normals\n    sMesh.mNormals.resize(sMesh.mPositions.size(),aiVector3D());\n    for( unsigned int a = 0; a < sMesh.mFaces.size(); a++)\n    {\n        T& face = sMesh.mFaces[a];\n\n        aiVector3D* pV1 = &sMesh.mPositions[face.mIndices[0]];\n        aiVector3D* pV2 = &sMesh.mPositions[face.mIndices[1]];\n        aiVector3D* pV3 = &sMesh.mPositions[face.mIndices[2]];\n\n        aiVector3D pDelta1 = *pV2 - *pV1;\n        aiVector3D pDelta2 = *pV3 - *pV1;\n        aiVector3D vNor = pDelta1 ^ pDelta2;\n\n        for (unsigned int c = 0; c < 3;++c)\n            sMesh.mNormals[face.mIndices[c]] = vNor;\n    }\n\n    // calculate the position bounds so we have a reliable epsilon to check position differences against \n    aiVector3D minVec( 1e10f, 1e10f, 1e10f), maxVec( -1e10f, -1e10f, -1e10f);\n    for( unsigned int a = 0; a < sMesh.mPositions.size(); a++)\n    {\n        minVec.x = std::min( minVec.x, sMesh.mPositions[a].x);\n        minVec.y = std::min( minVec.y, sMesh.mPositions[a].y);\n        minVec.z = std::min( minVec.z, sMesh.mPositions[a].z);\n        maxVec.x = std::max( maxVec.x, sMesh.mPositions[a].x);\n        maxVec.y = std::max( maxVec.y, sMesh.mPositions[a].y);\n        maxVec.z = std::max( maxVec.z, sMesh.mPositions[a].z);\n    }\n    const float posEpsilon = (maxVec - minVec).Length() * 1e-5f;\n    std::vector<aiVector3D> avNormals;\n    avNormals.resize(sMesh.mNormals.size());\n    \n    // now generate the spatial sort tree\n    SGSpatialSort sSort;\n    for( typename std::vector<T>::iterator i =  sMesh.mFaces.begin();\n        i != sMesh.mFaces.end();++i)\n    {\n        for (unsigned int c = 0; c < 3;++c)\n            sSort.Add(sMesh.mPositions[(*i).mIndices[c]],(*i).mIndices[c],(*i).iSmoothGroup);\n    }\n    sSort.Prepare();\n\n    std::vector<bool> vertexDone(sMesh.mPositions.size(),false);\n    for( typename std::vector<T>::iterator i =  sMesh.mFaces.begin();\n        i != sMesh.mFaces.end();++i)\n    {\n        std::vector<unsigned int> poResult;\n        for (unsigned int c = 0; c < 3;++c)\n        {\n            unsigned int idx = (*i).mIndices[c];\n            if (vertexDone[idx])continue;\n\n            sSort.FindPositions(sMesh.mPositions[idx],(*i).iSmoothGroup,\n                posEpsilon,poResult);\n\n            aiVector3D vNormals;\n            for (std::vector<unsigned int>::const_iterator\n                a =  poResult.begin();\n                a != poResult.end();++a)\n            {\n                vNormals += sMesh.mNormals[(*a)];\n            }\n            vNormals.NormalizeSafe();\n\n            // write back into all affected normals\n            for (std::vector<unsigned int>::const_iterator\n                a =  poResult.begin();\n                a != poResult.end();++a)\n            {\n                idx = *a;\n                avNormals [idx] = vNormals;\n                vertexDone[idx] = true;\n            }\n        }\n    }\n    sMesh.mNormals = avNormals;\n}\n\n#endif // !! AI_SMOOTHINGGROUPS_INL_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SmoothingGroups.inl b/include/assimp/SmoothingGroups.inl
--- a/include/assimp/SmoothingGroups.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SmoothingGroups.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2012, assimp team
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -41,13 +41,16 @@
 
 /** @file Generation of normal vectors basing on smoothing groups */
 
+#pragma once
 #ifndef AI_SMOOTHINGGROUPS_INL_INCLUDED
 #define AI_SMOOTHINGGROUPS_INL_INCLUDED
 
-// internal headers
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/SGSpatialSort.h>
 
-// CRT header
 #include <algorithm>
 
 using namespace Assimp;
Index: include/assimp/SceneCombiner.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Declares a helper class, \"SceneCombiner\" providing various\n *  utilities to merge scenes.\n */\n#ifndef AI_SCENE_COMBINER_H_INC\n#define AI_SCENE_COMBINER_H_INC\n\n#include <assimp/ai_assert.h>\n#include <assimp/types.h>\n#include <assimp/Defines.h>\n#include <stddef.h>\n#include <set>\n#include <list>\n#include <stdint.h>\n\n#include <vector>\n\nstruct aiScene;\nstruct aiNode;\nstruct aiMaterial;\nstruct aiTexture;\nstruct aiCamera;\nstruct aiLight;\nstruct aiMetadata;\nstruct aiBone;\nstruct aiMesh;\nstruct aiAnimMesh;\nstruct aiAnimation;\nstruct aiNodeAnim;\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------\n/** \\brief Helper data structure for SceneCombiner.\n *\n *  Describes to which node a scene must be attached to.\n */\nstruct AttachmentInfo\n{\n    AttachmentInfo()\n        :   scene           (NULL)\n        ,   attachToNode    (NULL)\n    {}\n\n    AttachmentInfo(aiScene* _scene, aiNode* _attachToNode)\n        :   scene           (_scene)\n        ,   attachToNode    (_attachToNode)\n    {}\n\n    aiScene* scene;\n    aiNode*  attachToNode;\n};\n\n// ---------------------------------------------------------------------------\nstruct NodeAttachmentInfo\n{\n    NodeAttachmentInfo()\n        :   node            (NULL)\n        ,   attachToNode    (NULL)\n        ,   resolved        (false)\n        ,   src_idx         (SIZE_MAX)\n    {}\n\n    NodeAttachmentInfo(aiNode* _scene, aiNode* _attachToNode,size_t idx)\n        :   node            (_scene)\n        ,   attachToNode    (_attachToNode)\n        ,   resolved        (false)\n        ,   src_idx         (idx)\n    {}\n\n    aiNode*  node;\n    aiNode*  attachToNode;\n    bool     resolved;\n    size_t   src_idx;\n};\n\n// ---------------------------------------------------------------------------\n/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES\n *  Generate unique names for all named scene items\n */\n#define AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES      0x1\n\n/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES\n *  Generate unique names for materials, too.\n *  This is not absolutely required to pass the validation.\n */\n#define AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES   0x2\n\n/** @def AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY\n * Use deep copies of duplicate scenes\n */\n#define AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY   0x4\n\n/** @def AI_INT_MERGE_SCENE_RESOLVE_CROSS_ATTACHMENTS\n * If attachment nodes are not found in the given master scene,\n * search the other imported scenes for them in an any order.\n */\n#define AI_INT_MERGE_SCENE_RESOLVE_CROSS_ATTACHMENTS 0x8\n\n/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY\n * Can be combined with AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES.\n * Unique names are generated, but only if this is absolutely\n * required to avoid name conflicts.\n */\n#define AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY 0x10\n\ntypedef std::pair<aiBone*,unsigned int> BoneSrcIndex;\n\n// ---------------------------------------------------------------------------\n/** @brief Helper data structure for SceneCombiner::MergeBones.\n */\nstruct BoneWithHash : public std::pair<uint32_t,aiString*>  {\n    std::vector<BoneSrcIndex> pSrcBones;\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Utility for SceneCombiner\n */\nstruct SceneHelper\n{\n    SceneHelper ()\n        : scene     (NULL)\n        , idlen     (0)\n    {\n        id[0] = 0;\n    }\n\n    explicit SceneHelper (aiScene* _scene)\n        : scene     (_scene)\n        , idlen     (0)\n    {\n        id[0] = 0;\n    }\n\n    AI_FORCE_INLINE aiScene* operator-> () const\n    {\n        return scene;\n    }\n\n    // scene we're working on\n    aiScene* scene;\n\n    // prefix to be added to all identifiers in the scene ...\n    char id [32];\n\n    // and its strlen()\n    unsigned int idlen;\n\n    // hash table to quickly check whether a name is contained in the scene\n    std::set<unsigned int> hashes;\n};\n\n// ---------------------------------------------------------------------------\n/** \\brief Static helper class providing various utilities to merge two\n *    scenes. It is intended as internal utility and NOT for use by\n *    applications.\n *\n * The class is currently being used by various postprocessing steps\n * and loaders (ie. LWS).\n */\nclass ASSIMP_API SceneCombiner {\n    // class cannot be instanced\n    SceneCombiner() {\n        // empty\n    }\n\n    ~SceneCombiner() {\n        // empty\n    }\n\npublic:\n    // -------------------------------------------------------------------\n    /** Merges two or more scenes.\n     *\n     *  @param dest  Receives a pointer to the destination scene. If the\n     *    pointer doesn't point to NULL when the function is called, the\n     *    existing scene is cleared and refilled.\n     *  @param src Non-empty list of scenes to be merged. The function\n     *    deletes the input scenes afterwards. There may be duplicate scenes.\n     *  @param flags Combination of the AI_INT_MERGE_SCENE flags defined above\n     */\n    static void MergeScenes(aiScene** dest,std::vector<aiScene*>& src,\n        unsigned int flags = 0);\n\n    // -------------------------------------------------------------------\n    /** Merges two or more scenes and attaches all scenes to a specific\n     *  position in the node graph of the master scene.\n     *\n     *  @param dest Receives a pointer to the destination scene. If the\n     *    pointer doesn't point to NULL when the function is called, the\n     *    existing scene is cleared and refilled.\n     *  @param master Master scene. It will be deleted afterwards. All\n     *    other scenes will be inserted in its node graph.\n     *  @param src Non-empty list of scenes to be merged along with their\n     *    corresponding attachment points in the master scene. The function\n     *    deletes the input scenes afterwards. There may be duplicate scenes.\n     *  @param flags Combination of the AI_INT_MERGE_SCENE flags defined above\n     */\n    static void MergeScenes(aiScene** dest, aiScene* master,\n        std::vector<AttachmentInfo>& src,\n        unsigned int flags = 0);\n\n    // -------------------------------------------------------------------\n    /** Merges two or more meshes\n     *\n     *  The meshes should have equal vertex formats. Only components\n     *  that are provided by ALL meshes will be present in the output mesh.\n     *  An exception is made for VColors - they are set to black. The\n     *  meshes should have the same material indices, too. The output\n     *  material index is always the material index of the first mesh.\n     *\n     *  @param dest Destination mesh. Must be empty.\n     *  @param flags Currently no parameters\n     *  @param begin First mesh to be processed\n     *  @param end Points to the mesh after the last mesh to be processed\n     */\n    static void MergeMeshes(aiMesh** dest,unsigned int flags,\n        std::vector<aiMesh*>::const_iterator begin,\n        std::vector<aiMesh*>::const_iterator end);\n\n    // -------------------------------------------------------------------\n    /** Merges two or more bones\n     *\n     *  @param out Mesh to receive the output bone list\n     *  @param flags Currently no parameters\n     *  @param begin First mesh to be processed\n     *  @param end Points to the mesh after the last mesh to be processed\n     */\n    static void MergeBones(aiMesh* out,std::vector<aiMesh*>::const_iterator it,\n        std::vector<aiMesh*>::const_iterator end);\n\n    // -------------------------------------------------------------------\n    /** Merges two or more materials\n     *\n     *  The materials should be complementary as much as possible. In case\n     *  of a property present in different materials, the first occurrence\n     *  is used.\n     *\n     *  @param dest Destination material. Must be empty.\n     *  @param begin First material to be processed\n     *  @param end Points to the material after the last material to be processed\n     */\n    static void MergeMaterials(aiMaterial** dest,\n        std::vector<aiMaterial*>::const_iterator begin,\n        std::vector<aiMaterial*>::const_iterator end);\n\n    // -------------------------------------------------------------------\n    /** Builds a list of uniquely named bones in a mesh list\n     *\n     *  @param asBones Receives the output list\n     *  @param it First mesh to be processed\n     *  @param end Last mesh to be processed\n     */\n    static void BuildUniqueBoneList(std::list<BoneWithHash>& asBones,\n        std::vector<aiMesh*>::const_iterator it,\n        std::vector<aiMesh*>::const_iterator end);\n\n    // -------------------------------------------------------------------\n    /** Add a name prefix to all nodes in a scene.\n     *\n     *  @param Current node. This function is called recursively.\n     *  @param prefix Prefix to be added to all nodes\n     *  @param len STring length\n     */\n    static void AddNodePrefixes(aiNode* node, const char* prefix,\n        unsigned int len);\n\n    // -------------------------------------------------------------------\n    /** Add an offset to all mesh indices in a node graph\n     *\n     *  @param Current node. This function is called recursively.\n     *  @param offset Offset to be added to all mesh indices\n     */\n    static void OffsetNodeMeshIndices (aiNode* node, unsigned int offset);\n\n    // -------------------------------------------------------------------\n    /** Attach a list of node graphs to well-defined nodes in a master\n     *  graph. This is a helper for MergeScenes()\n     *\n     *  @param master Master scene\n     *  @param srcList List of source scenes along with their attachment\n     *    points. If an attachment point is NULL (or does not exist in\n     *    the master graph), a scene is attached to the root of the master\n     *    graph (as an additional child node)\n     *  @duplicates List of duplicates. If elem[n] == n the scene is not\n     *    a duplicate. Otherwise elem[n] links scene n to its first occurrence.\n     */\n    static void AttachToGraph ( aiScene* master,\n        std::vector<NodeAttachmentInfo>& srcList);\n\n    static void AttachToGraph (aiNode* attach,\n        std::vector<NodeAttachmentInfo>& srcList);\n\n\n    // -------------------------------------------------------------------\n    /** Get a deep copy of a scene\n     *\n     *  @param dest Receives a pointer to the destination scene\n     *  @param src Source scene - remains unmodified.\n     */\n    static void CopyScene(aiScene** dest,const aiScene* source,bool allocate = true);\n\n\n    // -------------------------------------------------------------------\n    /** Get a flat copy of a scene\n     *\n     *  Only the first hierarchy layer is copied. All pointer members of\n     *  aiScene are shared by source and destination scene.  If the\n     *    pointer doesn't point to NULL when the function is called, the\n     *    existing scene is cleared and refilled.\n     *  @param dest Receives a pointer to the destination scene\n     *  @param src Source scene - remains unmodified.\n     */\n    static void CopySceneFlat(aiScene** dest,const aiScene* source);\n\n\n    // -------------------------------------------------------------------\n    /** Get a deep copy of a mesh\n     *\n     *  @param dest Receives a pointer to the destination mesh\n     *  @param src Source mesh - remains unmodified.\n     */\n    static void Copy     (aiMesh** dest, const aiMesh* src);\n\n    // similar to Copy():\n    static void Copy  (aiAnimMesh** dest, const aiAnimMesh* src);\n    static void Copy  (aiMaterial** dest, const aiMaterial* src);\n    static void Copy  (aiTexture** dest, const aiTexture* src);\n    static void Copy  (aiAnimation** dest, const aiAnimation* src);\n    static void Copy  (aiCamera** dest, const aiCamera* src);\n    static void Copy  (aiBone** dest, const aiBone* src);\n    static void Copy  (aiLight** dest, const aiLight* src);\n    static void Copy  (aiNodeAnim** dest, const aiNodeAnim* src);\n    static void Copy  (aiMetadata** dest, const aiMetadata* src);\n\n    // recursive, of course\n    static void Copy     (aiNode** dest, const aiNode* src);\n\n\nprivate:\n\n    // -------------------------------------------------------------------\n    // Same as AddNodePrefixes, but with an additional check\n    static void AddNodePrefixesChecked(aiNode* node, const char* prefix,\n        unsigned int len,\n        std::vector<SceneHelper>& input,\n        unsigned int cur);\n\n    // -------------------------------------------------------------------\n    // Add node identifiers to a hashing set\n    static void AddNodeHashes(aiNode* node, std::set<unsigned int>& hashes);\n\n\n    // -------------------------------------------------------------------\n    // Search for duplicate names\n    static bool FindNameMatch(const aiString& name,\n        std::vector<SceneHelper>& input, unsigned int cur);\n};\n\n}\n\n#endif // !! AI_SCENE_COMBINER_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SceneCombiner.h b/include/assimp/SceneCombiner.h
--- a/include/assimp/SceneCombiner.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SceneCombiner.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -43,17 +43,22 @@
 /** @file Declares a helper class, "SceneCombiner" providing various
  *  utilities to merge scenes.
  */
+#pragma once
 #ifndef AI_SCENE_COMBINER_H_INC
 #define AI_SCENE_COMBINER_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/ai_assert.h>
 #include <assimp/types.h>
 #include <assimp/Defines.h>
+
 #include <stddef.h>
 #include <set>
 #include <list>
 #include <stdint.h>
-
 #include <vector>
 
 struct aiScene;
@@ -68,6 +73,7 @@
 struct aiAnimMesh;
 struct aiAnimation;
 struct aiNodeAnim;
+struct aiMeshMorphAnim;
 
 namespace Assimp    {
 
@@ -372,6 +378,7 @@
     static void Copy  (aiBone** dest, const aiBone* src);
     static void Copy  (aiLight** dest, const aiLight* src);
     static void Copy  (aiNodeAnim** dest, const aiNodeAnim* src);
+    static void Copy  (aiMeshMorphAnim** dest, const aiMeshMorphAnim* src);
     static void Copy  (aiMetadata** dest, const aiMetadata* src);
 
     // recursive, of course
Index: include/assimp/irrXMLWrapper.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#ifndef INCLUDED_AI_IRRXML_WRAPPER\n#define INCLUDED_AI_IRRXML_WRAPPER\n\n// some long includes ....\n#ifdef ASSIMP_USE_HUNTER\n#  include <irrXML/irrXML.h>\n#else\n#  include <irrXML.h>\n#endif\n#include \"IOStream.hpp\"\n#include \"BaseImporter.h\"\n#include <vector>\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------------\n/** @brief Utility class to make IrrXML work together with our custom IO system\n *  See the IrrXML docs for more details.\n *\n *  Construct IrrXML-Reader in BaseImporter::InternReadFile():\n *  @code\n * // open the file\n * std::unique_ptr<IOStream> file( pIOHandler->Open( pFile));\n * if( file.get() == NULL) {\n *    throw DeadlyImportError( \"Failed to open file \" + pFile + \".\");\n * }\n *\n * // generate a XML reader for it\n * std::unique_ptr<CIrrXML_IOStreamReader> mIOWrapper( new CIrrXML_IOStreamReader( file.get()));\n * mReader = irr::io::createIrrXMLReader( mIOWrapper.get());\n * if( !mReader) {\n *    ThrowException( \"xxxx: Unable to open file.\");\n * }\n * @endcode\n **/\nclass CIrrXML_IOStreamReader : public irr::io::IFileReadCallBack {\npublic:\n\n    // ----------------------------------------------------------------------------------\n    //! Construction from an existing IOStream\n    explicit CIrrXML_IOStreamReader(IOStream* _stream)\n        : stream (_stream)\n        , t (0)\n    {\n\n        // Map the buffer into memory and convert it to UTF8. IrrXML provides its\n        // own conversion, which is merely a cast from uintNN_t to uint8_t. Thus,\n        // it is not suitable for our purposes and we have to do it BEFORE IrrXML\n        // gets the buffer. Sadly, this forces us to map the whole file into\n        // memory.\n\n        data.resize(stream->FileSize());\n        stream->Read(&data[0],data.size(),1);\n\n        // Remove null characters from the input sequence otherwise the parsing will utterly fail\n        // std::find is usually much faster than manually iterating\n        // It is very unlikely that there will be any null characters\n        auto null_char_iter = std::find(data.begin(), data.end(), '\\0');\n\n        while (null_char_iter != data.end())\n        {\n            null_char_iter = data.erase(null_char_iter);\n            null_char_iter = std::find(null_char_iter, data.end(), '\\0');\n        }\n\n        BaseImporter::ConvertToUTF8(data);\n    }\n\n    // ----------------------------------------------------------------------------------\n    //! Virtual destructor\n    virtual ~CIrrXML_IOStreamReader() {}\n\n    // ----------------------------------------------------------------------------------\n    //!   Reads an amount of bytes from the file.\n    /**  @param buffer:       Pointer to output buffer.\n     *   @param sizeToRead:   Amount of bytes to read\n     *   @return              Returns how much bytes were read.  */\n    virtual int read(void* buffer, int sizeToRead)  {\n        if(sizeToRead<0) {\n            return 0;\n        }\n        if(t+sizeToRead>data.size()) {\n            sizeToRead = static_cast<int>(data.size()-t);\n        }\n\n        memcpy(buffer,&data.front()+t,sizeToRead);\n\n        t += sizeToRead;\n        return sizeToRead;\n    }\n\n    // ----------------------------------------------------------------------------------\n    //! Returns size of file in bytes\n    virtual int getSize()   {\n        return (int)data.size();\n    }\n\nprivate:\n    IOStream* stream;\n    std::vector<char> data;\n    size_t t;\n\n}; // ! class CIrrXML_IOStreamReader\n\n} // ! Assimp\n\n#endif // !! INCLUDED_AI_IRRXML_WRAPPER\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/irrXMLWrapper.h b/include/assimp/irrXMLWrapper.h
--- a/include/assimp/irrXMLWrapper.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/irrXMLWrapper.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
Index: include/assimp/vector2.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  vector2.inl\n *  @brief Inline implementation of aiVector2t<TReal> operators\n */\n#pragma once\n#ifndef AI_VECTOR2D_INL_INC\n#define AI_VECTOR2D_INL_INC\n\n#ifdef __cplusplus\n#include \"vector2.h\"\n\n#include <cmath>\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ntemplate <typename TOther>\naiVector2t<TReal>::operator aiVector2t<TOther> () const {\n    return aiVector2t<TOther>(static_cast<TOther>(x),static_cast<TOther>(y));\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nvoid aiVector2t<TReal>::Set( TReal pX, TReal pY) {\n    x = pX; y = pY;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nTReal aiVector2t<TReal>::SquareLength() const {\n    return x*x + y*y;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nTReal aiVector2t<TReal>::Length() const {\n    return std::sqrt( SquareLength());\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\naiVector2t<TReal>& aiVector2t<TReal>::Normalize() {\n    *this /= Length();\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nconst aiVector2t<TReal>& aiVector2t<TReal>::operator += (const aiVector2t& o) {\n    x += o.x; y += o.y;\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nconst aiVector2t<TReal>& aiVector2t<TReal>::operator -= (const aiVector2t& o) {\n    x -= o.x; y -= o.y;\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nconst aiVector2t<TReal>& aiVector2t<TReal>::operator *= (TReal f) {\n    x *= f; y *= f;\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nconst aiVector2t<TReal>& aiVector2t<TReal>::operator /= (TReal f) {\n    x /= f; y /= f;\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nTReal aiVector2t<TReal>::operator[](unsigned int i) const {\n\tswitch (i) {\n\t\tcase 0:\n\t\t\treturn x;\n\t\tcase 1:\n\t\t\treturn y;\n\t\tdefault:\n\t\t\tbreak;\n\n    }\n    return x;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nbool aiVector2t<TReal>::operator== (const aiVector2t& other) const {\n    return x == other.x && y == other.y;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nbool aiVector2t<TReal>::operator!= (const aiVector2t& other) const {\n    return x != other.x || y != other.y;\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline\nbool aiVector2t<TReal>::Equal(const aiVector2t& other, TReal epsilon) const {\n    return\n        std::abs(x - other.x) <= epsilon &&\n        std::abs(y - other.y) <= epsilon;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\naiVector2t<TReal>& aiVector2t<TReal>::operator= (TReal f)   {\n    x = y = f;\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline\nconst aiVector2t<TReal> aiVector2t<TReal>::SymMul(const aiVector2t& o) {\n    return aiVector2t(x*o.x,y*o.y);\n}\n\n\n// ------------------------------------------------------------------------------------------------\n// symmetric addition\ntemplate <typename TReal>\ninline\naiVector2t<TReal> operator + (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {\n    return aiVector2t<TReal>( v1.x + v2.x, v1.y + v2.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// symmetric subtraction\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {\n    return aiVector2t<TReal>( v1.x - v2.x, v1.y - v2.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// scalar product\ntemplate <typename TReal>\ninline \nTReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {\n    return v1.x*v2.x + v1.y*v2.y;\n}\n\n// ------------------------------------------------------------------------------------------------\n// scalar multiplication\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v) {\n    return aiVector2t<TReal>( f*v.x, f*v.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// and the other way around\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f) {\n    return aiVector2t<TReal>( f*v.x, f*v.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// scalar division\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f) {\n    return v * (1/f);\n}\n\n// ------------------------------------------------------------------------------------------------\n// vector division\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TReal>& v2) {\n    return aiVector2t<TReal>(v.x / v2.x,v.y / v2.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// vector negation\ntemplate <typename TReal>\ninline \naiVector2t<TReal> operator - ( const aiVector2t<TReal>& v) {\n    return aiVector2t<TReal>( -v.x, -v.y);\n}\n\n#endif\n\n#endif // AI_VECTOR2D_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/vector2.inl b/include/assimp/vector2.inl
--- a/include/assimp/vector2.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/vector2.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,8 +48,12 @@
 #ifndef AI_VECTOR2D_INL_INC
 #define AI_VECTOR2D_INL_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
-#include "vector2.h"
+#include <assimp/vector2.h>
 
 #include <cmath>
 
Index: include/assimp/IOSystem.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file IOSystem.hpp\n *  @brief File system wrapper for C++. Inherit this class to supply\n *  custom file handling logic to the Import library.\n*/\n\n#pragma once\n#ifndef AI_IOSYSTEM_H_INC\n#define AI_IOSYSTEM_H_INC\n\n#ifndef __cplusplus\n#   error This header requires C++ to be used. aiFileIO.h is the \\\n    corresponding C interface.\n#endif\n\n#include \"types.h\"\n\n#ifdef _WIN32\n#   include <direct.h>  \n#   include <stdlib.h>  \n#   include <stdio.h>  \n#else\n#   include <sys/stat.h>\n#   include <sys/types.h>\n#   include <unistd.h>\n#endif // _WIN32\n\n#include <vector>\n\nnamespace Assimp    {\n\n    class IOStream;\n\n// ---------------------------------------------------------------------------\n/** @brief CPP-API: Interface to the file system.\n *\n *  Derive an own implementation from this interface to supply custom file handling\n *  to the importer library. If you implement this interface, you also want to\n *  supply a custom implementation for IOStream.\n *\n *  @see Importer::SetIOHandler() \n */\nclass ASSIMP_API IOSystem\n#ifndef SWIG\n    : public Intern::AllocateFromAssimpHeap\n#endif\n{\npublic:\n\n    // -------------------------------------------------------------------\n    /** @brief Default constructor.\n     *\n     *  Create an instance of your derived class and assign it to an\n     *  #Assimp::Importer instance by calling Importer::SetIOHandler().\n     */\n    IOSystem() AI_NO_EXCEPT;\n\n    // -------------------------------------------------------------------\n    /** @brief Virtual destructor.\n     *\n     *  It is safe to be called from within DLL Assimp, we're constructed\n     *  on Assimp's heap.\n     */\n    virtual ~IOSystem();\n\n    // -------------------------------------------------------------------\n    /** @brief For backward compatibility\n     *  @see Exists(const char*)\n     */\n    AI_FORCE_INLINE bool Exists( const std::string& pFile) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Tests for the existence of a file at the given path.\n     *\n     * @param pFile Path to the file\n     * @return true if there is a file with this path, else false.\n     */\n    virtual bool Exists( const char* pFile) const = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Returns the system specific directory separator\n     *  @return System specific directory separator\n     */\n    virtual char getOsSeparator() const = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Open a new file with a given path.\n     *\n     *  When the access to the file is finished, call Close() to release\n     *  all associated resources (or the virtual dtor of the IOStream).\n     *\n     *  @param pFile Path to the file\n     *  @param pMode Desired file I/O mode. Required are: \"wb\", \"w\", \"wt\",\n     *         \"rb\", \"r\", \"rt\".\n     *\n     *  @return New IOStream interface allowing the lib to access\n     *         the underlying file.\n     *  @note When implementing this class to provide custom IO handling,\n     *  you probably have to supply an own implementation of IOStream as well.\n     */\n    virtual IOStream* Open(const char* pFile,\n        const char* pMode = \"rb\") = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief For backward compatibility\n     *  @see Open(const char*, const char*)\n     */\n    inline IOStream* Open(const std::string& pFile,\n        const std::string& pMode = std::string(\"rb\"));\n\n    // -------------------------------------------------------------------\n    /** @brief Closes the given file and releases all resources\n     *    associated with it.\n     *  @param pFile The file instance previously created by Open().\n     */\n    virtual void Close( IOStream* pFile) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Compares two paths and check whether the point to\n     *         identical files.\n     *\n     * The dummy implementation of this virtual member performs a\n     * case-insensitive comparison of the given strings. The default IO\n     * system implementation uses OS mechanisms to convert relative into\n     * absolute paths, so the result can be trusted.\n     * @param one First file\n     * @param second Second file\n     * @return true if the paths point to the same file. The file needn't\n     *   be existing, however.\n     */\n    virtual bool ComparePaths (const char* one,\n        const char* second) const;\n\n    // -------------------------------------------------------------------\n    /** @brief For backward compatibility\n     *  @see ComparePaths(const char*, const char*)\n     */\n    inline bool ComparePaths (const std::string& one,\n        const std::string& second) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Pushes a new directory onto the directory stack.\n     *  @param path Path to push onto the stack.\n     *  @return True, when push was successful, false if path is empty.\n     */\n    virtual bool PushDirectory( const std::string &path );\n\n    // -------------------------------------------------------------------\n    /** @brief Returns the top directory from the stack.\n     *  @return The directory on the top of the stack.\n     *          Returns empty when no directory was pushed to the stack.\n     */\n    virtual const std::string &CurrentDirectory() const;\n\n    // -------------------------------------------------------------------\n    /** @brief Returns the number of directories stored on the stack.\n     *  @return The number of directories of the stack.\n     */\n    virtual size_t StackSize() const;\n\n    // -------------------------------------------------------------------\n    /** @brief Pops the top directory from the stack.\n     *  @return True, when a directory was on the stack. False if no\n     *          directory was on the stack.\n     */\n    virtual bool PopDirectory();\n\n    // -------------------------------------------------------------------\n    /** @brief CReates an new directory at the given path.\n     *  @param  path    [in] The path to create.\n     *  @return True, when a directory was created. False if the directory\n     *           cannot be created.\n     */\n    virtual bool CreateDirectory( const std::string &path );\n\n    // -------------------------------------------------------------------\n    /** @brief Will change the current directory to the given path.\n     *  @param path     [in] The path to change to.\n     *  @return True, when the directory has changed successfully.\n     */\n    virtual bool ChangeDirectory( const std::string &path );\n\n    virtual bool DeleteFile( const std::string &file );\n\nprivate:\n    std::vector<std::string> m_pathStack;\n};\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nIOSystem::IOSystem() AI_NO_EXCEPT\n: m_pathStack() {\n    // empty\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nIOSystem::~IOSystem() {\n    // empty\n}\n\n// ----------------------------------------------------------------------------\n// For compatibility, the interface of some functions taking a std::string was\n// changed to const char* to avoid crashes between binary incompatible STL\n// versions. This code her is inlined,  so it shouldn't cause any problems.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nIOStream* IOSystem::Open(const std::string& pFile, const std::string& pMode) {\n    // NOTE:\n    // For compatibility, interface was changed to const char* to\n    // avoid crashes between binary incompatible STL versions\n    return Open(pFile.c_str(),pMode.c_str());\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::Exists( const std::string& pFile) const {\n    // NOTE:\n    // For compatibility, interface was changed to const char* to\n    // avoid crashes between binary incompatible STL versions\n    return Exists(pFile.c_str());\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::ComparePaths (const std::string& one, const std::string& second) const {\n    // NOTE:\n    // For compatibility, interface was changed to const char* to\n    // avoid crashes between binary incompatible STL versions\n    return ComparePaths(one.c_str(),second.c_str());\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::PushDirectory( const std::string &path ) {\n    if ( path.empty() ) {\n        return false;\n    }\n\n    m_pathStack.push_back( path );\n\n    return true;\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nconst std::string &IOSystem::CurrentDirectory() const {\n    if ( m_pathStack.empty() ) {\n        static const std::string Dummy(\"\");\n        return Dummy;\n    }\n    return m_pathStack[ m_pathStack.size()-1 ];\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nsize_t IOSystem::StackSize() const {\n    return m_pathStack.size();\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::PopDirectory() {\n    if ( m_pathStack.empty() ) {\n        return false;\n    }\n\n    m_pathStack.pop_back();\n\n    return true;\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::CreateDirectory( const std::string &path ) {\n    if ( path.empty() ) {\n        return false;\n    }\n\n#ifdef _WIN32\n    return 0 != ::_mkdir( path.c_str() );\n#else\n    return 0 != ::mkdir( path.c_str(), 0777 );\n#endif // _WIN32\n}\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::ChangeDirectory( const std::string &path ) {\n    if ( path.empty() ) {\n        return false;\n    }\n\n#ifdef _WIN32\n    return 0 != ::_chdir( path.c_str() );\n#else\n    return 0 != ::chdir( path.c_str() );\n#endif // _WIN32\n}\n\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE\nbool IOSystem::DeleteFile( const std::string &file ) {\n    if ( file.empty() ) {\n        return false;\n    }\n    const int retCode( ::remove( file.c_str() ) );\n    return ( 0 == retCode );\n}\n} //!ns Assimp\n\n#endif //AI_IOSYSTEM_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/IOSystem.hpp b/include/assimp/IOSystem.hpp
--- a/include/assimp/IOSystem.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/IOSystem.hpp	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -50,6 +50,10 @@
 #ifndef AI_IOSYSTEM_H_INC
 #define AI_IOSYSTEM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifndef __cplusplus
 #   error This header requires C++ to be used. aiFileIO.h is the \
     corresponding C interface.
Index: include/assimp/matrix4x4.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file matrix4x4.inl\n *  @brief Inline implementation of the 4x4 matrix operators\n */\n#pragma once\n#ifndef AI_MATRIX4X4_INL_INC\n#define AI_MATRIX4X4_INL_INC\n\n#ifdef __cplusplus\n\n#include \"matrix4x4.h\"\n#include \"matrix3x3.h\"\n#include \"quaternion.h\"\n#include \"MathFunctions.h\"\n\n#include <algorithm>\n#include <limits>\n#include <cmath>\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\naiMatrix4x4t<TReal>::aiMatrix4x4t() AI_NO_EXCEPT :\n    a1(1.0f), a2(), a3(), a4(),\n    b1(), b2(1.0f), b3(), b4(),\n    c1(), c2(), c3(1.0f), c4(),\n    d1(), d2(), d3(), d4(1.0f)\n{\n\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\naiMatrix4x4t<TReal>::aiMatrix4x4t (TReal _a1, TReal _a2, TReal _a3, TReal _a4,\n              TReal _b1, TReal _b2, TReal _b3, TReal _b4,\n              TReal _c1, TReal _c2, TReal _c3, TReal _c4,\n              TReal _d1, TReal _d2, TReal _d3, TReal _d4) :\n    a1(_a1), a2(_a2), a3(_a3), a4(_a4),\n    b1(_b1), b2(_b2), b3(_b3), b4(_b4),\n    c1(_c1), c2(_c2), c3(_c3), c4(_c4),\n    d1(_d1), d2(_d2), d3(_d3), d4(_d4)\n{\n\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ntemplate <typename TOther>\naiMatrix4x4t<TReal>::operator aiMatrix4x4t<TOther> () const\n{\n    return aiMatrix4x4t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),static_cast<TOther>(a4),\n        static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),static_cast<TOther>(b4),\n        static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3),static_cast<TOther>(c4),\n        static_cast<TOther>(d1),static_cast<TOther>(d2),static_cast<TOther>(d3),static_cast<TOther>(d4));\n}\n\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiMatrix3x3t<TReal>& m)\n{\n    a1 = m.a1; a2 = m.a2; a3 = m.a3; a4 = static_cast<TReal>(0.0);\n    b1 = m.b1; b2 = m.b2; b3 = m.b3; b4 = static_cast<TReal>(0.0);\n    c1 = m.c1; c2 = m.c2; c3 = m.c3; c4 = static_cast<TReal>(0.0);\n    d1 = static_cast<TReal>(0.0); d2 = static_cast<TReal>(0.0); d3 = static_cast<TReal>(0.0); d4 = static_cast<TReal>(1.0);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation, const aiVector3t<TReal>& position)\n{\n    // build a 3x3 rotation matrix\n    aiMatrix3x3t<TReal> m = rotation.GetMatrix();\n\n    a1 = m.a1 * scaling.x;\n    a2 = m.a2 * scaling.x;\n    a3 = m.a3 * scaling.x;\n    a4 = position.x;\n\n    b1 = m.b1 * scaling.y;\n    b2 = m.b2 * scaling.y;\n    b3 = m.b3 * scaling.y;\n    b4 = position.y;\n\n    c1 = m.c1 * scaling.z;\n    c2 = m.c2 * scaling.z;\n    c3 = m.c3 * scaling.z;\n    c4= position.z;\n\n    d1 = static_cast<TReal>(0.0);\n    d2 = static_cast<TReal>(0.0);\n    d3 = static_cast<TReal>(0.0);\n    d4 = static_cast<TReal>(1.0);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::operator *= (const aiMatrix4x4t<TReal>& m)\n{\n    *this = aiMatrix4x4t<TReal>(\n        m.a1 * a1 + m.b1 * a2 + m.c1 * a3 + m.d1 * a4,\n        m.a2 * a1 + m.b2 * a2 + m.c2 * a3 + m.d2 * a4,\n        m.a3 * a1 + m.b3 * a2 + m.c3 * a3 + m.d3 * a4,\n        m.a4 * a1 + m.b4 * a2 + m.c4 * a3 + m.d4 * a4,\n        m.a1 * b1 + m.b1 * b2 + m.c1 * b3 + m.d1 * b4,\n        m.a2 * b1 + m.b2 * b2 + m.c2 * b3 + m.d2 * b4,\n        m.a3 * b1 + m.b3 * b2 + m.c3 * b3 + m.d3 * b4,\n        m.a4 * b1 + m.b4 * b2 + m.c4 * b3 + m.d4 * b4,\n        m.a1 * c1 + m.b1 * c2 + m.c1 * c3 + m.d1 * c4,\n        m.a2 * c1 + m.b2 * c2 + m.c2 * c3 + m.d2 * c4,\n        m.a3 * c1 + m.b3 * c2 + m.c3 * c3 + m.d3 * c4,\n        m.a4 * c1 + m.b4 * c2 + m.c4 * c3 + m.d4 * c4,\n        m.a1 * d1 + m.b1 * d2 + m.c1 * d3 + m.d1 * d4,\n        m.a2 * d1 + m.b2 * d2 + m.c2 * d3 + m.d2 * d4,\n        m.a3 * d1 + m.b3 * d2 + m.c3 * d3 + m.d3 * d4,\n        m.a4 * d1 + m.b4 * d2 + m.c4 * d3 + m.d4 * d4);\n    return *this;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const TReal& aFloat) const\n{\n    aiMatrix4x4t<TReal> temp(\n        a1 * aFloat,\n        a2 * aFloat,\n        a3 * aFloat,\n        a4 * aFloat,\n        b1 * aFloat,\n        b2 * aFloat,\n        b3 * aFloat,\n        b4 * aFloat,\n        c1 * aFloat,\n        c2 * aFloat,\n        c3 * aFloat,\n        c4 * aFloat,\n        d1 * aFloat,\n        d2 * aFloat,\n        d3 * aFloat,\n        d4 * aFloat);\n    return temp;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator+ (const aiMatrix4x4t<TReal>& m) const\n{\n    aiMatrix4x4t<TReal> temp(\n        m.a1 + a1,\n        m.a2 + a2,\n        m.a3 + a3,\n        m.a4 + a4,\n        m.b1 + b1,\n        m.b2 + b2,\n        m.b3 + b3,\n        m.b4 + b4,\n        m.c1 + c1,\n        m.c2 + c2,\n        m.c3 + c3,\n        m.c4 + c4,\n        m.d1 + d1,\n        m.d2 + d2,\n        m.d3 + d3,\n        m.d4 + d4);\n    return temp;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const aiMatrix4x4t<TReal>& m) const\n{\n    aiMatrix4x4t<TReal> temp( *this);\n    temp *= m;\n    return temp;\n}\n\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Transpose()\n{\n    // (TReal&) don't remove, GCC complains cause of packed fields\n    std::swap( (TReal&)b1, (TReal&)a2);\n    std::swap( (TReal&)c1, (TReal&)a3);\n    std::swap( (TReal&)c2, (TReal&)b3);\n    std::swap( (TReal&)d1, (TReal&)a4);\n    std::swap( (TReal&)d2, (TReal&)b4);\n    std::swap( (TReal&)d3, (TReal&)c4);\n    return *this;\n}\n\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline TReal aiMatrix4x4t<TReal>::Determinant() const\n{\n    return a1*b2*c3*d4 - a1*b2*c4*d3 + a1*b3*c4*d2 - a1*b3*c2*d4\n        + a1*b4*c2*d3 - a1*b4*c3*d2 - a2*b3*c4*d1 + a2*b3*c1*d4\n        - a2*b4*c1*d3 + a2*b4*c3*d1 - a2*b1*c3*d4 + a2*b1*c4*d3\n        + a3*b4*c1*d2 - a3*b4*c2*d1 + a3*b1*c2*d4 - a3*b1*c4*d2\n        + a3*b2*c4*d1 - a3*b2*c1*d4 - a4*b1*c2*d3 + a4*b1*c3*d2\n        - a4*b2*c3*d1 + a4*b2*c1*d3 - a4*b3*c1*d2 + a4*b3*c2*d1;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Inverse()\n{\n    // Compute the reciprocal determinant\n    const TReal det = Determinant();\n    if(det == static_cast<TReal>(0.0))\n    {\n        // Matrix not invertible. Setting all elements to nan is not really\n        // correct in a mathematical sense but it is easy to debug for the\n        // programmer.\n        const TReal nan = std::numeric_limits<TReal>::quiet_NaN();\n        *this = aiMatrix4x4t<TReal>(\n            nan,nan,nan,nan,\n            nan,nan,nan,nan,\n            nan,nan,nan,nan,\n            nan,nan,nan,nan);\n\n        return *this;\n    }\n\n    const TReal invdet = static_cast<TReal>(1.0) / det;\n\n    aiMatrix4x4t<TReal> res;\n    res.a1 = invdet  * (b2 * (c3 * d4 - c4 * d3) + b3 * (c4 * d2 - c2 * d4) + b4 * (c2 * d3 - c3 * d2));\n    res.a2 = -invdet * (a2 * (c3 * d4 - c4 * d3) + a3 * (c4 * d2 - c2 * d4) + a4 * (c2 * d3 - c3 * d2));\n    res.a3 = invdet  * (a2 * (b3 * d4 - b4 * d3) + a3 * (b4 * d2 - b2 * d4) + a4 * (b2 * d3 - b3 * d2));\n    res.a4 = -invdet * (a2 * (b3 * c4 - b4 * c3) + a3 * (b4 * c2 - b2 * c4) + a4 * (b2 * c3 - b3 * c2));\n    res.b1 = -invdet * (b1 * (c3 * d4 - c4 * d3) + b3 * (c4 * d1 - c1 * d4) + b4 * (c1 * d3 - c3 * d1));\n    res.b2 = invdet  * (a1 * (c3 * d4 - c4 * d3) + a3 * (c4 * d1 - c1 * d4) + a4 * (c1 * d3 - c3 * d1));\n    res.b3 = -invdet * (a1 * (b3 * d4 - b4 * d3) + a3 * (b4 * d1 - b1 * d4) + a4 * (b1 * d3 - b3 * d1));\n    res.b4 = invdet  * (a1 * (b3 * c4 - b4 * c3) + a3 * (b4 * c1 - b1 * c4) + a4 * (b1 * c3 - b3 * c1));\n    res.c1 = invdet  * (b1 * (c2 * d4 - c4 * d2) + b2 * (c4 * d1 - c1 * d4) + b4 * (c1 * d2 - c2 * d1));\n    res.c2 = -invdet * (a1 * (c2 * d4 - c4 * d2) + a2 * (c4 * d1 - c1 * d4) + a4 * (c1 * d2 - c2 * d1));\n    res.c3 = invdet  * (a1 * (b2 * d4 - b4 * d2) + a2 * (b4 * d1 - b1 * d4) + a4 * (b1 * d2 - b2 * d1));\n    res.c4 = -invdet * (a1 * (b2 * c4 - b4 * c2) + a2 * (b4 * c1 - b1 * c4) + a4 * (b1 * c2 - b2 * c1));\n    res.d1 = -invdet * (b1 * (c2 * d3 - c3 * d2) + b2 * (c3 * d1 - c1 * d3) + b3 * (c1 * d2 - c2 * d1));\n    res.d2 = invdet  * (a1 * (c2 * d3 - c3 * d2) + a2 * (c3 * d1 - c1 * d3) + a3 * (c1 * d2 - c2 * d1));\n    res.d3 = -invdet * (a1 * (b2 * d3 - b3 * d2) + a2 * (b3 * d1 - b1 * d3) + a3 * (b1 * d2 - b2 * d1));\n    res.d4 = invdet  * (a1 * (b2 * c3 - b3 * c2) + a2 * (b3 * c1 - b1 * c3) + a3 * (b1 * c2 - b2 * c1));\n    *this = res;\n\n    return *this;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) {\n    if (p_iIndex > 3) {\n        return NULL;\n    }\n    switch ( p_iIndex ) {\n        case 0:\n            return &a1;\n        case 1:\n            return &b1;\n        case 2:\n            return &c1;\n        case 3:\n            return &d1;\n        default:\n            break;\n    }\n    return &a1;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline const TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) const {\n    if (p_iIndex > 3) {\n        return NULL;\n    }\n\n    switch ( p_iIndex ) {\n        case 0:\n            return &a1;\n        case 1:\n            return &b1;\n        case 2:\n            return &c1;\n        case 3:\n            return &d1;\n        default:\n            break;\n    }\n    return &a1;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiMatrix4x4t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const\n{\n    return (a1 == m.a1 && a2 == m.a2 && a3 == m.a3 && a4 == m.a4 &&\n            b1 == m.b1 && b2 == m.b2 && b3 == m.b3 && b4 == m.b4 &&\n            c1 == m.c1 && c2 == m.c2 && c3 == m.c3 && c4 == m.c4 &&\n            d1 == m.d1 && d2 == m.d2 && d3 == m.d3 && d4 == m.d4);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiMatrix4x4t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const\n{\n    return !(*this == m);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline bool aiMatrix4x4t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {\n    return\n        std::abs(a1 - m.a1) <= epsilon &&\n        std::abs(a2 - m.a2) <= epsilon &&\n        std::abs(a3 - m.a3) <= epsilon &&\n        std::abs(a4 - m.a4) <= epsilon &&\n        std::abs(b1 - m.b1) <= epsilon &&\n        std::abs(b2 - m.b2) <= epsilon &&\n        std::abs(b3 - m.b3) <= epsilon &&\n        std::abs(b4 - m.b4) <= epsilon &&\n        std::abs(c1 - m.c1) <= epsilon &&\n        std::abs(c2 - m.c2) <= epsilon &&\n        std::abs(c3 - m.c3) <= epsilon &&\n        std::abs(c4 - m.c4) <= epsilon &&\n        std::abs(d1 - m.d1) <= epsilon &&\n        std::abs(d2 - m.d2) <= epsilon &&\n        std::abs(d3 - m.d3) <= epsilon &&\n        std::abs(d4 - m.d4) <= epsilon;\n}\n\n// ----------------------------------------------------------------------------------------\n\n#define ASSIMP_MATRIX4_4_DECOMPOSE_PART\t\t\\\n\tconst aiMatrix4x4t<TReal>& _this = *this;/* Create alias for conveniance. */ \\\n\t\\\n\t/* extract translation */ \\\n\tpPosition.x = _this[0][3]; \\\n\tpPosition.y = _this[1][3]; \\\n\tpPosition.z = _this[2][3]; \\\n\t\\\n\t/* extract the columns of the matrix. */ \\\n\taiVector3t<TReal> vCols[3] = { \\\n\t\taiVector3t<TReal>(_this[0][0],_this[1][0],_this[2][0]), \\\n\t\taiVector3t<TReal>(_this[0][1],_this[1][1],_this[2][1]), \\\n\t\taiVector3t<TReal>(_this[0][2],_this[1][2],_this[2][2]) \\\n\t}; \\\n\t\\\n\t/* extract the scaling factors */ \\\n\tpScaling.x = vCols[0].Length(); \\\n\tpScaling.y = vCols[1].Length(); \\\n\tpScaling.z = vCols[2].Length(); \\\n\t\\\n\t/* and the sign of the scaling */ \\\n\tif (Determinant() < 0) pScaling = -pScaling; \\\n\t\\\n\t/* and remove all scaling from the matrix */ \\\n\tif(pScaling.x) vCols[0] /= pScaling.x; \\\n\tif(pScaling.y) vCols[1] /= pScaling.y; \\\n\tif(pScaling.z) vCols[2] /= pScaling.z; \\\n\t\\\n\tdo {} while(false)\n\n\n\n\ntemplate <typename TReal>\ninline void aiMatrix4x4t<TReal>::Decompose (aiVector3t<TReal>& pScaling, aiQuaterniont<TReal>& pRotation,\n    aiVector3t<TReal>& pPosition) const\n{\n\tASSIMP_MATRIX4_4_DECOMPOSE_PART;\n\n    // build a 3x3 rotation matrix\n    aiMatrix3x3t<TReal> m(vCols[0].x,vCols[1].x,vCols[2].x,\n        vCols[0].y,vCols[1].y,vCols[2].y,\n        vCols[0].z,vCols[1].z,vCols[2].z);\n\n    // and generate the rotation quaternion from it\n    pRotation = aiQuaterniont<TReal>(m);\n}\n\ntemplate <typename TReal>\ninline\nvoid aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const {\n\tASSIMP_MATRIX4_4_DECOMPOSE_PART;\n\n    /*\n    assuming a right-handed coordinate system\n    and post-multiplication of column vectors,\n    the rotation matrix for an euler XYZ rotation is M = Rz * Ry * Rx.\n    combining gives:\n    \n        |  CE  BDE-AF  ADE+BF  0  |\n    M = |  CF  BDF+AE  ADF-BE  0  |\n        |  -D    CB      AC    0  |\n        |   0     0       0    1  |\n\n    where\n\tA = cos(angle_x), B = sin(angle_x);\n\tC = cos(angle_y), D = sin(angle_y);\n\tE = cos(angle_z), F = sin(angle_z);\n\t*/\n\n\t// Use a small epsilon to solve floating-point inaccuracies\n    const TReal epsilon = Assimp::Math::getEpsilon<TReal>();\n\n\tpRotation.y  = std::asin(-vCols[0].z);// D. Angle around oY.\n\n\tTReal C = std::cos(pRotation.y);\n\n\tif(std::fabs(C) > epsilon)\n\t{\n\t\t// Finding angle around oX.\n\t\tTReal tan_x = vCols[2].z / C;// A\n\t\tTReal tan_y = vCols[1].z / C;// B\n\n\t\tpRotation.x = std::atan2(tan_y, tan_x);\n\t\t// Finding angle around oZ.\n\t\ttan_x = vCols[0].x / C;// E\n\t\ttan_y = vCols[0].y / C;// F\n\t\tpRotation.z = std::atan2(tan_y, tan_x);\n\t}\n\telse\n\t{// oY is fixed.\n\t\tpRotation.x = 0;// Set angle around oX to 0. => A == 1, B == 0, C == 0, D == 1.\n\n\t\t// And finding angle around oZ.\n\t\tTReal tan_x =  vCols[1].y;// BDF+AE => E\n\t\tTReal tan_y = -vCols[1].x;// BDE-AF => F\n\n\t\tpRotation.z = std::atan2(tan_y, tan_x);\n\t}\n}\n\n#undef ASSIMP_MATRIX4_4_DECOMPOSE_PART\n\ntemplate <typename TReal>\ninline void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle,\n\t\t\t\t\t\t\t\t\t\t\taiVector3t<TReal>& pPosition) const\n{\naiQuaterniont<TReal> pRotation;\n\n\tDecompose(pScaling, pRotation, pPosition);\n\tpRotation.Normalize();\n\n\tTReal angle_cos = pRotation.w;\n\tTReal angle_sin = std::sqrt(1.0f - angle_cos * angle_cos);\n\n\tpRotationAngle = std::acos(angle_cos) * 2;\n\n\t// Use a small epsilon to solve floating-point inaccuracies\n    const TReal epsilon = 10e-3f;\n\n\tif(std::fabs(angle_sin) < epsilon) angle_sin = 1;\n\n\tpRotationAxis.x = pRotation.x / angle_sin;\n\tpRotationAxis.y = pRotation.y / angle_sin;\n\tpRotationAxis.z = pRotation.z / angle_sin;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline void aiMatrix4x4t<TReal>::DecomposeNoScaling (aiQuaterniont<TReal>& rotation,\n    aiVector3t<TReal>& position) const\n{\n    const aiMatrix4x4t<TReal>& _this = *this;\n\n    // extract translation\n    position.x = _this[0][3];\n    position.y = _this[1][3];\n    position.z = _this[2][3];\n\n    // extract rotation\n    rotation = aiQuaterniont<TReal>((aiMatrix3x3t<TReal>)_this);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb)\n{\n    return FromEulerAnglesXYZ(blubb.x,blubb.y,blubb.z);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(TReal x, TReal y, TReal z)\n{\n    aiMatrix4x4t<TReal>& _this = *this;\n\n    TReal cx = std::cos(x);\n    TReal sx = std::sin(x);\n    TReal cy = std::cos(y);\n    TReal sy = std::sin(y);\n    TReal cz = std::cos(z);\n    TReal sz = std::sin(z);\n\n    // mz*my*mx\n    _this.a1 = cz * cy;\n    _this.a2 = cz * sy * sx - sz * cx;\n    _this.a3 = sz * sx + cz * sy * cx;\n\n    _this.b1 = sz * cy;\n    _this.b2 = cz * cx + sz * sy * sx;\n    _this.b3 = sz * sy * cx - cz * sx;\n\n    _this.c1 = -sy;\n    _this.c2 = cy * sx;\n    _this.c3 = cy * cx;\n\n    return *this;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiMatrix4x4t<TReal>::IsIdentity() const\n{\n    // Use a small epsilon to solve floating-point inaccuracies\n    const static TReal epsilon = 10e-3f;\n\n    return (a2 <= epsilon && a2 >= -epsilon &&\n            a3 <= epsilon && a3 >= -epsilon &&\n            a4 <= epsilon && a4 >= -epsilon &&\n            b1 <= epsilon && b1 >= -epsilon &&\n            b3 <= epsilon && b3 >= -epsilon &&\n            b4 <= epsilon && b4 >= -epsilon &&\n            c1 <= epsilon && c1 >= -epsilon &&\n            c2 <= epsilon && c2 >= -epsilon &&\n            c4 <= epsilon && c4 >= -epsilon &&\n            d1 <= epsilon && d1 >= -epsilon &&\n            d2 <= epsilon && d2 >= -epsilon &&\n            d3 <= epsilon && d3 >= -epsilon &&\n            a1 <= 1.f+epsilon && a1 >= 1.f-epsilon &&\n            b2 <= 1.f+epsilon && b2 >= 1.f-epsilon &&\n            c3 <= 1.f+epsilon && c3 >= 1.f-epsilon &&\n            d4 <= 1.f+epsilon && d4 >= 1.f-epsilon);\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationX(TReal a, aiMatrix4x4t<TReal>& out)\n{\n    /*\n         |  1  0       0       0 |\n     M = |  0  cos(A) -sin(A)  0 |\n         |  0  sin(A)  cos(A)  0 |\n         |  0  0       0       1 |  */\n    out = aiMatrix4x4t<TReal>();\n    out.b2 = out.c3 = std::cos(a);\n    out.b3 = -(out.c2 = std::sin(a));\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationY(TReal a, aiMatrix4x4t<TReal>& out)\n{\n    /*\n         |  cos(A)  0   sin(A)  0 |\n     M = |  0       1   0       0 |\n         | -sin(A)  0   cos(A)  0 |\n         |  0       0   0       1 |\n        */\n    out = aiMatrix4x4t<TReal>();\n    out.a1 = out.c3 = std::cos(a);\n    out.c1 = -(out.a3 = std::sin(a));\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationZ(TReal a, aiMatrix4x4t<TReal>& out)\n{\n    /*\n         |  cos(A)  -sin(A)   0   0 |\n     M = |  sin(A)   cos(A)   0   0 |\n         |  0        0        1   0 |\n         |  0        0        0   1 |   */\n    out = aiMatrix4x4t<TReal>();\n    out.a1 = out.b2 = std::cos(a);\n    out.a2 = -(out.b1 = std::sin(a));\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\n// Returns a rotation matrix for a rotation around an arbitrary axis.\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix4x4t<TReal>& out)\n{\n  TReal c = std::cos( a), s = std::sin( a), t = 1 - c;\n  TReal x = axis.x, y = axis.y, z = axis.z;\n\n  // Many thanks to MathWorld and Wikipedia\n  out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;\n  out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;\n  out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;\n  out.a4 = out.b4 = out.c4 = static_cast<TReal>(0.0);\n  out.d1 = out.d2 = out.d3 = static_cast<TReal>(0.0);\n  out.d4 = static_cast<TReal>(1.0);\n\n  return out;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Translation( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)\n{\n    out = aiMatrix4x4t<TReal>();\n    out.a4 = v.x;\n    out.b4 = v.y;\n    out.c4 = v.z;\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)\n{\n    out = aiMatrix4x4t<TReal>();\n    out.a1 = v.x;\n    out.b2 = v.y;\n    out.c3 = v.z;\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\n/** A function for creating a rotation matrix that rotates a vector called\n * \"from\" into another vector called \"to\".\n * Input : from[3], to[3] which both must be *normalized* non-zero vectors\n * Output: mtx[3][3] -- a 3x3 matrix in colum-major form\n * Authors: Tomas Möller, John Hughes\n *          \"Efficiently Building a Matrix to Rotate One Vector to Another\"\n *          Journal of Graphics Tools, 4(4):1-4, 1999\n */\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,\n    const aiVector3t<TReal>& to, aiMatrix4x4t<TReal>& mtx)\n{\n    aiMatrix3x3t<TReal> m3;\n    aiMatrix3x3t<TReal>::FromToMatrix(from,to,m3);\n    mtx = aiMatrix4x4t<TReal>(m3);\n    return mtx;\n}\n\n#endif // __cplusplus\n#endif // AI_MATRIX4X4_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/matrix4x4.inl b/include/assimp/matrix4x4.inl
--- a/include/assimp/matrix4x4.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/matrix4x4.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -60,12 +60,11 @@
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
 aiMatrix4x4t<TReal>::aiMatrix4x4t() AI_NO_EXCEPT :
-    a1(1.0f), a2(), a3(), a4(),
-    b1(), b2(1.0f), b3(), b4(),
-    c1(), c2(), c3(1.0f), c4(),
-    d1(), d2(), d3(), d4(1.0f)
-{
-
+        a1(1.0f), a2(), a3(), a4(),
+        b1(), b2(1.0f), b3(), b4(),
+        c1(), c2(), c3(1.0f), c4(),
+        d1(), d2(), d3(), d4(1.0f) {
+    // empty
 }
 
 // ----------------------------------------------------------------------------------------
@@ -74,19 +73,17 @@
               TReal _b1, TReal _b2, TReal _b3, TReal _b4,
               TReal _c1, TReal _c2, TReal _c3, TReal _c4,
               TReal _d1, TReal _d2, TReal _d3, TReal _d4) :
-    a1(_a1), a2(_a2), a3(_a3), a4(_a4),
-    b1(_b1), b2(_b2), b3(_b3), b4(_b4),
-    c1(_c1), c2(_c2), c3(_c3), c4(_c4),
-    d1(_d1), d2(_d2), d3(_d3), d4(_d4)
-{
-
+        a1(_a1), a2(_a2), a3(_a3), a4(_a4),
+        b1(_b1), b2(_b2), b3(_b3), b4(_b4),
+        c1(_c1), c2(_c2), c3(_c3), c4(_c4),
+        d1(_d1), d2(_d2), d3(_d3), d4(_d4) {
+    // empty
 }
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
 template <typename TOther>
-aiMatrix4x4t<TReal>::operator aiMatrix4x4t<TOther> () const
-{
+aiMatrix4x4t<TReal>::operator aiMatrix4x4t<TOther> () const {
     return aiMatrix4x4t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),static_cast<TOther>(a4),
         static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),static_cast<TOther>(b4),
         static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3),static_cast<TOther>(c4),
@@ -96,8 +93,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiMatrix3x3t<TReal>& m)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiMatrix3x3t<TReal>& m) {
     a1 = m.a1; a2 = m.a2; a3 = m.a3; a4 = static_cast<TReal>(0.0);
     b1 = m.b1; b2 = m.b2; b3 = m.b3; b4 = static_cast<TReal>(0.0);
     c1 = m.c1; c2 = m.c2; c3 = m.c3; c4 = static_cast<TReal>(0.0);
@@ -106,8 +103,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation, const aiVector3t<TReal>& position)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation, const aiVector3t<TReal>& position) {
     // build a 3x3 rotation matrix
     aiMatrix3x3t<TReal> m = rotation.GetMatrix();
 
@@ -134,8 +131,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::operator *= (const aiMatrix4x4t<TReal>& m)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::operator *= (const aiMatrix4x4t<TReal>& m) {
     *this = aiMatrix4x4t<TReal>(
         m.a1 * a1 + m.b1 * a2 + m.c1 * a3 + m.d1 * a4,
         m.a2 * a1 + m.b2 * a2 + m.c2 * a3 + m.d2 * a4,
@@ -158,8 +155,7 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const TReal& aFloat) const
-{
+AI_FORCE_INLINE aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const TReal& aFloat) const {
     aiMatrix4x4t<TReal> temp(
         a1 * aFloat,
         a2 * aFloat,
@@ -182,8 +178,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator+ (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator+ (const aiMatrix4x4t<TReal>& m) const {
     aiMatrix4x4t<TReal> temp(
         m.a1 + a1,
         m.a2 + a2,
@@ -206,18 +202,16 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const aiMatrix4x4t<TReal>& m) const {
     aiMatrix4x4t<TReal> temp( *this);
     temp *= m;
     return temp;
 }
 
-
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Transpose()
-{
+AI_FORCE_INLINE aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Transpose() {
     // (TReal&) don't remove, GCC complains cause of packed fields
     std::swap( (TReal&)b1, (TReal&)a2);
     std::swap( (TReal&)c1, (TReal&)a3);
@@ -228,11 +222,10 @@
     return *this;
 }
 
-
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline TReal aiMatrix4x4t<TReal>::Determinant() const
-{
+AI_FORCE_INLINE
+TReal aiMatrix4x4t<TReal>::Determinant() const {
     return a1*b2*c3*d4 - a1*b2*c4*d3 + a1*b3*c4*d2 - a1*b3*c2*d4
         + a1*b4*c2*d3 - a1*b4*c3*d2 - a2*b3*c4*d1 + a2*b3*c1*d4
         - a2*b4*c1*d3 + a2*b4*c3*d1 - a2*b1*c3*d4 + a2*b1*c4*d3
@@ -243,8 +236,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Inverse()
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Inverse() {
     // Compute the reciprocal determinant
     const TReal det = Determinant();
     if(det == static_cast<TReal>(0.0))
@@ -288,9 +281,10 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) {
+AI_FORCE_INLINE
+TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) {
     if (p_iIndex > 3) {
-        return NULL;
+        return nullptr;
     }
     switch ( p_iIndex ) {
         case 0:
@@ -309,9 +303,10 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline const TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) const {
+AI_FORCE_INLINE
+const TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) const {
     if (p_iIndex > 3) {
-        return NULL;
+        return nullptr;
     }
 
     switch ( p_iIndex ) {
@@ -331,8 +326,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiMatrix4x4t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+bool aiMatrix4x4t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const {
     return (a1 == m.a1 && a2 == m.a2 && a3 == m.a3 && a4 == m.a4 &&
             b1 == m.b1 && b2 == m.b2 && b3 == m.b3 && b4 == m.b4 &&
             c1 == m.c1 && c2 == m.c2 && c3 == m.c3 && c4 == m.c4 &&
@@ -341,14 +336,15 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiMatrix4x4t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+bool aiMatrix4x4t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const {
     return !(*this == m);
 }
 
 // ---------------------------------------------------------------------------
 template<typename TReal>
-inline bool aiMatrix4x4t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {
+AI_FORCE_INLINE
+bool aiMatrix4x4t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {
     return
         std::abs(a1 - m.a1) <= epsilon &&
         std::abs(a2 - m.a2) <= epsilon &&
@@ -400,13 +396,10 @@
 	\
 	do {} while(false)
 
-
-
-
 template <typename TReal>
-inline void aiMatrix4x4t<TReal>::Decompose (aiVector3t<TReal>& pScaling, aiQuaterniont<TReal>& pRotation,
-    aiVector3t<TReal>& pPosition) const
-{
+AI_FORCE_INLINE
+void aiMatrix4x4t<TReal>::Decompose (aiVector3t<TReal>& pScaling, aiQuaterniont<TReal>& pRotation,
+        aiVector3t<TReal>& pPosition) const {
 	ASSIMP_MATRIX4_4_DECOMPOSE_PART;
 
     // build a 3x3 rotation matrix
@@ -419,7 +412,7 @@
 }
 
 template <typename TReal>
-inline
+AI_FORCE_INLINE
 void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const {
 	ASSIMP_MATRIX4_4_DECOMPOSE_PART;
 
@@ -474,10 +467,10 @@
 #undef ASSIMP_MATRIX4_4_DECOMPOSE_PART
 
 template <typename TReal>
-inline void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle,
-											aiVector3t<TReal>& pPosition) const
-{
-aiQuaterniont<TReal> pRotation;
+AI_FORCE_INLINE
+void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle,
+											aiVector3t<TReal>& pPosition) const {
+    aiQuaterniont<TReal> pRotation;
 
 	Decompose(pScaling, pRotation, pPosition);
 	pRotation.Normalize();
@@ -499,9 +492,9 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline void aiMatrix4x4t<TReal>::DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
-    aiVector3t<TReal>& position) const
-{
+AI_FORCE_INLINE
+void aiMatrix4x4t<TReal>::DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
+        aiVector3t<TReal>& position) const {
     const aiMatrix4x4t<TReal>& _this = *this;
 
     // extract translation
@@ -515,15 +508,15 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb) {
     return FromEulerAnglesXYZ(blubb.x,blubb.y,blubb.z);
 }
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(TReal x, TReal y, TReal z)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(TReal x, TReal y, TReal z) {
     aiMatrix4x4t<TReal>& _this = *this;
 
     TReal cx = std::cos(x);
@@ -551,8 +544,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiMatrix4x4t<TReal>::IsIdentity() const
-{
+AI_FORCE_INLINE
+bool aiMatrix4x4t<TReal>::IsIdentity() const {
     // Use a small epsilon to solve floating-point inaccuracies
     const static TReal epsilon = 10e-3f;
 
@@ -576,8 +569,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationX(TReal a, aiMatrix4x4t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationX(TReal a, aiMatrix4x4t<TReal>& out) {
     /*
          |  1  0       0       0 |
      M = |  0  cos(A) -sin(A)  0 |
@@ -591,8 +584,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationY(TReal a, aiMatrix4x4t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationY(TReal a, aiMatrix4x4t<TReal>& out) {
     /*
          |  cos(A)  0   sin(A)  0 |
      M = |  0       1   0       0 |
@@ -607,8 +600,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationZ(TReal a, aiMatrix4x4t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationZ(TReal a, aiMatrix4x4t<TReal>& out) {
     /*
          |  cos(A)  -sin(A)   0   0 |
      M = |  sin(A)   cos(A)   0   0 |
@@ -623,26 +616,25 @@
 // ----------------------------------------------------------------------------------------
 // Returns a rotation matrix for a rotation around an arbitrary axis.
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix4x4t<TReal>& out)
-{
-  TReal c = std::cos( a), s = std::sin( a), t = 1 - c;
-  TReal x = axis.x, y = axis.y, z = axis.z;
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix4x4t<TReal>& out) {
+    TReal c = std::cos( a), s = std::sin( a), t = 1 - c;
+    TReal x = axis.x, y = axis.y, z = axis.z;
 
-  // Many thanks to MathWorld and Wikipedia
-  out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;
-  out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;
-  out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;
-  out.a4 = out.b4 = out.c4 = static_cast<TReal>(0.0);
-  out.d1 = out.d2 = out.d3 = static_cast<TReal>(0.0);
-  out.d4 = static_cast<TReal>(1.0);
+    // Many thanks to MathWorld and Wikipedia
+    out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;
+    out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;
+    out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;
+    out.a4 = out.b4 = out.c4 = static_cast<TReal>(0.0);
+    out.d1 = out.d2 = out.d3 = static_cast<TReal>(0.0);
+    out.d4 = static_cast<TReal>(1.0);
 
-  return out;
+    return out;
 }
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Translation( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)
-{
+AI_FORCE_INLINE aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Translation( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out) {
     out = aiMatrix4x4t<TReal>();
     out.a4 = v.x;
     out.b4 = v.y;
@@ -652,8 +644,8 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out) {
     out = aiMatrix4x4t<TReal>();
     out.a1 = v.x;
     out.b2 = v.y;
@@ -672,9 +664,9 @@
  */
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,
-    const aiVector3t<TReal>& to, aiMatrix4x4t<TReal>& mtx)
-{
+AI_FORCE_INLINE
+aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,
+        const aiVector3t<TReal>& to, aiMatrix4x4t<TReal>& mtx) {
     aiMatrix3x3t<TReal> m3;
     aiMatrix3x3t<TReal>::FromToMatrix(from,to,m3);
     mtx = aiMatrix4x4t<TReal>(m3);
Index: include/assimp/Exceptional.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2008, assimp team\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#ifndef INCLUDED_EXCEPTIONAL_H\n#define INCLUDED_EXCEPTIONAL_H\n\n#include <stdexcept>\n#include <assimp/DefaultIOStream.h>\nusing std::runtime_error;\n\n#ifdef _MSC_VER\n#   pragma warning(disable : 4275)\n#endif\n\n// ---------------------------------------------------------------------------\n/** FOR IMPORTER PLUGINS ONLY: Simple exception class to be thrown if an\n *  unrecoverable error occurs while importing. Loading APIs return\n *  NULL instead of a valid aiScene then.  */\nclass DeadlyImportError\n    : public runtime_error\n{\npublic:\n    /** Constructor with arguments */\n    explicit DeadlyImportError( const std::string& errorText)\n        : runtime_error(errorText)\n    {\n    }\n\nprivate:\n};\n\ntypedef DeadlyImportError DeadlyExportError;\n\n#ifdef _MSC_VER\n#   pragma warning(default : 4275)\n#endif\n\n// ---------------------------------------------------------------------------\ntemplate <typename T>\nstruct ExceptionSwallower   {\n    T operator ()() const {\n        return T();\n    }\n};\n\n// ---------------------------------------------------------------------------\ntemplate <typename T>\nstruct ExceptionSwallower<T*>   {\n    T* operator ()() const {\n        return NULL;\n    }\n};\n\n// ---------------------------------------------------------------------------\ntemplate <>\nstruct ExceptionSwallower<aiReturn> {\n    aiReturn operator ()() const {\n        try {\n            throw;\n        }\n        catch (std::bad_alloc&) {\n            return aiReturn_OUTOFMEMORY;\n        }\n        catch (...) {\n            return aiReturn_FAILURE;\n        }\n    }\n};\n\n// ---------------------------------------------------------------------------\ntemplate <>\nstruct ExceptionSwallower<void> {\n    void operator ()() const {\n        return;\n    }\n};\n\n#define ASSIMP_BEGIN_EXCEPTION_REGION()\\\n{\\\n    try {\n\n#define ASSIMP_END_EXCEPTION_REGION(type)\\\n    } catch(...) {\\\n        return ExceptionSwallower<type>()();\\\n    }\\\n}\n\n#endif // INCLUDED_EXCEPTIONAL_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Exceptional.h b/include/assimp/Exceptional.h
--- a/include/assimp/Exceptional.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Exceptional.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2008, assimp team
+Copyright (c) 2006-2020, assimp team
 All rights reserved.
 
 Redistribution and use of this software in source and binary forms,
@@ -38,11 +38,17 @@
 ----------------------------------------------------------------------
 */
 
-#ifndef INCLUDED_EXCEPTIONAL_H
-#define INCLUDED_EXCEPTIONAL_H
+#pragma once
+#ifndef AI_INCLUDED_EXCEPTIONAL_H
+#define AI_INCLUDED_EXCEPTIONAL_H
+
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
 
 #include <stdexcept>
 #include <assimp/DefaultIOStream.h>
+
 using std::runtime_error;
 
 #ifdef _MSC_VER
@@ -53,17 +59,14 @@
 /** FOR IMPORTER PLUGINS ONLY: Simple exception class to be thrown if an
  *  unrecoverable error occurs while importing. Loading APIs return
  *  NULL instead of a valid aiScene then.  */
-class DeadlyImportError
-    : public runtime_error
-{
+class DeadlyImportError : public runtime_error {
 public:
     /** Constructor with arguments */
     explicit DeadlyImportError( const std::string& errorText)
-        : runtime_error(errorText)
-    {
+    : runtime_error(errorText) {
+        // empty
     }
 
-private:
 };
 
 typedef DeadlyImportError DeadlyExportError;
@@ -84,7 +87,7 @@
 template <typename T>
 struct ExceptionSwallower<T*>   {
     T* operator ()() const {
-        return NULL;
+        return nullptr;
     }
 };
 
@@ -116,10 +119,20 @@
 {\
     try {
 
+#define ASSIMP_END_EXCEPTION_REGION_WITH_ERROR_STRING(type, ASSIMP_END_EXCEPTION_REGION_errorString)\
+    } catch(const DeadlyImportError& e) {\
+        ASSIMP_END_EXCEPTION_REGION_errorString = e.what();\
+        return ExceptionSwallower<type>()();\
+    } catch(...) {\
+        ASSIMP_END_EXCEPTION_REGION_errorString = "Unknown exception";\
+        return ExceptionSwallower<type>()();\
+    }\
+}
+
 #define ASSIMP_END_EXCEPTION_REGION(type)\
     } catch(...) {\
         return ExceptionSwallower<type>()();\
     }\
 }
 
-#endif // INCLUDED_EXCEPTIONAL_H
+#endif // AI_INCLUDED_EXCEPTIONAL_H
Index: include/assimp/NullLogger.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file  NullLogger.hpp\n *  @brief Dummy logger\n*/\n\n#ifndef INCLUDED_AI_NULLLOGGER_H\n#define INCLUDED_AI_NULLLOGGER_H\n\n#include \"Logger.hpp\"\n\nnamespace Assimp {\n\n// ---------------------------------------------------------------------------\n/** @brief CPP-API: Empty logging implementation.\n *\n * Does nothing! Used by default if the application hasn't requested a\n * custom logger via #DefaultLogger::set() or #DefaultLogger::create(); */\nclass ASSIMP_API NullLogger\n    : public Logger {\n\npublic:\n\n    /** @brief  Logs a debug message */\n    void OnDebug(const char* message) {\n        (void)message; //this avoids compiler warnings\n    }\n\n    /** @brief  Logs an info message */\n    void OnInfo(const char* message) {\n        (void)message; //this avoids compiler warnings\n    }\n\n    /** @brief  Logs a warning message */\n    void OnWarn(const char* message) {\n        (void)message; //this avoids compiler warnings\n    }\n\n    /** @brief  Logs an error message */\n    void OnError(const char* message) {\n        (void)message; //this avoids compiler warnings\n    }\n\n    /** @brief  Detach a still attached stream from logger */\n    bool attachStream(LogStream *pStream, unsigned int severity) {\n        (void)pStream; (void)severity; //this avoids compiler warnings\n        return false;\n    }\n\n    /** @brief  Detach a still attached stream from logger */\n    bool detatchStream(LogStream *pStream, unsigned int severity) {\n        (void)pStream; (void)severity; //this avoids compiler warnings\n        return false;\n    }\n\nprivate:\n};\n}\n#endif // !! AI_NULLLOGGER_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/NullLogger.hpp b/include/assimp/NullLogger.hpp
--- a/include/assimp/NullLogger.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/NullLogger.hpp	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
Index: include/assimp/StandardShapes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Declares a helper class, \"StandardShapes\" which generates\n *  vertices for standard shapes, such as cylnders, cones, spheres ..\n */\n#ifndef AI_STANDARD_SHAPES_H_INC\n#define AI_STANDARD_SHAPES_H_INC\n\n#include <assimp/vector3.h>\n#include <vector>\n\nstruct aiMesh;\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------\n/** \\brief Helper class to generate vertex buffers for standard geometric\n *  shapes, such as cylinders, cones, boxes, spheres, elipsoids ... .\n */\nclass ASSIMP_API StandardShapes\n{\n    // class cannot be instanced\n    StandardShapes() {}\n\npublic:\n\n\n    // ----------------------------------------------------------------\n    /** Generates a mesh from an array of vertex positions.\n     *\n     *  @param positions List of vertex positions\n     *  @param numIndices Number of indices per primitive\n     *  @return Output mesh\n     */\n    static aiMesh* MakeMesh(const std::vector<aiVector3D>& positions,\n        unsigned int numIndices);\n\n\n    static aiMesh* MakeMesh ( unsigned int (*GenerateFunc)\n        (std::vector<aiVector3D>&));\n\n    static aiMesh* MakeMesh ( unsigned int (*GenerateFunc)\n        (std::vector<aiVector3D>&, bool));\n\n    static aiMesh* MakeMesh ( unsigned int n,  void (*GenerateFunc)\n        (unsigned int,std::vector<aiVector3D>&));\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a hexahedron (cube)\n     *\n     *  Hexahedrons can be scaled on all axes.\n     *  @param positions Receives output triangles.\n     *  @param polygons If you pass true here quads will be returned\n     *  @return Number of vertices per face\n     */\n    static unsigned int MakeHexahedron(\n        std::vector<aiVector3D>& positions,\n        bool polygons = false);\n\n    // ----------------------------------------------------------------\n    /** @brief Generates an icosahedron\n     *\n     *  @param positions Receives output triangles.\n     *  @return Number of vertices per face\n     */\n    static unsigned int MakeIcosahedron(\n        std::vector<aiVector3D>& positions);\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a dodecahedron\n     *\n     *  @param positions Receives output triangles\n     *  @param polygons If you pass true here pentagons will be returned\n     *  @return Number of vertices per face\n     */\n    static unsigned int MakeDodecahedron(\n        std::vector<aiVector3D>& positions,\n        bool polygons = false);\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates an octahedron\n     *\n     *  @param positions Receives output triangles.\n     *  @return Number of vertices per face\n     */\n    static unsigned int MakeOctahedron(\n        std::vector<aiVector3D>& positions);\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a tetrahedron\n     *\n     *  @param positions Receives output triangles.\n     *  @return Number of vertices per face\n     */\n    static unsigned int MakeTetrahedron(\n        std::vector<aiVector3D>& positions);\n\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a sphere\n     *\n     *  @param tess Number of subdivions - 0 generates a octahedron\n     *  @param positions Receives output triangles.\n     */\n    static void MakeSphere(unsigned int tess,\n        std::vector<aiVector3D>& positions);\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a cone or a cylinder, either open or closed.\n     *\n     *  @code\n     *\n     *       |-----|       <- radius 1\n     *\n     *        __x__        <- ]               ^\n     *       /     \\          | height        |\n     *      /       \\         |               Y\n     *     /         \\        |\n     *    /           \\       |\n     *   /______x______\\   <- ] <- end cap\n     *\n     *   |-------------|   <- radius 2\n     *\n     *  @endcode\n     *\n     *  @param height Height of the cone\n     *  @param radius1 First radius\n     *  @param radius2 Second radius\n     *  @param tess Number of triangles.\n     *  @param bOpened true for an open cone/cylinder. An open shape has\n     *    no 'end caps'\n     *  @param positions Receives output triangles\n     */\n    static void MakeCone(ai_real height,ai_real radius1,\n        ai_real radius2,unsigned int tess,\n        std::vector<aiVector3D>& positions,bool bOpen= false);\n\n\n    // ----------------------------------------------------------------\n    /** @brief Generates a flat circle\n     *\n     *  The circle is constructed in the planned formed by the x,z\n     *  axes of the cartesian coordinate system.\n     *\n     *  @param radius Radius of the circle\n     *  @param tess Number of segments.\n     *  @param positions Receives output triangles.\n     */\n    static void MakeCircle(ai_real radius, unsigned int tess,\n        std::vector<aiVector3D>& positions);\n\n};\n} // ! Assimp\n\n#endif // !! AI_STANDARD_SHAPES_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/StandardShapes.h b/include/assimp/StandardShapes.h
--- a/include/assimp/StandardShapes.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/StandardShapes.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -41,11 +41,16 @@
 */
 
 /** @file Declares a helper class, "StandardShapes" which generates
- *  vertices for standard shapes, such as cylnders, cones, spheres ..
+ *  vertices for standard shapes, such as cylinders, cones, spheres ..
  */
+#pragma once
 #ifndef AI_STANDARD_SHAPES_H_INC
 #define AI_STANDARD_SHAPES_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/vector3.h>
 #include <vector>
 
Index: include/assimp/BaseImporter.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Definition of the base class for all importer worker classes. */\n#ifndef INCLUDED_AI_BASEIMPORTER_H\n#define INCLUDED_AI_BASEIMPORTER_H\n\n#include \"Exceptional.h\"\n\n#include <vector>\n#include <set>\n#include <map>\n#include <assimp/types.h>\n#include <assimp/ProgressHandler.hpp>\n#include <assimp/ai_assert.h>\n\nstruct aiScene;\nstruct aiImporterDesc;\n\nnamespace Assimp    {\n\nclass Importer;\nclass IOSystem;\nclass BaseProcess;\nclass SharedPostProcessInfo;\nclass IOStream;\n\n// utility to do char4 to uint32 in a portable manner\n#define AI_MAKE_MAGIC(string) ((uint32_t)((string[0] << 24) + \\\n    (string[1] << 16) + (string[2] << 8) + string[3]))\n\n\n// ---------------------------------------------------------------------------\n/** FOR IMPORTER PLUGINS ONLY: The BaseImporter defines a common interface\n *  for all importer worker classes.\n *\n * The interface defines two functions: CanRead() is used to check if the\n * importer can handle the format of the given file. If an implementation of\n * this function returns true, the importer then calls ReadFile() which\n * imports the given file. ReadFile is not overridable, it just calls\n * InternReadFile() and catches any ImportErrorException that might occur.\n */\nclass ASSIMP_API BaseImporter {\n    friend class Importer;\n\nprivate:\n    /* Pushes state into importer for the importer scale */\n    virtual void UpdateImporterScale( Importer* pImp );\n\npublic:\n\n    /** Constructor to be privately used by #Importer */\n    BaseImporter() AI_NO_EXCEPT;\n\n    /** Destructor, private as well */\n    virtual ~BaseImporter();\n\n    // -------------------------------------------------------------------\n    /** Returns whether the class can handle the format of the given file.\n     *\n     * The implementation should be as quick as possible. A check for\n     * the file extension is enough. If no suitable loader is found with\n     * this strategy, CanRead() is called again, the 'checkSig' parameter\n     * set to true this time. Now the implementation is expected to\n     * perform a full check of the file structure, possibly searching the\n     * first bytes of the file for magic identifiers or keywords.\n     *\n     * @param pFile Path and file name of the file to be examined.\n     * @param pIOHandler The IO handler to use for accessing any file.\n     * @param checkSig Set to true if this method is called a second time.\n     *   This time, the implementation may take more time to examine the\n     *   contents of the file to be loaded for magic bytes, keywords, etc\n     *   to be able to load files with unknown/not existent file extensions.\n     * @return true if the class can read this file, false if not.\n     */\n    virtual bool CanRead(\n        const std::string& pFile,\n        IOSystem* pIOHandler,\n        bool checkSig\n        ) const = 0;\n\n    // -------------------------------------------------------------------\n    /** Imports the given file and returns the imported data.\n     * If the import succeeds, ownership of the data is transferred to\n     * the caller. If the import fails, NULL is returned. The function\n     * takes care that any partially constructed data is destroyed\n     * beforehand.\n     *\n     * @param pImp #Importer object hosting this loader.\n     * @param pFile Path of the file to be imported.\n     * @param pIOHandler IO-Handler used to open this and possible other files.\n     * @return The imported data or NULL if failed. If it failed a\n     * human-readable error description can be retrieved by calling\n     * GetErrorText()\n     *\n     * @note This function is not intended to be overridden. Implement\n     * InternReadFile() to do the import. If an exception is thrown somewhere\n     * in InternReadFile(), this function will catch it and transform it into\n     *  a suitable response to the caller.\n     */\n    aiScene* ReadFile(\n        Importer* pImp,\n        const std::string& pFile,\n        IOSystem* pIOHandler\n        );\n\n    // -------------------------------------------------------------------\n    /** Returns the error description of the last error that occurred.\n     * @return A description of the last error that occurred. An empty\n     * string if there was no error.\n     */\n    const std::string& GetErrorText() const {\n        return m_ErrorText;\n    }\n\n    // -------------------------------------------------------------------\n    /** Called prior to ReadFile().\n     * The function is a request to the importer to update its configuration\n     * basing on the Importer's configuration property list.\n     * @param pImp Importer instance\n     */\n    virtual void SetupProperties(\n        const Importer* pImp\n        );\n\n    // -------------------------------------------------------------------\n    /** Called by #Importer::GetImporterInfo to get a description of\n     *  some loader features. Importers must provide this information. */\n    virtual const aiImporterDesc* GetInfo() const = 0;\n\n    /**\n     * Will be called only by scale process when scaling is requested.\n     */\n    virtual void SetFileScale(double scale)\n    {\n        fileScale = scale;\n    }\n\n    virtual double GetFileScale() const\n    {\n        return fileScale;\n    }\n\n    enum ImporterUnits {\n        M,\n        MM,\n        CM,\n        INCHES,\n        FEET\n    };\n\n    /**\n     * Assimp Importer\n     * unit conversions available \n     * if you need another measurment unit add it below.\n     * it's currently defined in assimp that we prefer meters.\n     * */\n    std::map<ImporterUnits, double> importerUnits = {\n        {ImporterUnits::M, 1},\n        {ImporterUnits::CM, 0.01},\n        {ImporterUnits::MM, 0.001},\n        {ImporterUnits::INCHES, 0.0254},\n        {ImporterUnits::FEET, 0.3048}\n    };\n\n    virtual void SetApplicationUnits( const ImporterUnits& unit )\n    {\n        importerScale = importerUnits[unit];\n        applicationUnits = unit;\n    }\n\n    virtual const ImporterUnits& GetApplicationUnits()\n    {\n        return applicationUnits;\n    }\n\n    // -------------------------------------------------------------------\n    /** Called by #Importer::GetExtensionList for each loaded importer.\n     *  Take the extension list contained in the structure returned by\n     *  #GetInfo and insert all file extensions into the given set.\n     *  @param extension set to collect file extensions in*/\n    void GetExtensionList(std::set<std::string>& extensions);\n    \nprotected:    \n    ImporterUnits applicationUnits = ImporterUnits::M;\n    double importerScale = 1.0;\n    double fileScale = 1.0;\n\n\n\n    // -------------------------------------------------------------------\n    /** Imports the given file into the given scene structure. The\n     * function is expected to throw an ImportErrorException if there is\n     * an error. If it terminates normally, the data in aiScene is\n     * expected to be correct. Override this function to implement the\n     * actual importing.\n     * <br>\n     *  The output scene must meet the following requirements:<br>\n     * <ul>\n     * <li>At least a root node must be there, even if its only purpose\n     *     is to reference one mesh.</li>\n     * <li>aiMesh::mPrimitiveTypes may be 0. The types of primitives\n     *   in the mesh are determined automatically in this case.</li>\n     * <li>the vertex data is stored in a pseudo-indexed \"verbose\" format.\n     *   In fact this means that every vertex that is referenced by\n     *   a face is unique. Or the other way round: a vertex index may\n     *   not occur twice in a single aiMesh.</li>\n     * <li>aiAnimation::mDuration may be -1. Assimp determines the length\n     *   of the animation automatically in this case as the length of\n     *   the longest animation channel.</li>\n     * <li>aiMesh::mBitangents may be NULL if tangents and normals are\n     *   given. In this case bitangents are computed as the cross product\n     *   between normal and tangent.</li>\n     * <li>There needn't be a material. If none is there a default material\n     *   is generated. However, it is recommended practice for loaders\n     *   to generate a default material for yourself that matches the\n     *   default material setting for the file format better than Assimp's\n     *   generic default material. Note that default materials *should*\n     *   be named AI_DEFAULT_MATERIAL_NAME if they're just color-shaded\n     *   or AI_DEFAULT_TEXTURED_MATERIAL_NAME if they define a (dummy)\n     *   texture. </li>\n     * </ul>\n     * If the AI_SCENE_FLAGS_INCOMPLETE-Flag is <b>not</b> set:<ul>\n     * <li> at least one mesh must be there</li>\n     * <li> there may be no meshes with 0 vertices or faces</li>\n     * </ul>\n     * This won't be checked (except by the validation step): Assimp will\n     * crash if one of the conditions is not met!\n     *\n     * @param pFile Path of the file to be imported.\n     * @param pScene The scene object to hold the imported data.\n     * NULL is not a valid parameter.\n     * @param pIOHandler The IO handler to use for any file access.\n     * NULL is not a valid parameter. */\n    virtual void InternReadFile(\n        const std::string& pFile,\n        aiScene* pScene,\n        IOSystem* pIOHandler\n        ) = 0;\n\npublic: // static utilities\n\n    // -------------------------------------------------------------------\n    /** A utility for CanRead().\n     *\n     *  The function searches the header of a file for a specific token\n     *  and returns true if this token is found. This works for text\n     *  files only. There is a rudimentary handling of UNICODE files.\n     *  The comparison is case independent.\n     *\n     *  @param pIOSystem IO System to work with\n     *  @param file File name of the file\n     *  @param tokens List of tokens to search for\n     *  @param numTokens Size of the token array\n     *  @param searchBytes Number of bytes to be searched for the tokens.\n     */\n    static bool SearchFileHeaderForToken(\n        IOSystem* pIOSystem,\n        const std::string&  file,\n        const char** tokens,\n        unsigned int numTokens,\n        unsigned int searchBytes = 200,\n        bool tokensSol = false,\n        bool noAlphaBeforeTokens = false);\n\n    // -------------------------------------------------------------------\n    /** @brief Check whether a file has a specific file extension\n     *  @param pFile Input file\n     *  @param ext0 Extension to check for. Lowercase characters only, no dot!\n     *  @param ext1 Optional second extension\n     *  @param ext2 Optional third extension\n     *  @note Case-insensitive\n     */\n    static bool SimpleExtensionCheck (\n        const std::string& pFile,\n        const char* ext0,\n        const char* ext1 = NULL,\n        const char* ext2 = NULL);\n\n    // -------------------------------------------------------------------\n    /** @brief Extract file extension from a string\n     *  @param pFile Input file\n     *  @return Extension without trailing dot, all lowercase\n     */\n    static std::string GetExtension (\n        const std::string& pFile);\n\n    // -------------------------------------------------------------------\n    /** @brief Check whether a file starts with one or more magic tokens\n     *  @param pFile Input file\n     *  @param pIOHandler IO system to be used\n     *  @param magic n magic tokens\n     *  @params num Size of magic\n     *  @param offset Offset from file start where tokens are located\n     *  @param Size of one token, in bytes. Maximally 16 bytes.\n     *  @return true if one of the given tokens was found\n     *\n     *  @note For convenience, the check is also performed for the\n     *  byte-swapped variant of all tokens (big endian). Only for\n     *  tokens of size 2,4.\n     */\n    static bool CheckMagicToken(\n        IOSystem* pIOHandler,\n        const std::string& pFile,\n        const void* magic,\n        unsigned int num,\n        unsigned int offset = 0,\n        unsigned int size   = 4);\n\n    // -------------------------------------------------------------------\n    /** An utility for all text file loaders. It converts a file to our\n     *   UTF8 character set. Errors are reported, but ignored.\n     *\n     *  @param data File buffer to be converted to UTF8 data. The buffer\n     *  is resized as appropriate. */\n    static void ConvertToUTF8(\n        std::vector<char>& data);\n\n    // -------------------------------------------------------------------\n    /** An utility for all text file loaders. It converts a file from our\n     *   UTF8 character set back to ISO-8859-1. Errors are reported, but ignored.\n     *\n     *  @param data File buffer to be converted from UTF8 to ISO-8859-1. The buffer\n     *  is resized as appropriate. */\n    static void ConvertUTF8toISO8859_1(\n        std::string& data);\n\n    // -------------------------------------------------------------------\n    /// @brief  Enum to define, if empty files are ok or not.\n    enum TextFileMode { \n        ALLOW_EMPTY,\n        FORBID_EMPTY \n    };\n\n    // -------------------------------------------------------------------\n    /** Utility for text file loaders which copies the contents of the\n     *  file into a memory buffer and converts it to our UTF8\n     *  representation.\n     *  @param stream Stream to read from.\n     *  @param data Output buffer to be resized and filled with the\n     *   converted text file data. The buffer is terminated with\n     *   a binary 0.\n     *  @param mode Whether it is OK to load empty text files. */\n    static void TextFileToBuffer(\n        IOStream* stream,\n        std::vector<char>& data,\n        TextFileMode mode = FORBID_EMPTY);\n\n    // -------------------------------------------------------------------\n    /** Utility function to move a std::vector into a aiScene array\n    *  @param vec The vector to be moved\n    *  @param out The output pointer to the allocated array.\n    *  @param numOut The output count of elements copied. */\n    template<typename T>\n    AI_FORCE_INLINE\n    static void CopyVector(\n        std::vector<T>& vec,\n        T*& out,\n        unsigned int& outLength)\n    {\n        outLength = unsigned(vec.size());\n        if (outLength) {\n            out = new T[outLength];\n            std::swap_ranges(vec.begin(), vec.end(), out);\n        }\n    }\n\nprotected:\n    /// Error description in case there was one.\n    std::string m_ErrorText;\n    /// Currently set progress handler.\n    ProgressHandler* m_progress;\n};\n\n\n\n} // end of namespace Assimp\n\n#endif // AI_BASEIMPORTER_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/BaseImporter.h b/include/assimp/BaseImporter.h
--- a/include/assimp/BaseImporter.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/BaseImporter.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -41,9 +41,14 @@
 */
 
 /** @file Definition of the base class for all importer worker classes. */
+#pragma once
 #ifndef INCLUDED_AI_BASEIMPORTER_H
 #define INCLUDED_AI_BASEIMPORTER_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include "Exceptional.h"
 
 #include <vector>
@@ -191,16 +196,13 @@
     /**
      * Assimp Importer
      * unit conversions available 
-     * if you need another measurment unit add it below.
-     * it's currently defined in assimp that we prefer meters.
+     * NOTE: Valid options are initialised in the
+     * constructor in the implementation file to
+     * work around a VS2013 compiler bug if support
+     * for that compiler is dropped in the future
+     * initialisation can be moved back here
      * */
-    std::map<ImporterUnits, double> importerUnits = {
-        {ImporterUnits::M, 1},
-        {ImporterUnits::CM, 0.01},
-        {ImporterUnits::MM, 0.001},
-        {ImporterUnits::INCHES, 0.0254},
-        {ImporterUnits::FEET, 0.3048}
-    };
+    std::map<ImporterUnits, double> importerUnits;
 
     virtual void SetApplicationUnits( const ImporterUnits& unit )
     {
Index: cmake-files/FindGLM.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-files/FindGLM.cmake b/cmake-files/FindGLM.cmake
new file mode 100644
--- /dev/null	(date 1617531326000)
+++ b/cmake-files/FindGLM.cmake	(date 1617531326000)
@@ -0,0 +1,53 @@
+#
+# Find GLM
+#
+# Try to find GLM : OpenGL Mathematics.
+# This module defines
+# - GLM_INCLUDE_DIRS
+# - GLM_FOUND
+#
+# The following variables can be set as arguments for the module.
+# - GLM_ROOT_DIR : Root library directory of GLM
+#
+# References:
+# - https://github.com/Groovounet/glm/blob/master/util/FindGLM.cmake
+# - https://bitbucket.org/alfonse/gltut/src/28636298c1c0/glm-0.9.0.7/FindGLM.cmake
+#
+
+# Additional modules
+include(FindPackageHandleStandardArgs)
+
+if (WIN32)
+	# Find include files
+	find_path(
+		GLM_INCLUDE_DIR
+		NAMES glm/glm.hpp
+		PATHS
+		$ENV{PROGRAMFILES}/include
+		${GLM_ROOT_DIR}/include
+		DOC "The directory where glm/glm.hpp resides")
+else()
+	# Find include files
+	find_path(
+		GLM_INCLUDE_DIR
+		NAMES glm/glm.hpp
+		PATHS
+		/usr/include
+		/usr/local/include
+		/sw/include
+		/opt/local/include
+		${GLM_ROOT_DIR}/include
+		/usr/local/Cellar/glm
+		DOC "The directory where glm/glm.hpp resides")
+endif()
+
+# Handle REQUIRD argument, define *_FOUND variable
+find_package_handle_standard_args(GLM DEFAULT_MSG GLM_INCLUDE_DIR)
+
+# Define GLM_INCLUDE_DIRS
+if (GLM_FOUND)
+	set(GLM_INCLUDE_DIRS ${GLM_INCLUDE_DIR})
+endif()
+
+# Hide some variables
+mark_as_advanced(GLM_INCLUDE_DIR)
\ No newline at end of file
Index: include/assimp/quaternion.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file quaternion.h\n *  @brief Quaternion structure, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_QUATERNION_H_INC\n#define AI_QUATERNION_H_INC\n\n#ifdef __cplusplus\n\n#include \"defs.h\"\n\ntemplate <typename TReal> class aiVector3t;\ntemplate <typename TReal> class aiMatrix3x3t;\n\n// ---------------------------------------------------------------------------\n/** Represents a quaternion in a 4D vector. */\ntemplate <typename TReal>\nclass aiQuaterniont\n{\npublic:\n    aiQuaterniont() AI_NO_EXCEPT : w(1.0), x(), y(), z() {}\n    aiQuaterniont(TReal pw, TReal px, TReal py, TReal pz)\n        : w(pw), x(px), y(py), z(pz) {}\n\n    /** Construct from rotation matrix. Result is undefined if the matrix is not orthonormal. */\n    explicit aiQuaterniont( const aiMatrix3x3t<TReal>& pRotMatrix);\n\n    /** Construct from euler angles */\n    aiQuaterniont( TReal rotx, TReal roty, TReal rotz);\n\n    /** Construct from an axis-angle pair */\n    aiQuaterniont( aiVector3t<TReal> axis, TReal angle);\n\n    /** Construct from a normalized quaternion stored in a vec3 */\n    explicit aiQuaterniont( aiVector3t<TReal> normalized);\n\n    /** Returns a matrix representation of the quaternion */\n    aiMatrix3x3t<TReal> GetMatrix() const;\n\npublic:\n\n    bool operator== (const aiQuaterniont& o) const;\n    bool operator!= (const aiQuaterniont& o) const;\n\n    bool Equal(const aiQuaterniont& o, TReal epsilon = 1e-6) const;\n\npublic:\n\n    /** Normalize the quaternion */\n    aiQuaterniont& Normalize();\n\n    /** Compute quaternion conjugate */\n    aiQuaterniont& Conjugate ();\n\n    /** Rotate a point by this quaternion */\n    aiVector3t<TReal> Rotate (const aiVector3t<TReal>& in);\n\n    /** Multiply two quaternions */\n    aiQuaterniont operator* (const aiQuaterniont& two) const;\n\npublic:\n\n    /** Performs a spherical interpolation between two quaternions and writes the result into the third.\n     * @param pOut Target object to received the interpolated rotation.\n     * @param pStart Start rotation of the interpolation at factor == 0.\n     * @param pEnd End rotation, factor == 1.\n     * @param pFactor Interpolation factor between 0 and 1. Values outside of this range yield undefined results.\n     */\n    static void Interpolate( aiQuaterniont& pOut, const aiQuaterniont& pStart,\n        const aiQuaterniont& pEnd, TReal pFactor);\n\npublic:\n\n    //! w,x,y,z components of the quaternion\n    TReal w, x, y, z;\n} ;\n\ntypedef aiQuaterniont<ai_real> aiQuaternion;\n\n#else\n\nstruct aiQuaternion {\n    ai_real w, x, y, z;\n};\n\n#endif\n\n#endif // AI_QUATERNION_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/quaternion.h b/include/assimp/quaternion.h
--- a/include/assimp/quaternion.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/quaternion.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -49,7 +49,11 @@
 
 #ifdef __cplusplus
 
-#include "defs.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/defs.h>
 
 template <typename TReal> class aiVector3t;
 template <typename TReal> class aiMatrix3x3t;
Index: include/assimp/cfileio.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file cfileio.h\n *  @brief Defines generic C routines to access memory-mapped files\n */\n#pragma once\n#ifndef AI_FILEIO_H_INC\n#define AI_FILEIO_H_INC\n\n#include <assimp/types.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct aiFileIO;\nstruct aiFile;\n\n// aiFile callbacks\ntypedef size_t          (*aiFileWriteProc) (C_STRUCT aiFile*,   const char*, size_t, size_t);\ntypedef size_t          (*aiFileReadProc)  (C_STRUCT aiFile*,   char*, size_t,size_t);\ntypedef size_t          (*aiFileTellProc)  (C_STRUCT aiFile*);\ntypedef void            (*aiFileFlushProc) (C_STRUCT aiFile*);\ntypedef C_ENUM aiReturn (*aiFileSeek)      (C_STRUCT aiFile*, size_t, C_ENUM aiOrigin);\n\n// aiFileIO callbacks\ntypedef C_STRUCT aiFile* (*aiFileOpenProc)  (C_STRUCT aiFileIO*, const char*, const char*);\ntypedef void             (*aiFileCloseProc) (C_STRUCT aiFileIO*, C_STRUCT aiFile*);\n\n// Represents user-defined data\ntypedef char* aiUserData;\n\n// ----------------------------------------------------------------------------------\n/** @brief C-API: File system callbacks\n *\n *  Provided are functions to open and close files. Supply a custom structure to\n *  the import function. If you don't, a default implementation is used. Use custom\n *  file systems to enable reading from other sources, such as ZIPs\n *  or memory locations. */\nstruct aiFileIO\n{\n    /** Function used to open a new file\n     */\n    aiFileOpenProc OpenProc;\n\n    /** Function used to close an existing file\n     */\n    aiFileCloseProc CloseProc;\n\n    /** User-defined, opaque data */\n    aiUserData UserData;\n};\n\n// ----------------------------------------------------------------------------------\n/** @brief C-API: File callbacks\n *\n *  Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)\n *  replacement functions.\n *\n *  The default implementation of the functions utilizes the fXXX functions from\n *  the CRT. However, you can supply a custom implementation to Assimp by\n *  delivering a custom aiFileIO. Use this to enable reading from other sources,\n *  such as ZIP archives or memory locations. */\nstruct aiFile\n{\n    /** Callback to read from a file */\n    aiFileReadProc ReadProc;\n\n    /** Callback to write to a file */\n    aiFileWriteProc WriteProc;\n\n    /** Callback to retrieve the current position of\n     *  the file cursor (ftell())\n     */\n    aiFileTellProc TellProc;\n\n    /** Callback to retrieve the size of the file,\n     *  in bytes\n     */\n    aiFileTellProc FileSizeProc;\n\n    /** Callback to set the current position\n     * of the file cursor (fseek())\n     */\n    aiFileSeek SeekProc;\n\n    /** Callback to flush the file contents\n     */\n    aiFileFlushProc FlushProc;\n\n    /** User-defined, opaque data\n     */\n    aiUserData UserData;\n};\n\n#ifdef __cplusplus\n}\n#endif\n#endif // AI_FILEIO_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/cfileio.h b/include/assimp/cfileio.h
--- a/include/assimp/cfileio.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/cfileio.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,10 +48,16 @@
 #ifndef AI_FILEIO_H_INC
 #define AI_FILEIO_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
+
 struct aiFileIO;
 struct aiFile;
 
Index: include/assimp/Subdivision.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Defines a helper class to evaluate subdivision surfaces.*/\n#pragma once\n#ifndef AI_SUBDISIVION_H_INC\n#define AI_SUBDISIVION_H_INC\n\n#include <cstddef>\n#include <assimp/types.h>\n\nstruct aiMesh;\n\nnamespace Assimp    {\n\n// ------------------------------------------------------------------------------\n/** Helper class to evaluate subdivision surfaces. Different algorithms\n *  are provided for choice. */\n// ------------------------------------------------------------------------------\nclass ASSIMP_API Subdivider {\npublic:\n\n    /** Enumerates all supported subvidision algorithms */\n    enum Algorithm  {\n        CATMULL_CLARKE = 0x1\n    };\n\n    virtual ~Subdivider();\n\n    // ---------------------------------------------------------------\n    /** Create a subdivider of a specific type\n     *\n     *  @param algo Algorithm to be used for subdivision\n     *  @return Subdivider instance. */\n    static Subdivider* Create (Algorithm algo);\n\n    // ---------------------------------------------------------------\n    /** Subdivide a mesh using the selected algorithm\n     *\n     *  @param mesh First mesh to be subdivided. Must be in verbose\n     *    format.\n     *  @param out Receives the output mesh, allocated by me.\n     *  @param num Number of subdivisions to perform.\n     *  @param discard_input If true is passed, the input mesh is\n     *    deleted after the subdivision is complete. This can\n     *    improve performance because it allows the optimization\n     *    to reuse the existing mesh for intermediate results.\n     *  @pre out!=mesh*/\n    virtual void Subdivide ( aiMesh* mesh,\n        aiMesh*& out, unsigned int num,\n        bool discard_input = false) = 0;\n\n    // ---------------------------------------------------------------\n    /** Subdivide multiple meshes using the selected algorithm. This\n     *  avoids erroneous smoothing on objects consisting of multiple\n     *  per-material meshes. Usually, most 3d modellers smooth on a\n     *  per-object base, regardless the materials assigned to the\n     *  meshes.\n     *\n     *  @param smesh Array of meshes to be subdivided. Must be in\n     *    verbose format.\n     *  @param nmesh Number of meshes in smesh.\n     *  @param out Receives the output meshes. The array must be\n     *    sufficiently large (at least @c nmesh elements) and may not\n     *    overlap the input array. Output meshes map one-to-one to\n     *    their corresponding input meshes. The meshes are allocated\n     *    by the function.\n     *  @param discard_input If true is passed, input meshes are\n     *    deleted after the subdivision is complete. This can\n     *    improve performance because it allows the optimization\n     *    of reusing existing meshes for intermediate results.\n     *  @param num Number of subdivisions to perform.\n     *  @pre nmesh != 0, smesh and out may not overlap*/\n    virtual void Subdivide (\n        aiMesh** smesh,\n        size_t nmesh,\n        aiMesh** out,\n        unsigned int num,\n        bool discard_input = false) = 0;\n\n};\n\ninline\nSubdivider::~Subdivider() {\n    // empty\n}\n\n} // end namespace Assimp\n\n\n#endif // !!  AI_SUBDISIVION_H_INC\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Subdivision.h b/include/assimp/Subdivision.h
--- a/include/assimp/Subdivision.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Subdivision.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -45,7 +45,10 @@
 #ifndef AI_SUBDISIVION_H_INC
 #define AI_SUBDISIVION_H_INC
 
-#include <cstddef>
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
 
 struct aiMesh;
Index: include/assimp/ZipArchiveIOSystem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file ZipArchiveIOSystem.h\n *  @brief Implementation of IOSystem to read a ZIP file from another IOSystem\n*/\n\n#ifndef AI_ZIPARCHIVEIOSYSTEM_H_INC\n#define AI_ZIPARCHIVEIOSYSTEM_H_INC\n\n#include <assimp/IOStream.hpp>\n#include <assimp/IOSystem.hpp>\n\nnamespace Assimp {\n    class ZipArchiveIOSystem : public IOSystem {\n    public:\n        //! Open a Zip using the proffered IOSystem\n        ZipArchiveIOSystem(IOSystem* pIOHandler, const char *pFilename, const char* pMode = \"r\");\n        ZipArchiveIOSystem(IOSystem* pIOHandler, const std::string& rFilename, const char* pMode = \"r\");\n        virtual ~ZipArchiveIOSystem();\n        bool Exists(const char* pFilename) const override;\n        char getOsSeparator() const override;\n        IOStream* Open(const char* pFilename, const char* pMode = \"rb\") override;\n        void Close(IOStream* pFile) override;\n\n        // Specific to ZIP\n        //! The file was opened and is a ZIP\n        bool isOpen() const;\n\n        //! Get the list of all files with their simplified paths\n        //! Intended for use within Assimp library boundaries\n        void getFileList(std::vector<std::string>& rFileList) const;\n\n        //! Get the list of all files with extension (must be lowercase)\n        //! Intended for use within Assimp library boundaries\n        void getFileListExtension(std::vector<std::string>& rFileList, const std::string& extension) const;\n\n        static bool isZipArchive(IOSystem* pIOHandler, const char *pFilename);\n        static bool isZipArchive(IOSystem* pIOHandler, const std::string& rFilename);\n\n    private:\n        class Implement;\n        Implement *pImpl = nullptr;\n    };\n} // Namespace Assimp\n\n#endif // AI_ZIPARCHIVEIOSYSTEM_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/ZipArchiveIOSystem.h b/include/assimp/ZipArchiveIOSystem.h
--- a/include/assimp/ZipArchiveIOSystem.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/ZipArchiveIOSystem.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -45,43 +45,50 @@
  *  @brief Implementation of IOSystem to read a ZIP file from another IOSystem
 */
 
+#pragma once
 #ifndef AI_ZIPARCHIVEIOSYSTEM_H_INC
 #define AI_ZIPARCHIVEIOSYSTEM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/IOStream.hpp>
 #include <assimp/IOSystem.hpp>
 
 namespace Assimp {
-    class ZipArchiveIOSystem : public IOSystem {
-    public:
-        //! Open a Zip using the proffered IOSystem
-        ZipArchiveIOSystem(IOSystem* pIOHandler, const char *pFilename, const char* pMode = "r");
-        ZipArchiveIOSystem(IOSystem* pIOHandler, const std::string& rFilename, const char* pMode = "r");
-        virtual ~ZipArchiveIOSystem();
-        bool Exists(const char* pFilename) const override;
-        char getOsSeparator() const override;
-        IOStream* Open(const char* pFilename, const char* pMode = "rb") override;
-        void Close(IOStream* pFile) override;
+
+class ZipArchiveIOSystem : public IOSystem {
+public:
+    //! Open a Zip using the proffered IOSystem
+    ZipArchiveIOSystem(IOSystem* pIOHandler, const char *pFilename, const char* pMode = "r");
+    ZipArchiveIOSystem(IOSystem* pIOHandler, const std::string& rFilename, const char* pMode = "r");
+    virtual ~ZipArchiveIOSystem();
+    bool Exists(const char* pFilename) const override;
+    char getOsSeparator() const override;
+    IOStream* Open(const char* pFilename, const char* pMode = "rb") override;
+    void Close(IOStream* pFile) override;
 
-        // Specific to ZIP
-        //! The file was opened and is a ZIP
-        bool isOpen() const;
+    // Specific to ZIP
+    //! The file was opened and is a ZIP
+    bool isOpen() const;
 
-        //! Get the list of all files with their simplified paths
-        //! Intended for use within Assimp library boundaries
-        void getFileList(std::vector<std::string>& rFileList) const;
+    //! Get the list of all files with their simplified paths
+    //! Intended for use within Assimp library boundaries
+    void getFileList(std::vector<std::string>& rFileList) const;
 
-        //! Get the list of all files with extension (must be lowercase)
-        //! Intended for use within Assimp library boundaries
-        void getFileListExtension(std::vector<std::string>& rFileList, const std::string& extension) const;
+    //! Get the list of all files with extension (must be lowercase)
+    //! Intended for use within Assimp library boundaries
+    void getFileListExtension(std::vector<std::string>& rFileList, const std::string& extension) const;
 
-        static bool isZipArchive(IOSystem* pIOHandler, const char *pFilename);
-        static bool isZipArchive(IOSystem* pIOHandler, const std::string& rFilename);
+    static bool isZipArchive(IOSystem* pIOHandler, const char *pFilename);
+    static bool isZipArchive(IOSystem* pIOHandler, const std::string& rFilename);
 
-    private:
-        class Implement;
-        Implement *pImpl = nullptr;
-    };
+private:
+    class Implement;
+    Implement *pImpl = nullptr;
+};
+
 } // Namespace Assimp
 
 #endif // AI_ZIPARCHIVEIOSYSTEM_H_INC
Index: include/assimp/Exporter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  Exporter.hpp\n*  @brief Defines the CPP-API for the Assimp export interface\n*/\n#pragma once\n#ifndef AI_EXPORT_HPP_INC\n#define AI_EXPORT_HPP_INC\n\n#ifndef ASSIMP_BUILD_NO_EXPORT\n\n#include \"cexport.h\"\n#include <map>\n\nnamespace Assimp {\n    \nclass ExporterPimpl;\nclass IOSystem;\nclass ProgressHandler;\n\n// ----------------------------------------------------------------------------------\n/** CPP-API: The Exporter class forms an C++ interface to the export functionality\n * of the Open Asset Import Library. Note that the export interface is available\n * only if Assimp has been built with ASSIMP_BUILD_NO_EXPORT not defined.\n *\n * The interface is modeled after the importer interface and mostly\n * symmetric. The same rules for threading etc. apply.\n *\n * In a nutshell, there are two export interfaces: #Export, which writes the\n * output file(s) either to the regular file system or to a user-supplied\n * #IOSystem, and #ExportToBlob which returns a linked list of memory\n * buffers (blob), each referring to one output file (in most cases\n * there will be only one output file of course, but this extra complexity is\n * needed since Assimp aims at supporting a wide range of file formats).\n *\n * #ExportToBlob is especially useful if you intend to work\n * with the data in-memory.\n*/\nclass ASSIMP_API ExportProperties;\n\nclass ASSIMP_API Exporter {\npublic:\n    /** Function pointer type of a Export worker function */\n    typedef void (*fpExportFunc)(const char*, IOSystem*, const aiScene*, const ExportProperties*);\n\n    /** Internal description of an Assimp export format option */\n    struct ExportFormatEntry {\n        /// Public description structure to be returned by aiGetExportFormatDescription()\n        aiExportFormatDesc mDescription;\n\n        // Worker function to do the actual exporting\n        fpExportFunc mExportFunction;\n\n        // Post-processing steps to be executed PRIOR to invoking mExportFunction\n        unsigned int mEnforcePP;\n\n        // Constructor to fill all entries\n        ExportFormatEntry( const char* pId, const char* pDesc, const char* pExtension, fpExportFunc pFunction, unsigned int pEnforcePP = 0u)\n        {\n            mDescription.id = pId;\n            mDescription.description = pDesc;\n            mDescription.fileExtension = pExtension;\n            mExportFunction = pFunction;\n            mEnforcePP = pEnforcePP;\n        }\n\n        ExportFormatEntry() :\n            mExportFunction()\n          , mEnforcePP()\n        {\n            mDescription.id = NULL;\n            mDescription.description = NULL;\n            mDescription.fileExtension = NULL;\n        }\n    };\n\n    /**\n     *  @brief  The class constructor.\n     */\n    Exporter();\n\n    /**\n    *  @brief  The class destructor.\n    */\n    ~Exporter();\n\n    // -------------------------------------------------------------------\n    /** Supplies a custom IO handler to the exporter to use to open and\n     * access files.\n     *\n     * If you need #Export to use custom IO logic to access the files,\n     * you need to supply a custom implementation of IOSystem and\n     * IOFile to the exporter.\n     *\n     * #Exporter takes ownership of the object and will destroy it\n     * afterwards. The previously assigned handler will be deleted.\n     * Pass NULL to take again ownership of your IOSystem and reset Assimp\n     * to use its default implementation, which uses plain file IO.\n     *\n     * @param pIOHandler The IO handler to be used in all file accesses\n     *   of the Importer. */\n    void SetIOHandler( IOSystem* pIOHandler);\n\n    // -------------------------------------------------------------------\n    /** Retrieves the IO handler that is currently set.\n     * You can use #IsDefaultIOHandler() to check whether the returned\n     * interface is the default IO handler provided by ASSIMP. The default\n     * handler is active as long the application doesn't supply its own\n     * custom IO handler via #SetIOHandler().\n     * @return A valid IOSystem interface, never NULL. */\n    IOSystem* GetIOHandler() const;\n\n    // -------------------------------------------------------------------\n    /** Checks whether a default IO handler is active\n     * A default handler is active as long the application doesn't\n     * supply its own custom IO handler via #SetIOHandler().\n     * @return true by default */\n    bool IsDefaultIOHandler() const;\n\n    // -------------------------------------------------------------------\n    /** Supplies a custom progress handler to the exporter. This\n     *  interface exposes an #Update() callback, which is called\n     *  more or less periodically (please don't sue us if it\n     *  isn't as periodically as you'd like it to have ...).\n     *  This can be used to implement progress bars and loading\n     *  timeouts.\n     *  @param pHandler Progress callback interface. Pass nullptr to\n     *    disable progress reporting.\n     *  @note Progress handlers can be used to abort the loading\n     *    at almost any time.*/\n    void SetProgressHandler(ProgressHandler* pHandler);\n\n    // -------------------------------------------------------------------\n    /** Exports the given scene to a chosen file format. Returns the exported\n    * data as a binary blob which you can write into a file or something.\n    * When you're done with the data, simply let the #Exporter instance go\n    * out of scope to have it released automatically.\n    * @param pScene The scene to export. Stays in possession of the caller,\n    *   is not changed by the function.\n    * @param pFormatId ID string to specify to which format you want to\n    *   export to. Use\n    * #GetExportFormatCount / #GetExportFormatDescription to learn which\n    *   export formats are available.\n    * @param pPreprocessing See the documentation for #Export\n    * @return the exported data or NULL in case of error.\n    * @note If the Exporter instance did already hold a blob from\n    *   a previous call to #ExportToBlob, it will be disposed.\n    *   Any IO handlers set via #SetIOHandler are ignored here.\n    * @note Use aiCopyScene() to get a modifiable copy of a previously\n    *   imported scene. */\n    const aiExportDataBlob* ExportToBlob(const aiScene* pScene, const char* pFormatId,\n        unsigned int pPreprocessing = 0u, const ExportProperties* pProperties = nullptr);\n    const aiExportDataBlob* ExportToBlob(  const aiScene* pScene, const std::string& pFormatId,\n        unsigned int pPreprocessing = 0u, const ExportProperties* pProperties = nullptr);\n\n    // -------------------------------------------------------------------\n    /** Convenience function to export directly to a file. Use\n     *  #SetIOSystem to supply a custom IOSystem to gain fine-grained control\n     *  about the output data flow of the export process.\n     * @param pBlob A data blob obtained from a previous call to #aiExportScene. Must not be NULL.\n     * @param pPath Full target file name. Target must be accessible.\n     * @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated\n     *   flags, but in reality only a subset of them makes sense here. Specifying\n     *   'preprocessing' flags is useful if the input scene does not conform to\n     *   Assimp's default conventions as specified in the @link data Data Structures Page @endlink.\n     *   In short, this means the geometry data should use a right-handed coordinate systems, face\n     *   winding should be counter-clockwise and the UV coordinate origin is assumed to be in\n     *   the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n     *   #aiProcess_FlipWindingOrder flags are used in the import side to allow users\n     *   to have those defaults automatically adapted to their conventions. Specifying those flags\n     *   for exporting has the opposite effect, respectively. Some other of the\n     *   #aiPostProcessSteps enumerated values may be useful as well, but you'll need\n     *   to try out what their effect on the exported file is. Many formats impose\n     *   their own restrictions on the structure of the geometry stored therein,\n     *   so some preprocessing may have little or no effect at all, or may be\n     *   redundant as exporters would apply them anyhow. A good example\n     *   is triangulation - whilst you can enforce it by specifying\n     *   the #aiProcess_Triangulate flag, most export formats support only\n     *   triangulate data so they would run the step even if it wasn't requested.\n     *\n     *   If assimp detects that the input scene was directly taken from the importer side of\n     *   the library (i.e. not copied using aiCopyScene and potentially modified afterwards),\n     *   any post-processing steps already applied to the scene will not be applied again, unless\n     *   they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n     *   #aiProcess_FlipWindingOrder).\n     * @return AI_SUCCESS if everything was fine.\n     * @note Use aiCopyScene() to get a modifiable copy of a previously\n     *   imported scene.*/\n    aiReturn Export( const aiScene* pScene, const char* pFormatId, const char* pPath,\n        unsigned int pPreprocessing = 0u, const ExportProperties* pProperties = nullptr);\n    aiReturn Export( const aiScene* pScene, const std::string& pFormatId, const std::string& pPath,\n        unsigned int pPreprocessing = 0u, const ExportProperties* pProperties = nullptr);\n\n    // -------------------------------------------------------------------\n    /** Returns an error description of an error that occurred in #Export\n     *    or #ExportToBlob\n     *\n     * Returns an empty string if no error occurred.\n     * @return A description of the last error, an empty string if no\n     *   error occurred. The string is never NULL.\n     *\n     * @note The returned function remains valid until one of the\n     * following methods is called: #Export, #ExportToBlob, #FreeBlob */\n    const char* GetErrorString() const;\n\n    // -------------------------------------------------------------------\n    /** Return the blob obtained from the last call to #ExportToBlob */\n    const aiExportDataBlob* GetBlob() const;\n\n    // -------------------------------------------------------------------\n    /** Orphan the blob from the last call to #ExportToBlob. This means\n     *  the caller takes ownership and is thus responsible for calling\n     *  the C API function #aiReleaseExportBlob to release it. */\n    const aiExportDataBlob* GetOrphanedBlob() const;\n\n    // -------------------------------------------------------------------\n    /** Frees the current blob.\n     *\n     *  The function does nothing if no blob has previously been\n     *  previously produced via #ExportToBlob. #FreeBlob is called\n     *  automatically by the destructor. The only reason to call\n     *  it manually would be to reclaim as much storage as possible\n     *  without giving up the #Exporter instance yet. */\n    void FreeBlob( );\n\n    // -------------------------------------------------------------------\n    /** Returns the number of export file formats available in the current\n     *  Assimp build. Use #Exporter::GetExportFormatDescription to\n     *  retrieve infos of a specific export format.\n     *\n     *  This includes built-in exporters as well as exporters registered\n     *  using #RegisterExporter.\n     **/\n    size_t GetExportFormatCount() const;\n\n    // -------------------------------------------------------------------\n    /** Returns a description of the nth export file format. Use #\n     *  #Exporter::GetExportFormatCount to learn how many export\n     *  formats are supported.\n     *\n     * The returned pointer is of static storage duration if the\n     * pIndex pertains to a built-in exporter (i.e. one not registered\n     * via #RegistrerExporter). It is restricted to the life-time of the\n     * #Exporter instance otherwise.\n     *\n     * @param pIndex Index of the export format to retrieve information\n     *  for. Valid range is 0 to #Exporter::GetExportFormatCount\n     * @return A description of that specific export format.\n     *  NULL if pIndex is out of range. */\n    const aiExportFormatDesc* GetExportFormatDescription( size_t pIndex ) const;\n\n    // -------------------------------------------------------------------\n    /** Register a custom exporter. Custom export formats are limited to\n     *    to the current #Exporter instance and do not affect the\n     *    library globally. The indexes under which the format's\n     *    export format description can be queried are assigned\n     *    monotonously.\n     *  @param desc Exporter description.\n     *  @return aiReturn_SUCCESS if the export format was successfully\n     *    registered. A common cause that would prevent an exporter\n     *    from being registered is that its format id is already\n     *    occupied by another format. */\n    aiReturn RegisterExporter(const ExportFormatEntry& desc);\n\n    // -------------------------------------------------------------------\n    /** Remove an export format previously registered with #RegisterExporter\n     *  from the #Exporter instance (this can also be used to drop\n     *  built-in exporters because those are implicitly registered\n     *  using #RegisterExporter).\n     *  @param id Format id to be unregistered, this refers to the\n     *    'id' field of #aiExportFormatDesc.\n     *  @note Calling this method on a format description not yet registered\n     *    has no effect.*/\n    void UnregisterExporter(const char* id);\n\nprotected:\n    // Just because we don't want you to know how we're hacking around.\n    ExporterPimpl* pimpl;\n};\n\nclass ASSIMP_API ExportProperties {\npublic:\n    // Data type to store the key hash\n    typedef unsigned int KeyType;\n\n    // typedefs for our four configuration maps.\n    // We don't need more, so there is no need for a generic solution\n    typedef std::map<KeyType, int> IntPropertyMap;\n    typedef std::map<KeyType, ai_real> FloatPropertyMap;\n    typedef std::map<KeyType, std::string> StringPropertyMap;\n    typedef std::map<KeyType, aiMatrix4x4> MatrixPropertyMap;\n\npublic:\n    /** Standard constructor\n    * @see ExportProperties()\n    */\n    ExportProperties();\n\n    // -------------------------------------------------------------------\n    /** Copy constructor.\n     *\n     * This copies the configuration properties of another ExportProperties.\n     * @see ExportProperties(const ExportProperties& other)\n     */\n    ExportProperties(const ExportProperties& other);\n\n    // -------------------------------------------------------------------\n    /** Set an integer configuration property.\n     * @param szName Name of the property. All supported properties\n     *   are defined in the aiConfig.g header (all constants share the\n     *   prefix AI_CONFIG_XXX and are simple strings).\n     * @param iValue New value of the property\n     * @return true if the property was set before. The new value replaces\n     *   the previous value in this case.\n     * @note Property of different types (float, int, string ..) are kept\n     *   on different stacks, so calling SetPropertyInteger() for a\n     *   floating-point property has no effect - the loader will call\n     *   GetPropertyFloat() to read the property, but it won't be there.\n     */\n    bool SetPropertyInteger(const char* szName, int iValue);\n\n    // -------------------------------------------------------------------\n    /** Set a boolean configuration property. Boolean properties\n     *  are stored on the integer stack internally so it's possible\n     *  to set them via #SetPropertyBool and query them with\n     *  #GetPropertyBool and vice versa.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyBool(const char* szName, bool value)    {\n        return SetPropertyInteger(szName,value);\n    }\n\n    // -------------------------------------------------------------------\n    /** Set a floating-point configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyFloat(const char* szName, ai_real fValue);\n\n    // -------------------------------------------------------------------\n    /** Set a string configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyString(const char* szName, const std::string& sValue);\n\n    // -------------------------------------------------------------------\n    /** Set a matrix configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyMatrix(const char* szName, const aiMatrix4x4& sValue);\n\n    // -------------------------------------------------------------------\n    /** Get a configuration property.\n     * @param szName Name of the property. All supported properties\n     *   are defined in the aiConfig.g header (all constants share the\n     *   prefix AI_CONFIG_XXX).\n     * @param iErrorReturn Value that is returned if the property\n     *   is not found.\n     * @return Current value of the property\n     * @note Property of different types (float, int, string ..) are kept\n     *   on different lists, so calling SetPropertyInteger() for a\n     *   floating-point property has no effect - the loader will call\n     *   GetPropertyFloat() to read the property, but it won't be there.\n     */\n    int GetPropertyInteger(const char* szName,\n        int iErrorReturn = 0xffffffff) const;\n\n    // -------------------------------------------------------------------\n    /** Get a boolean configuration property. Boolean properties\n     *  are stored on the integer stack internally so it's possible\n     *  to set them via #SetPropertyBool and query them with\n     *  #GetPropertyBool and vice versa.\n     * @see GetPropertyInteger()\n     */\n    bool GetPropertyBool(const char* szName, bool bErrorReturn = false) const {\n        return GetPropertyInteger(szName,bErrorReturn)!=0;\n    }\n\n    // -------------------------------------------------------------------\n    /** Get a floating-point configuration property\n     * @see GetPropertyInteger()\n     */\n    ai_real GetPropertyFloat(const char* szName,\n        ai_real fErrorReturn = 10e10f) const;\n\n    // -------------------------------------------------------------------\n    /** Get a string configuration property\n     *\n     *  The return value remains valid until the property is modified.\n     * @see GetPropertyInteger()\n     */\n    const std::string GetPropertyString(const char* szName,\n        const std::string& sErrorReturn = \"\") const;\n\n    // -------------------------------------------------------------------\n    /** Get a matrix configuration property\n     *\n     *  The return value remains valid until the property is modified.\n     * @see GetPropertyInteger()\n     */\n    const aiMatrix4x4 GetPropertyMatrix(const char* szName,\n        const aiMatrix4x4& sErrorReturn = aiMatrix4x4()) const;\n\n    // -------------------------------------------------------------------\n    /** Determine a integer configuration property has been set.\n    * @see HasPropertyInteger()\n     */\n    bool HasPropertyInteger(const char* szName) const;\n\n    /** Determine a boolean configuration property has been set.\n    * @see HasPropertyBool()\n     */\n    bool HasPropertyBool(const char* szName) const;\n\n    /** Determine a boolean configuration property has been set.\n    * @see HasPropertyFloat()\n     */\n    bool HasPropertyFloat(const char* szName) const;\n\n    /** Determine a String configuration property has been set.\n    * @see HasPropertyString()\n     */\n    bool HasPropertyString(const char* szName) const;\n\n    /** Determine a Matrix configuration property has been set.\n    * @see HasPropertyMatrix()\n     */\n    bool HasPropertyMatrix(const char* szName) const;\n\nprotected:\n\n    /** List of integer properties */\n    IntPropertyMap mIntProperties;\n\n    /** List of floating-point properties */\n    FloatPropertyMap mFloatProperties;\n\n    /** List of string properties */\n    StringPropertyMap mStringProperties;\n\n    /** List of Matrix properties */\n    MatrixPropertyMap mMatrixProperties;\n};\n\n// ----------------------------------------------------------------------------------\ninline \nconst aiExportDataBlob* Exporter::ExportToBlob(  const aiScene* pScene, const std::string& pFormatId,\n                                                 unsigned int pPreprocessing, const ExportProperties* pProperties)\n{\n    return ExportToBlob(pScene,pFormatId.c_str(),pPreprocessing, pProperties);\n}\n\n// ----------------------------------------------------------------------------------\ninline\naiReturn Exporter :: Export( const aiScene* pScene, const std::string& pFormatId, \n                                    const std::string& pPath, unsigned int pPreprocessing, \n                                    const ExportProperties* pProperties)\n{\n    return Export(pScene,pFormatId.c_str(),pPath.c_str(),pPreprocessing, pProperties);\n}\n\n} // namespace Assimp\n\n#endif // ASSIMP_BUILD_NO_EXPORT\n#endif // AI_EXPORT_HPP_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Exporter.hpp b/include/assimp/Exporter.hpp
--- a/include/assimp/Exporter.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Exporter.hpp	(date 1617519895000)
@@ -3,9 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -48,6 +46,10 @@
 #ifndef AI_EXPORT_HPP_INC
 #define AI_EXPORT_HPP_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifndef ASSIMP_BUILD_NO_EXPORT
 
 #include "cexport.h"
Index: cmake-files/FindAssimp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-files/FindAssimp.cmake b/cmake-files/FindAssimp.cmake
new file mode 100644
--- /dev/null	(date 1617532792000)
+++ b/cmake-files/FindAssimp.cmake	(date 1617532792000)
@@ -0,0 +1,66 @@
+#
+# Find Assimp
+#
+# Try to find Assimp : Open Asset Import Library.
+# This module defines the following variables:
+# - ASSIMP_INCLUDE_DIRS
+# - ASSIMP_LIBRARIES
+# - ASSIMP_FOUND
+#
+# The following variables can be set as arguments for the module.
+# - ASSIMP_ROOT_DIR : Root library directory of Assimp
+#
+
+# Additional modules
+include(FindPackageHandleStandardArgs)
+
+if (WIN32)
+    # Find include files
+    find_path(
+            ASSIMP_INCLUDE_DIR
+            NAMES assimp/scene.h
+            PATHS
+            $ENV{PROGRAMFILES}/include
+            ${ASSIMP_ROOT_DIR}/include
+            DOC "The directory where assimp/scene.h resides")
+
+    # Find library files
+    find_library(
+            ASSIMP_LIBRARY
+            NAMES assimp
+            PATHS
+            $ENV{PROGRAMFILES}/lib
+            ${ASSIMP_ROOT_DIR}/lib)
+else()
+    # Find include files
+    find_path(
+            ASSIMP_INCLUDE_DIR
+            NAMES assimp/scene.h
+            PATHS
+            /usr/include
+            /usr/local/include
+            /sw/include
+            /opt/local/include
+            DOC "The directory where assimp/scene.h resides")
+
+    # Find library files
+    find_library(
+            ASSIMP_LIBRARY
+            NAMES assimp
+            PATHS
+            /usr/local/Cellar
+            ${ASSIMP_ROOT_DIR}/lib
+            DOC "The Assimp library")
+endif()
+
+# Handle REQUIRD argument, define *_FOUND variable
+find_package_handle_standard_args(Assimp DEFAULT_MSG ASSIMP_INCLUDE_DIR ASSIMP_LIBRARY)
+
+# Define GLFW_LIBRARIES and GLFW_INCLUDE_DIRS
+if (ASSIMP_FOUND)
+    set(ASSIMP_LIBRARIES ${ASSIMP_LIBRARY})
+    set(ASSIMP_INCLUDE_DIRS ${ASSIMP_INCLUDE_DIR})
+endif()
+
+# Hide some variables
+mark_as_advanced(ASSIMP_INCLUDE_DIR ASSIMP_LIBRARY)
\ No newline at end of file
Index: include/assimp/metadata.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file metadata.h\n *  @brief Defines the data structures for holding node meta information.\n */\n#pragma once\n#ifndef AI_METADATA_H_INC\n#define AI_METADATA_H_INC\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1500)\n#  include \"Compiler/pstdint.h\"\n#else\n#  include <stdint.h>\n#endif\n\n// -------------------------------------------------------------------------------\n/**\n  * Enum used to distinguish data types\n  */\n // -------------------------------------------------------------------------------\ntypedef enum aiMetadataType {\n    AI_BOOL       = 0,\n    AI_INT32      = 1,\n    AI_UINT64     = 2,\n    AI_FLOAT      = 3,\n    AI_DOUBLE     = 4,\n    AI_AISTRING   = 5,\n    AI_AIVECTOR3D = 6,\n    AI_META_MAX   = 7,\n\n#ifndef SWIG\n    FORCE_32BIT = INT_MAX\n#endif\n} aiMetadataType;\n\n// -------------------------------------------------------------------------------\n/**\n  * Metadata entry\n  *\n  * The type field uniquely identifies the underlying type of the data field\n  */\n // -------------------------------------------------------------------------------\nstruct aiMetadataEntry {\n    aiMetadataType mType;\n    void* mData;\n};\n\n#ifdef __cplusplus\n\n#include <string>\n\n// -------------------------------------------------------------------------------\n/**\n  * Helper functions to get the aiType enum entry for a type\n  */\n // -------------------------------------------------------------------------------\n\ninline aiMetadataType GetAiType( bool )       { return AI_BOOL; }\ninline aiMetadataType GetAiType( int32_t )    { return AI_INT32; }\ninline aiMetadataType GetAiType( uint64_t )   { return AI_UINT64; }\ninline aiMetadataType GetAiType( float )      { return AI_FLOAT; }\ninline aiMetadataType GetAiType( double )     { return AI_DOUBLE; }\ninline aiMetadataType GetAiType( const aiString & )   { return AI_AISTRING; }\ninline aiMetadataType GetAiType( const aiVector3D & ) { return AI_AIVECTOR3D; }\n\n#endif // __cplusplus\n\n// -------------------------------------------------------------------------------\n/**\n  * Container for holding metadata.\n  *\n  * Metadata is a key-value store using string keys and values.\n  */\n // -------------------------------------------------------------------------------\nstruct aiMetadata {\n    /** Length of the mKeys and mValues arrays, respectively */\n    unsigned int mNumProperties;\n\n    /** Arrays of keys, may not be NULL. Entries in this array may not be NULL as well. */\n    C_STRUCT aiString* mKeys;\n\n    /** Arrays of values, may not be NULL. Entries in this array may be NULL if the\n      * corresponding property key has no assigned value. */\n    C_STRUCT aiMetadataEntry* mValues;\n\n#ifdef __cplusplus\n\n    /** \n     *  @brief  The default constructor, set all members to zero by default.\n     */\n    aiMetadata() AI_NO_EXCEPT\n    : mNumProperties(0)\n    , mKeys(nullptr)\n    , mValues(nullptr) {\n        // empty\n    }\n\n    aiMetadata( const aiMetadata &rhs )\n    : mNumProperties( rhs.mNumProperties )\n    , mKeys( nullptr )\n    , mValues( nullptr ) {\n        mKeys = new aiString[ mNumProperties ];\n        for ( size_t i = 0; i < static_cast<size_t>( mNumProperties ); ++i ) {\n            mKeys[ i ] = rhs.mKeys[ i ];\n        }\n        mValues = new aiMetadataEntry[ mNumProperties ];\n        for ( size_t i = 0; i < static_cast<size_t>(mNumProperties); ++i ) {\n            mValues[ i ].mType = rhs.mValues[ i ].mType;\n            switch ( rhs.mValues[ i ].mType ) {\n            case AI_BOOL:\n                mValues[ i ].mData = new bool;\n                ::memcpy( mValues[ i ].mData, rhs.mValues[ i ].mData, sizeof(bool) );\n                break;\n            case AI_INT32: {\n                int32_t v;\n                ::memcpy( &v, rhs.mValues[ i ].mData, sizeof( int32_t ) );\n                mValues[ i ].mData = new int32_t( v );\n                }\n                break;\n            case AI_UINT64: {\n                    uint64_t v;\n                    ::memcpy( &v, rhs.mValues[ i ].mData, sizeof( uint64_t ) );\n                    mValues[ i ].mData = new  uint64_t( v );\n                }\n                break;\n            case AI_FLOAT: {\n                    float v;\n                    ::memcpy( &v, rhs.mValues[ i ].mData, sizeof( float ) );\n                    mValues[ i ].mData = new float( v );\n                }\n                break;\n            case AI_DOUBLE: {\n                    double v;\n                    ::memcpy( &v, rhs.mValues[ i ].mData, sizeof( double ) );\n                    mValues[ i ].mData = new double( v );\n                }\n                break;\n            case AI_AISTRING: {\n                    aiString v;\n                    rhs.Get<aiString>( mKeys[ i ], v );\n                    mValues[ i ].mData = new aiString( v );\n                }\n                break;\n            case AI_AIVECTOR3D: {\n                    aiVector3D v;\n                    rhs.Get<aiVector3D>( mKeys[ i ], v );\n                    mValues[ i ].mData = new aiVector3D( v );\n                }\n                break;\n#ifndef SWIG\n            case FORCE_32BIT:\n#endif\n            default:\n                break;\n            }\n\n        }\n    }\n\n    /** \n     *  @brief The destructor.\n     */\n    ~aiMetadata() {\n        delete [] mKeys;\n        mKeys = nullptr;\n        if (mValues) {\n            // Delete each metadata entry\n            for (unsigned i=0; i<mNumProperties; ++i) {\n                void* data = mValues[i].mData;\n                switch (mValues[i].mType) {\n                case AI_BOOL:\n                    delete static_cast< bool* >( data );\n                    break;\n                case AI_INT32:\n                    delete static_cast< int32_t* >( data );\n                    break;\n                case AI_UINT64:\n                    delete static_cast< uint64_t* >( data );\n                    break;\n                case AI_FLOAT:\n                    delete static_cast< float* >( data );\n                    break;\n                case AI_DOUBLE:\n                    delete static_cast< double* >( data );\n                    break;\n                case AI_AISTRING:\n                    delete static_cast< aiString* >( data );\n                    break;\n                case AI_AIVECTOR3D:\n                    delete static_cast< aiVector3D* >( data );\n                    break;\n#ifndef SWIG\n                case FORCE_32BIT:\n#endif\n                default:\n                    break;\n                }\n            }\n\n            // Delete the metadata array\n            delete [] mValues;\n            mValues = nullptr;\n        }\n    }\n\n    /**\n     *  @brief Allocates property fields + keys.\n     *  @param  numProperties   Number of requested properties.\n     */\n    static inline\n    aiMetadata *Alloc( unsigned int numProperties ) {\n        if ( 0 == numProperties ) {\n            return nullptr;\n        }\n\n        aiMetadata *data = new aiMetadata;\n        data->mNumProperties = numProperties;\n        data->mKeys = new aiString[ data->mNumProperties ]();\n        data->mValues = new aiMetadataEntry[ data->mNumProperties ]();\n\n        return data;\n    }\n\n    /**\n     *  @brief Deallocates property fields + keys.\n     */\n    static inline\n    void Dealloc( aiMetadata *metadata ) {\n        delete metadata;\n    }\n\n\ttemplate<typename T>\n\tinline\n    void Add(const std::string& key, const T& value) {\n\t\taiString* new_keys = new aiString[mNumProperties + 1];\n\t\taiMetadataEntry* new_values = new aiMetadataEntry[mNumProperties + 1];\n\n\t\tfor(unsigned int i = 0; i < mNumProperties; ++i)\n\t\t{\n\t\t\tnew_keys[i] = mKeys[i];\n\t\t\tnew_values[i] = mValues[i];\n\t\t}\n\n\t\tdelete mKeys;\n\t\tdelete mValues;\n\n\t\tmKeys = new_keys;\n\t\tmValues = new_values;\n\n\t\tmNumProperties++;\n\n\t\tSet(mNumProperties - 1, key, value);\n\t}\n\n    template<typename T>\n    inline \n    bool Set( unsigned index, const std::string& key, const T& value ) {\n        // In range assertion\n        if ( index >= mNumProperties ) {\n            return false;\n        }\n\n        // Ensure that we have a valid key.\n        if ( key.empty() ) {\n            return false;\n        }\n\n        // Set metadata key\n        mKeys[index] = key;\n\n        // Set metadata type\n        mValues[index].mType = GetAiType(value);\n        // Copy the given value to the dynamic storage\n        mValues[index].mData = new T(value);\n\n        return true;\n    }\n\n    template<typename T>\n    inline \n    bool Get( unsigned index, T& value ) const {\n        // In range assertion\n        if ( index >= mNumProperties ) {\n            return false;\n        }\n\n        // Return false if the output data type does\n        // not match the found value's data type\n        if ( GetAiType( value ) != mValues[ index ].mType ) {\n            return false;\n        }\n\n        // Otherwise, output the found value and\n        // return true\n        value = *static_cast<T*>(mValues[index].mData);\n\n        return true;\n    }\n\n    template<typename T>\n    inline \n    bool Get( const aiString& key, T& value ) const {\n        // Search for the given key\n        for ( unsigned int i = 0; i < mNumProperties; ++i ) {\n            if ( mKeys[ i ] == key ) {\n                return Get( i, value );\n            }\n        }\n        return false;\n    }\n\n    template<typename T>\n    inline\n    bool Get( const std::string& key, T& value ) const {\n        return Get(aiString(key), value);\n    }\n\n\t/// Return metadata entry for analyzing it by user.\n\t/// \\param [in] pIndex - index of the entry.\n\t/// \\param [out] pKey - pointer to the key value.\n\t/// \\param [out] pEntry - pointer to the entry: type and value.\n\t/// \\return false - if pIndex is out of range, else - true.\n\tinline\n    bool Get(size_t index, const aiString*& key, const aiMetadataEntry*& entry) const {\n        if ( index >= mNumProperties ) {\n            return false;\n        }\n\n\t\tkey = &mKeys[index];\n\t\tentry = &mValues[index];\n\n\t\treturn true;\n\t}\n\n#endif // __cplusplus\n\n};\n\n#endif // AI_METADATA_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/metadata.h b/include/assimp/metadata.h
--- a/include/assimp/metadata.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/metadata.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,6 +48,10 @@
 #ifndef AI_METADATA_H_INC
 #define AI_METADATA_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #if defined(_MSC_VER) && (_MSC_VER <= 1500)
 #  include "Compiler/pstdint.h"
 #else
@@ -282,8 +286,8 @@
 			new_values[i] = mValues[i];
 		}
 
-		delete mKeys;
-		delete mValues;
+		delete[] mKeys;
+		delete[] mValues;
 
 		mKeys = new_keys;
 		mValues = new_values;
@@ -373,6 +377,23 @@
 		return true;
 	}
 
+    /// Check whether there is a metadata entry for the given key.
+    /// \param [in] Key - the key value value to check for.
+    inline
+    bool HasKey(const char* key) {
+        if ( nullptr == key ) {
+            return false;
+        }
+        
+        // Search for the given key
+        for (unsigned int i = 0; i < mNumProperties; ++i) {
+            if ( 0 == strncmp(mKeys[i].C_Str(), key, mKeys[i].length ) ) {
+                return true;
+            }
+        }
+        return false;
+    }
+
 #endif // __cplusplus
 
 };
Index: include/assimp/BlobIOSystem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Provides cheat implementations for IOSystem and IOStream to\n *  redirect exporter output to a blob chain.*/\n\n#ifndef AI_BLOBIOSYSTEM_H_INCLUDED\n#define AI_BLOBIOSYSTEM_H_INCLUDED\n\n#include <assimp/IOStream.hpp>\n#include <assimp/cexport.h>\n#include <assimp/IOSystem.hpp>\n#include <assimp/DefaultLogger.hpp>\n#include <stdint.h>\n#include <set>\n#include <vector>\n\nnamespace Assimp    {\n    class BlobIOSystem;\n\n// --------------------------------------------------------------------------------------------\n/** Redirect IOStream to a blob */\n// --------------------------------------------------------------------------------------------\nclass BlobIOStream : public IOStream\n{\npublic:\n\n    BlobIOStream(BlobIOSystem* creator, const std::string& file, size_t initial = 4096)\n        : buffer()\n        , cur_size()\n        , file_size()\n        , cursor()\n        , initial(initial)\n        , file(file)\n        , creator(creator)\n    {\n    }\n\n\n    virtual ~BlobIOStream();\n\npublic:\n\n    // -------------------------------------------------------------------\n    aiExportDataBlob* GetBlob()\n    {\n        aiExportDataBlob* blob = new aiExportDataBlob();\n        blob->size = file_size;\n        blob->data = buffer;\n\n        buffer = NULL;\n\n        return blob;\n    }\n\n\npublic:\n\n\n    // -------------------------------------------------------------------\n    virtual size_t Read( void *,\n        size_t,\n        size_t )\n    {\n        return 0;\n    }\n\n    // -------------------------------------------------------------------\n    virtual size_t Write(const void* pvBuffer,\n        size_t pSize,\n        size_t pCount)\n    {\n        pSize *= pCount;\n        if (cursor + pSize > cur_size) {\n            Grow(cursor + pSize);\n        }\n\n        memcpy(buffer+cursor, pvBuffer, pSize);\n        cursor += pSize;\n\n        file_size = std::max(file_size,cursor);\n        return pCount;\n    }\n\n    // -------------------------------------------------------------------\n    virtual aiReturn Seek(size_t pOffset,\n        aiOrigin pOrigin)\n    {\n        switch(pOrigin)\n        {\n        case aiOrigin_CUR:\n            cursor += pOffset;\n            break;\n\n        case aiOrigin_END:\n            cursor = file_size - pOffset;\n            break;\n\n        case aiOrigin_SET:\n            cursor = pOffset;\n            break;\n\n        default:\n            return AI_FAILURE;\n        }\n\n        if (cursor > file_size) {\n            Grow(cursor);\n        }\n\n        file_size = std::max(cursor,file_size);\n        return AI_SUCCESS;\n    }\n\n    // -------------------------------------------------------------------\n    virtual size_t Tell() const\n    {\n        return cursor;\n    }\n\n    // -------------------------------------------------------------------\n    virtual size_t FileSize() const\n    {\n        return file_size;\n    }\n\n    // -------------------------------------------------------------------\n    virtual void Flush()\n    {\n        // ignore\n    }\n\n\n\nprivate:\n\n    // -------------------------------------------------------------------\n    void Grow(size_t need = 0)\n    {\n        // 1.5 and phi are very heap-friendly growth factors (the first\n        // allows for frequent re-use of heap blocks, the second\n        // forms a fibonacci sequence with similar characteristics -\n        // since this heavily depends on the heap implementation\n        // and other factors as well, i'll just go with 1.5 since\n        // it is quicker to compute).\n        size_t new_size = std::max(initial, std::max( need, cur_size+(cur_size>>1) ));\n\n        const uint8_t* const old = buffer;\n        buffer = new uint8_t[new_size];\n\n        if (old) {\n            memcpy(buffer,old,cur_size);\n            delete[] old;\n        }\n\n        cur_size = new_size;\n    }\n\nprivate:\n\n    uint8_t* buffer;\n    size_t cur_size,file_size, cursor, initial;\n\n    const std::string file;\n    BlobIOSystem* const creator;\n};\n\n\n#define AI_BLOBIO_MAGIC \"$blobfile\"\n\n// --------------------------------------------------------------------------------------------\n/** Redirect IOSystem to a blob */\n// --------------------------------------------------------------------------------------------\nclass BlobIOSystem : public IOSystem\n{\n\n    friend class BlobIOStream;\n    typedef std::pair<std::string, aiExportDataBlob*> BlobEntry;\n\npublic:\n\n    BlobIOSystem()\n    {\n    }\n\n    virtual ~BlobIOSystem()\n    {\n        for(BlobEntry& blobby : blobs) {\n            delete blobby.second;\n        }\n    }\n\npublic:\n\n    // -------------------------------------------------------------------\n    const char* GetMagicFileName() const\n    {\n        return AI_BLOBIO_MAGIC;\n    }\n\n\n    // -------------------------------------------------------------------\n    aiExportDataBlob* GetBlobChain()\n    {\n        // one must be the master\n        aiExportDataBlob* master = NULL, *cur;\n        for(const BlobEntry& blobby : blobs) {\n            if (blobby.first == AI_BLOBIO_MAGIC) {\n                master = blobby.second;\n                break;\n            }\n        }\n        if (!master) {\n            ASSIMP_LOG_ERROR(\"BlobIOSystem: no data written or master file was not closed properly.\");\n            return NULL;\n        }\n\n        master->name.Set(\"\");\n\n        cur = master;\n        for(const BlobEntry& blobby : blobs) {\n            if (blobby.second == master) {\n                continue;\n            }\n\n            cur->next = blobby.second;\n            cur = cur->next;\n\n            // extract the file extension from the file written\n            const std::string::size_type s = blobby.first.find_first_of('.');\n            cur->name.Set(s == std::string::npos ? blobby.first : blobby.first.substr(s+1));\n        }\n\n        // give up blob ownership\n        blobs.clear();\n        return master;\n    }\n\npublic:\n\n    // -------------------------------------------------------------------\n    virtual bool Exists( const char* pFile) const {\n        return created.find(std::string(pFile)) != created.end();\n    }\n\n\n    // -------------------------------------------------------------------\n    virtual char getOsSeparator() const {\n        return '/';\n    }\n\n\n    // -------------------------------------------------------------------\n    virtual IOStream* Open(const char* pFile,\n        const char* pMode)\n    {\n        if (pMode[0] != 'w') {\n            return NULL;\n        }\n\n        created.insert(std::string(pFile));\n        return new BlobIOStream(this,std::string(pFile));\n    }\n\n    // -------------------------------------------------------------------\n    virtual void Close( IOStream* pFile)\n    {\n        delete pFile;\n    }\n\nprivate:\n\n    // -------------------------------------------------------------------\n    void OnDestruct(const std::string& filename, BlobIOStream* child)\n    {\n        // we don't know in which the files are closed, so we\n        // can't reliably say that the first must be the master\n        // file ...\n        blobs.push_back( BlobEntry(filename,child->GetBlob()) );\n    }\n\nprivate:\n    std::set<std::string> created;\n    std::vector< BlobEntry > blobs;\n};\n\n\n// --------------------------------------------------------------------------------------------\nBlobIOStream :: ~BlobIOStream()\n{\n    creator->OnDestruct(file,this);\n    delete[] buffer;\n}\n\n\n} // end Assimp\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/BlobIOSystem.h b/include/assimp/BlobIOSystem.h
--- a/include/assimp/BlobIOSystem.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/BlobIOSystem.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
Index: include/assimp/types.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file types.h\n *  Basic data types and primitives, such as vectors or colors.\n */\n#pragma once\n#ifndef AI_TYPES_H_INC\n#define AI_TYPES_H_INC\n\n// Some runtime headers\n#include <sys/types.h>\n#include <stddef.h>\n#include <string.h>\n#include <limits.h>\n#include <stdint.h>\n\n// Our compile configuration\n#include \"defs.h\"\n\n// Some types moved to separate header due to size of operators\n#include \"vector3.h\"\n#include \"vector2.h\"\n#include \"color4.h\"\n#include \"matrix3x3.h\"\n#include \"matrix4x4.h\"\n#include \"quaternion.h\"\n\ntypedef int32_t ai_int32;\ntypedef uint32_t ai_uint32 ;\n\n#ifdef __cplusplus\n#include <cstring>\n#include <new>      // for std::nothrow_t\n#include <string>   // for aiString::Set(const std::string&)\n\n\nnamespace Assimp    {\n    //! @cond never\nnamespace Intern        {\n    // --------------------------------------------------------------------\n    /** @brief Internal helper class to utilize our internal new/delete\n     *    routines for allocating object of this and derived classes.\n     *\n     * By doing this you can safely share class objects between Assimp\n     * and the application - it works even over DLL boundaries. A good\n     * example is the #IOSystem where the application allocates its custom\n     * #IOSystem, then calls #Importer::SetIOSystem(). When the Importer\n     * destructs, Assimp calls operator delete on the stored #IOSystem.\n     * If it lies on a different heap than Assimp is working with,\n     * the application is determined to crash.\n     */\n    // --------------------------------------------------------------------\n#ifndef SWIG\n    struct ASSIMP_API AllocateFromAssimpHeap    {\n        // http://www.gotw.ca/publications/mill15.htm\n\n        // new/delete overload\n        void *operator new    ( size_t num_bytes) /* throw( std::bad_alloc ) */;\n        void *operator new    ( size_t num_bytes, const std::nothrow_t& ) throw();\n        void  operator delete ( void* data);\n\n        // array new/delete overload\n        void *operator new[]    ( size_t num_bytes) /* throw( std::bad_alloc ) */;\n        void *operator new[]    ( size_t num_bytes, const std::nothrow_t& )  throw();\n        void  operator delete[] ( void* data);\n\n    }; // struct AllocateFromAssimpHeap\n#endif\n} // namespace Intern\n    //! @endcond\n} // namespace Assimp\n\nextern \"C\" {\n#endif\n\n/** Maximum dimension for strings, ASSIMP strings are zero terminated. */\n#ifdef __cplusplus\n    static const size_t MAXLEN = 1024;\n#else\n#   define MAXLEN 1024\n#endif\n\n// ----------------------------------------------------------------------------------\n/** Represents a plane in a three-dimensional, euclidean space\n*/\nstruct aiPlane {\n#ifdef __cplusplus\n    aiPlane () AI_NO_EXCEPT : a(0.f), b(0.f), c(0.f), d(0.f) {}\n    aiPlane (ai_real _a, ai_real _b, ai_real _c, ai_real _d)\n        : a(_a), b(_b), c(_c), d(_d) {}\n\n    aiPlane (const aiPlane& o) : a(o.a), b(o.b), c(o.c), d(o.d) {}\n\n#endif // !__cplusplus\n\n    //! Plane equation\n    ai_real a,b,c,d;\n}; // !struct aiPlane\n\n// ----------------------------------------------------------------------------------\n/** Represents a ray\n*/\nstruct aiRay {\n#ifdef __cplusplus\n    aiRay () AI_NO_EXCEPT {}\n    aiRay (const aiVector3D& _pos, const aiVector3D& _dir)\n        : pos(_pos), dir(_dir) {}\n\n    aiRay (const aiRay& o) : pos (o.pos), dir (o.dir) {}\n\n#endif // !__cplusplus\n\n    //! Position and direction of the ray\n    C_STRUCT aiVector3D pos, dir;\n}; // !struct aiRay\n\n// ----------------------------------------------------------------------------------\n/** Represents a color in Red-Green-Blue space.\n*/\nstruct aiColor3D\n{\n#ifdef __cplusplus\n    aiColor3D () AI_NO_EXCEPT : r(0.0f), g(0.0f), b(0.0f) {}\n    aiColor3D (ai_real _r, ai_real _g, ai_real _b) : r(_r), g(_g), b(_b) {}\n    explicit aiColor3D (ai_real _r) : r(_r), g(_r), b(_r) {}\n    aiColor3D (const aiColor3D& o) : r(o.r), g(o.g), b(o.b) {}\n\n\taiColor3D &operator=(const aiColor3D &o) {\n\t\tr = o.r;\n\t\tg = o.g;\n\t\tb = o.b;\n\t\treturn *this;\n\t}\n\n\t/** Component-wise comparison */\n    // TODO: add epsilon?\n    bool operator == (const aiColor3D& other) const\n        {return r == other.r && g == other.g && b == other.b;}\n\n    /** Component-wise inverse comparison */\n    // TODO: add epsilon?\n    bool operator != (const aiColor3D& other) const\n        {return r != other.r || g != other.g || b != other.b;}\n\n    /** Component-wise comparison */\n    // TODO: add epsilon?\n    bool operator < (const aiColor3D& other) const {\n        return r < other.r || ( r == other.r && (g < other.g || (g == other.g && b < other.b ) ) );\n    }\n\n    /** Component-wise addition */\n    aiColor3D operator+(const aiColor3D& c) const {\n        return aiColor3D(r+c.r,g+c.g,b+c.b);\n    }\n\n    /** Component-wise subtraction */\n    aiColor3D operator-(const aiColor3D& c) const {\n        return aiColor3D(r-c.r,g-c.g,b-c.b);\n    }\n\n    /** Component-wise multiplication */\n    aiColor3D operator*(const aiColor3D& c) const {\n        return aiColor3D(r*c.r,g*c.g,b*c.b);\n    }\n\n    /** Multiply with a scalar */\n    aiColor3D operator*(ai_real f) const {\n        return aiColor3D(r*f,g*f,b*f);\n    }\n\n    /** Access a specific color component */\n    ai_real operator[](unsigned int i) const {\n        return *(&r + i);\n    }\n\n    /** Access a specific color component */\n    ai_real& operator[](unsigned int i) {\n        if ( 0 == i ) {\n            return r;\n        } else if ( 1 == i ) {\n            return g;\n        } else if ( 2 == i ) {\n            return b;\n        }\n        return r;\n    }\n\n    /** Check whether a color is black */\n    bool IsBlack() const {\n        static const ai_real epsilon = ai_real(10e-3);\n        return std::fabs( r ) < epsilon && std::fabs( g ) < epsilon && std::fabs( b ) < epsilon;\n    }\n\n#endif // !__cplusplus\n\n    //! Red, green and blue color values\n    ai_real r, g, b;\n};  // !struct aiColor3D\n\n// ----------------------------------------------------------------------------------\n/** Represents an UTF-8 string, zero byte terminated.\n *\n *  The character set of an aiString is explicitly defined to be UTF-8. This Unicode\n *  transformation was chosen in the belief that most strings in 3d files are limited\n *  to ASCII, thus the character set needed to be strictly ASCII compatible.\n *\n *  Most text file loaders provide proper Unicode input file handling, special unicode\n *  characters are correctly transcoded to UTF8 and are kept throughout the libraries'\n *  import pipeline.\n *\n *  For most applications, it will be absolutely sufficient to interpret the\n *  aiString as ASCII data and work with it as one would work with a plain char*.\n *  Windows users in need of proper support for i.e asian characters can use the\n *  MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the\n *  UTF-8 strings to their working character set (i.e. MBCS, WideChar).\n *\n *  We use this representation instead of std::string to be C-compatible. The\n *  (binary) length of such a string is limited to MAXLEN characters (including the\n *  the terminating zero).\n*/\nstruct aiString\n{\n#ifdef __cplusplus\n    /** Default constructor, the string is set to have zero length */\n    aiString() AI_NO_EXCEPT\n    : length( 0 ) {\n        data[0] = '\\0';\n\n#ifdef ASSIMP_BUILD_DEBUG\n        // Debug build: overwrite the string on its full length with ESC (27)\n        memset(data+1,27,MAXLEN-1);\n#endif\n    }\n\n    /** Copy constructor */\n    aiString(const aiString& rOther)\n    : length(rOther.length)\n    {\n        // Crop the string to the maximum length\n        length = length>=MAXLEN?MAXLEN-1:length;\n        memcpy( data, rOther.data, length);\n        data[length] = '\\0';\n    }\n\n    /** Constructor from std::string */\n    explicit aiString(const std::string& pString) :\n        length( (ai_uint32) pString.length())\n    {\n        length = length>=MAXLEN?MAXLEN-1:length;\n        memcpy( data, pString.c_str(), length);\n        data[length] = '\\0';\n    }\n\n    /** Copy a std::string to the aiString */\n    void Set( const std::string& pString) {\n        if( pString.length() > MAXLEN - 1) {\n            return;\n        }\n        length = (ai_uint32)pString.length();\n        memcpy( data, pString.c_str(), length);\n        data[length] = 0;\n    }\n\n    /** Copy a const char* to the aiString */\n    void Set( const char* sz) {\n        const ai_int32 len = (ai_uint32) ::strlen(sz);\n        if( len > (ai_int32)MAXLEN - 1) {\n            return;\n        }\n        length = len;\n        memcpy( data, sz, len);\n        data[len] = 0;\n    }\n\n\n    /** Assignment operator */\n    aiString& operator = (const aiString &rOther) {\n        if (this == &rOther) {\n            return *this;\n        }\n\n        length = rOther.length;;\n        memcpy( data, rOther.data, length);\n        data[length] = '\\0';\n        return *this;\n    }\n\n\n    /** Assign a const char* to the string */\n    aiString& operator = (const char* sz) {\n        Set(sz);\n        return *this;\n    }\n\n    /** Assign a cstd::string to the string */\n    aiString& operator = ( const std::string& pString) {\n        Set(pString);\n        return *this;\n    }\n\n    /** Comparison operator */\n    bool operator==(const aiString& other) const {\n        return  (length == other.length && 0 == memcmp(data,other.data,length));\n    }\n\n    /** Inverse comparison operator */\n    bool operator!=(const aiString& other) const {\n        return  (length != other.length || 0 != memcmp(data,other.data,length));\n    }\n\n    /** Append a string to the string */\n    void Append (const char* app)   {\n        const ai_uint32 len = (ai_uint32) ::strlen(app);\n        if (!len) {\n            return;\n        }\n        if (length + len >= MAXLEN) {\n            return;\n        }\n\n        memcpy(&data[length],app,len+1);\n        length += len;\n    }\n\n    /** Clear the string - reset its length to zero */\n    void Clear ()   {\n        length  = 0;\n        data[0] = '\\0';\n\n#ifdef ASSIMP_BUILD_DEBUG\n        // Debug build: overwrite the string on its full length with ESC (27)\n        memset(data+1,27,MAXLEN-1);\n#endif\n    }\n\n    /** Returns a pointer to the underlying zero-terminated array of characters */\n    const char* C_Str() const {\n        return data;\n    }\n\n#endif // !__cplusplus\n\n    /** Binary length of the string excluding the terminal 0. This is NOT the\n     *  logical length of strings containing UTF-8 multi-byte sequences! It's\n     *  the number of bytes from the beginning of the string to its end.*/\n    ai_uint32 length;\n\n    /** String buffer. Size limit is MAXLEN */\n    char data[MAXLEN];\n} ;  // !struct aiString\n\n\n// ----------------------------------------------------------------------------------\n/** Standard return type for some library functions.\n * Rarely used, and if, mostly in the C API.\n */\ntypedef enum aiReturn\n{\n    /** Indicates that a function was successful */\n    aiReturn_SUCCESS = 0x0,\n\n    /** Indicates that a function failed */\n    aiReturn_FAILURE = -0x1,\n\n    /** Indicates that not enough memory was available\n     * to perform the requested operation\n     */\n    aiReturn_OUTOFMEMORY = -0x3,\n\n    /** @cond never\n     *  Force 32-bit size enum\n     */\n    _AI_ENFORCE_ENUM_SIZE = 0x7fffffff\n\n    /// @endcond\n} aiReturn;  // !enum aiReturn\n\n// just for backwards compatibility, don't use these constants anymore\n#define AI_SUCCESS     aiReturn_SUCCESS\n#define AI_FAILURE     aiReturn_FAILURE\n#define AI_OUTOFMEMORY aiReturn_OUTOFMEMORY\n\n// ----------------------------------------------------------------------------------\n/** Seek origins (for the virtual file system API).\n *  Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.\n */\nenum aiOrigin\n{\n    /** Beginning of the file */\n    aiOrigin_SET = 0x0,\n\n    /** Current position of the file pointer */\n    aiOrigin_CUR = 0x1,\n\n    /** End of the file, offsets must be negative */\n    aiOrigin_END = 0x2,\n\n    /**  @cond never\n     *   Force 32-bit size enum\n     */\n    _AI_ORIGIN_ENFORCE_ENUM_SIZE = 0x7fffffff\n\n    /// @endcond\n}; // !enum aiOrigin\n\n// ----------------------------------------------------------------------------------\n/** @brief Enumerates predefined log streaming destinations.\n *  Logging to these streams can be enabled with a single call to\n *   #LogStream::createDefaultStream.\n */\nenum aiDefaultLogStream\n{\n    /** Stream the log to a file */\n    aiDefaultLogStream_FILE = 0x1,\n\n    /** Stream the log to std::cout */\n    aiDefaultLogStream_STDOUT = 0x2,\n\n    /** Stream the log to std::cerr */\n    aiDefaultLogStream_STDERR = 0x4,\n\n    /** MSVC only: Stream the log the the debugger\n     * (this relies on OutputDebugString from the Win32 SDK)\n     */\n    aiDefaultLogStream_DEBUGGER = 0x8,\n\n    /** @cond never\n     *  Force 32-bit size enum\n     */\n    _AI_DLS_ENFORCE_ENUM_SIZE = 0x7fffffff\n    /// @endcond\n}; // !enum aiDefaultLogStream\n\n// just for backwards compatibility, don't use these constants anymore\n#define DLS_FILE     aiDefaultLogStream_FILE\n#define DLS_STDOUT   aiDefaultLogStream_STDOUT\n#define DLS_STDERR   aiDefaultLogStream_STDERR\n#define DLS_DEBUGGER aiDefaultLogStream_DEBUGGER\n\n// ----------------------------------------------------------------------------------\n/** Stores the memory requirements for different components (e.g. meshes, materials,\n *  animations) of an import. All sizes are in bytes.\n *  @see Importer::GetMemoryRequirements()\n*/\nstruct aiMemoryInfo\n{\n#ifdef __cplusplus\n\n    /** Default constructor */\n    aiMemoryInfo() AI_NO_EXCEPT\n        : textures   (0)\n        , materials  (0)\n        , meshes     (0)\n        , nodes      (0)\n        , animations (0)\n        , cameras    (0)\n        , lights     (0)\n        , total      (0)\n    {}\n\n#endif\n\n    /** Storage allocated for texture data */\n    unsigned int textures;\n\n    /** Storage allocated for material data  */\n    unsigned int materials;\n\n    /** Storage allocated for mesh data */\n    unsigned int meshes;\n\n    /** Storage allocated for node data */\n    unsigned int nodes;\n\n    /** Storage allocated for animation data */\n    unsigned int animations;\n\n    /** Storage allocated for camera data */\n    unsigned int cameras;\n\n    /** Storage allocated for light data */\n    unsigned int lights;\n\n    /** Total storage allocated for the full import. */\n    unsigned int total;\n}; // !struct aiMemoryInfo\n\n#ifdef __cplusplus\n}\n#endif //!  __cplusplus\n\n// Include implementation files\n#include \"vector2.inl\"\n#include \"vector3.inl\"\n#include \"color4.inl\"\n#include \"quaternion.inl\"\n#include \"matrix3x3.inl\"\n#include \"matrix4x4.inl\"\n\n#endif // AI_TYPES_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/types.h b/include/assimp/types.h
--- a/include/assimp/types.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/types.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,6 +48,10 @@
 #ifndef AI_TYPES_H_INC
 #define AI_TYPES_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 // Some runtime headers
 #include <sys/types.h>
 #include <stddef.h>
@@ -56,15 +60,15 @@
 #include <stdint.h>
 
 // Our compile configuration
-#include "defs.h"
+#include <assimp/defs.h>
 
 // Some types moved to separate header due to size of operators
-#include "vector3.h"
-#include "vector2.h"
-#include "color4.h"
-#include "matrix3x3.h"
-#include "matrix4x4.h"
-#include "quaternion.h"
+#include <assimp/vector3.h>
+#include <assimp/vector2.h>
+#include <assimp/color4.h>
+#include <assimp/matrix3x3.h>
+#include <assimp/matrix4x4.h>
+#include <assimp/quaternion.h>
 
 typedef int32_t ai_int32;
 typedef uint32_t ai_uint32 ;
@@ -74,9 +78,8 @@
 #include <new>      // for std::nothrow_t
 #include <string>   // for aiString::Set(const std::string&)
 
-
 namespace Assimp    {
-    //! @cond never
+//! @cond never
 namespace Intern        {
     // --------------------------------------------------------------------
     /** @brief Internal helper class to utilize our internal new/delete
Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1617534508000)
+++ b/CMakeLists.txt	(date 1617534508000)
@@ -0,0 +1,32 @@
+# Set cmake minimum version.
+cmake_minimum_required(VERSION 3.15)
+set (CMAKE_CXX_STANDARD 14)
+# Set the project details.
+set(PROJECT_NAME TNAH-Project)
+project(${PROJECT_NAME} LANGUAGES CXX)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake-files")
+
+# Define the executable.
+add_executable(${PROJECT_NAME})
+
+#Find Packages
+FIND_PACKAGE(OpenGL REQUIRED)
+FIND_PACKAGE(glfw3 REQUIRED)
+#FIND_PACKAGE(GLM REQUIRED)
+find_package(Assimp REQUIRED)
+find_package(GLAD REQUIRED)
+
+
+
+
+# Define source files.
+add_subdirectory(ICT397-Project-Engine)
+
+include_directories(${PROJECT_SOURCE_DIR}/include)
+link_libraries(${PROJECT_NAME} ${ASSIMP_LIBRARIES})
+link_libraries(${PROJECT_NAME} ${GLAD_LIBRARIES})
+
+target_link_libraries(${PROJECT_NAME} glfw ${ASSIMP_LIBRARIES} ${GLAD_LIBRARIES})
+
+#target_link_libraries(${PROJECT_NAME} ${ASSIMP_LIBRARIES})
\ No newline at end of file
Index: include/assimp/Hash.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#ifndef AI_HASH_H_INCLUDED\n#define AI_HASH_H_INCLUDED\n\n#include <stdint.h>\n#include <string.h>\n\n// ------------------------------------------------------------------------------------------------\n// Hashing function taken from\n// http://www.azillionmonkeys.com/qed/hash.html\n// (incremental version)\n//\n// This code is Copyright 2004-2008 by Paul Hsieh. It is used here in the belief that\n// Assimp's license is considered compatible with Pauls's derivative license as specified\n// on his web page.\n//\n// (stdint.h should have been been included here)\n// ------------------------------------------------------------------------------------------------\n#undef get16bits\n#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \\\n  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)\n#define get16bits(d) (*((const uint16_t *) (d)))\n#endif\n\n#if !defined (get16bits)\n#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\\\n                       +(uint32_t)(((const uint8_t *)(d))[0]) )\n#endif\n\n// ------------------------------------------------------------------------------------------------\ninline uint32_t SuperFastHash (const char * data, uint32_t len = 0, uint32_t hash = 0) {\nuint32_t tmp;\nint rem;\n\n    if (!data) return 0;\n    if (!len)len = (uint32_t)::strlen(data);\n\n    rem = len & 3;\n    len >>= 2;\n\n    /* Main loop */\n    for (;len > 0; len--) {\n        hash  += get16bits (data);\n        tmp    = (get16bits (data+2) << 11) ^ hash;\n        hash   = (hash << 16) ^ tmp;\n        data  += 2*sizeof (uint16_t);\n        hash  += hash >> 11;\n    }\n\n    /* Handle end cases */\n    switch (rem) {\n        case 3: hash += get16bits (data);\n                hash ^= hash << 16;\n                hash ^= data[sizeof (uint16_t)] << 18;\n                hash += hash >> 11;\n                break;\n        case 2: hash += get16bits (data);\n                hash ^= hash << 11;\n                hash += hash >> 17;\n                break;\n        case 1: hash += *data;\n                hash ^= hash << 10;\n                hash += hash >> 1;\n    }\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n#endif // !! AI_HASH_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Hash.h b/include/assimp/Hash.h
--- a/include/assimp/Hash.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Hash.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -39,10 +39,14 @@
 
 ----------------------------------------------------------------------
 */
-
+#pragma once
 #ifndef AI_HASH_H_INCLUDED
 #define AI_HASH_H_INCLUDED
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <stdint.h>
 #include <string.h>
 
Index: include/assimp/DefaultIOSystem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Default implementation of IOSystem using the standard C file functions */\n#ifndef AI_DEFAULTIOSYSTEM_H_INC\n#define AI_DEFAULTIOSYSTEM_H_INC\n\n#include <assimp/IOSystem.hpp>\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------\n/** Default implementation of IOSystem using the standard C file functions */\nclass ASSIMP_API DefaultIOSystem : public IOSystem {\npublic:\n    // -------------------------------------------------------------------\n    /** Tests for the existence of a file at the given path. */\n    bool Exists( const char* pFile) const;\n\n    // -------------------------------------------------------------------\n    /** Returns the directory separator. */\n    char getOsSeparator() const;\n\n    // -------------------------------------------------------------------\n    /** Open a new file with a given path. */\n    IOStream* Open( const char* pFile, const char* pMode = \"rb\");\n\n    // -------------------------------------------------------------------\n    /** Closes the given file and releases all resources associated with it. */\n    void Close( IOStream* pFile);\n\n    // -------------------------------------------------------------------\n    /** Compare two paths */\n    bool ComparePaths (const char* one, const char* second) const;\n\n    /** @brief get the file name of a full filepath\n     * example: /tmp/archive.tar.gz -> archive.tar.gz\n     */\n    static std::string fileName( const std::string &path );\n\n    /** @brief get the complete base name of a full filepath\n     * example: /tmp/archive.tar.gz -> archive.tar\n     */\n    static std::string completeBaseName( const std::string &path);\n\n    /** @brief get the path of a full filepath\n     * example: /tmp/archive.tar.gz -> /tmp/\n     */\n    static std::string absolutePath( const std::string &path);\n};\n\n} //!ns Assimp\n\n#endif //AI_DEFAULTIOSYSTEM_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/DefaultIOSystem.h b/include/assimp/DefaultIOSystem.h
--- a/include/assimp/DefaultIOSystem.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/DefaultIOSystem.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -41,9 +41,14 @@
 */
 
 /** @file Default implementation of IOSystem using the standard C file functions */
+#pragma once
 #ifndef AI_DEFAULTIOSYSTEM_H_INC
 #define AI_DEFAULTIOSYSTEM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/IOSystem.hpp>
 
 namespace Assimp    {
Index: ICT397-Project-Engine/GladSkybox.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n#include \"Skybox.h\"\nclass GladSkybox : public Skybox\n{\npublic:\n\tGladSkybox() {};\n\t~GladSkybox() { Terminate(); }\n\tvirtual void Init(std::string right, std::string left, std::string top, std::string bottom, std::string front, std::string back, std::string vertexShader, std::string fragmentShader);\n\tvirtual unsigned int loadCubemap(std::vector<std::string> faces);\n\tvirtual void Terminate();\n\tvirtual unsigned int GetVAO() const { return skyboxVAO; }\n\tvirtual Shader GetShader() const { return skyShader; }\n\tvirtual unsigned int GetTexture() const { return cubeTexture; }\nprivate:\n\tunsigned int skyboxVAO = 0, skyboxVBO = 0;\n\tunsigned int cubeTexture = 0;\n\tstd::vector<std::string> cubeFaces = {};\n\n\tfloat skyBoxVertices[108] = {\n\t\t// positions\n\t\t-1.0f, 1.0f,  -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,  -1.0f, -1.0f,\n\t\t1.0f,  -1.0f, -1.0f, 1.0f,  1.0f,  -1.0f, -1.0f, 1.0f,  -1.0f,\n\n\t\t-1.0f, -1.0f, 1.0f,  -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,  -1.0f,\n\t\t-1.0f, 1.0f,  -1.0f, -1.0f, 1.0f,  1.0f,  -1.0f, -1.0f, 1.0f,\n\n\t\t1.0f,  -1.0f, -1.0f, 1.0f,  -1.0f, 1.0f,  1.0f,  1.0f,  1.0f,\n\t\t1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  -1.0f, 1.0f,  -1.0f, -1.0f,\n\n\t\t-1.0f, -1.0f, 1.0f,  -1.0f, 1.0f,  1.0f,  1.0f,  1.0f,  1.0f,\n\t\t1.0f,  1.0f,  1.0f,  1.0f,  -1.0f, 1.0f,  -1.0f, -1.0f, 1.0f,\n\n\t\t-1.0f, 1.0f,  -1.0f, 1.0f,  1.0f,  -1.0f, 1.0f,  1.0f,  1.0f,\n\t\t1.0f,  1.0f,  1.0f,  -1.0f, 1.0f,  1.0f,  -1.0f, 1.0f,  -1.0f,\n\n\t\t-1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,  1.0f,  -1.0f, -1.0f,\n\t\t1.0f,  -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,  1.0f,  -1.0f, 1.0f };\n};\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICT397-Project-Engine/GladSkybox.h b/ICT397-Project-Engine/GladSkybox.h
--- a/ICT397-Project-Engine/GladSkybox.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/ICT397-Project-Engine/GladSkybox.h	(date 1617529761000)
@@ -14,7 +14,7 @@
 private:
 	unsigned int skyboxVAO = 0, skyboxVBO = 0;
 	unsigned int cubeTexture = 0;
-	std::vector<std::string> cubeFaces = {};
+	std::vector<std::string> cubeFaces;
 
 	float skyBoxVertices[108] = {
 		// positions
Index: include/assimp/RemoveComments.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Declares a helper class, \"CommentRemover\", which can be\n *  used to remove comments (single and multi line) from a text file.\n */\n#ifndef AI_REMOVE_COMMENTS_H_INC\n#define AI_REMOVE_COMMENTS_H_INC\n\n\n#include <assimp/defs.h>\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------\n/** \\brief Helper class to remove single and multi line comments from a file\n *\n *  Some mesh formats like MD5 have comments that are quite similar\n *  to those in C or C++ so this code has been moved to a separate\n *  module.\n */\nclass ASSIMP_API CommentRemover\n{\n    // class cannot be instanced\n    CommentRemover() {}\n\npublic:\n\n    //! Remove single-line comments. The end of a line is\n    //! expected to be either NL or CR or NLCR.\n    //! \\param szComment The start sequence of the comment, e.g. \"//\"\n    //! \\param szBuffer Buffer to work with\n    //! \\param chReplacement Character to be used as replacement\n    //! for commented lines. By default this is ' '\n    static void RemoveLineComments(const char* szComment,\n        char* szBuffer, char chReplacement = ' ');\n\n    //! Remove multi-line comments. The end of a line is\n    //! expected to be either NL or CR or NLCR. Multi-line comments\n    //! may not be nested (as in C).\n    //! \\param szCommentStart The start sequence of the comment, e.g. \"/*\"\n    //! \\param szCommentEnd The end sequence of the comment, e.g. \"*/\"\n    //! \\param szBuffer Buffer to work with\n    //! \\param chReplacement Character to be used as replacement\n    //! for commented lines. By default this is ' '\n    static void RemoveMultiLineComments(const char* szCommentStart,\n        const char* szCommentEnd,char* szBuffer,\n        char chReplacement = ' ');\n};\n} // ! Assimp\n\n#endif // !! AI_REMOVE_COMMENTS_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/RemoveComments.h b/include/assimp/RemoveComments.h
--- a/include/assimp/RemoveComments.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/RemoveComments.h	(date 1617519895000)
@@ -2,8 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -43,9 +42,13 @@
 /** @file Declares a helper class, "CommentRemover", which can be
  *  used to remove comments (single and multi line) from a text file.
  */
+#pragma once
 #ifndef AI_REMOVE_COMMENTS_H_INC
 #define AI_REMOVE_COMMENTS_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
 
 #include <assimp/defs.h>
 
@@ -58,8 +61,7 @@
  *  to those in C or C++ so this code has been moved to a separate
  *  module.
  */
-class ASSIMP_API CommentRemover
-{
+class ASSIMP_API CommentRemover {
     // class cannot be instanced
     CommentRemover() {}
 
Index: include/assimp/StringUtils.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n#ifndef INCLUDED_AI_STRINGUTILS_H\n#define INCLUDED_AI_STRINGUTILS_H\n\n#include <assimp/defs.h>\n\n#include <sstream>\n#include <stdarg.h>\n#include <cstdlib>\n\n///\t@fn\t\tai_snprintf\n///\t@brief\tThe portable version of the function snprintf ( C99 standard ), which works on visual studio compilers 2013 and earlier.\n///\t@param\toutBuf\t\tThe buffer to write in\n///\t@param\tsize\t\tThe buffer size\n///\t@param\tformat\t\tThe format string\n///\t@param\tap\t\t\tThe additional arguments.\n///\t@return\tThe number of written characters if the buffer size was big enough. If an encoding error occurs, a negative number is returned.\n#if defined(_MSC_VER) && _MSC_VER < 1900\n\n    AI_FORCE_INLINE\n    int c99_ai_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap) {\n\t\tint count(-1);\n\t\tif (0 != size) {\n\t\t\tcount = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);\n\t\t}\n\t\tif (count == -1) {\n\t\t\tcount = _vscprintf(format, ap);\n\t\t}\n\n\t\treturn count;\n\t}\n\n    AI_FORCE_INLINE\n    int ai_snprintf(char *outBuf, size_t size, const char *format, ...) {\n\t\tint count;\n\t\tva_list ap;\n\n\t\tva_start(ap, format);\n\t\tcount = c99_ai_vsnprintf(outBuf, size, format, ap);\n\t\tva_end(ap);\n\n\t\treturn count;\n\t}\n\n#else\n#   define ai_snprintf snprintf\n#endif\n\n///\t@fn\t\tto_string\n///\t@brief\tThe portable version of to_string ( some gcc-versions on embedded devices are not supporting this).\n///\t@param\tvalue   The value to write into the std::string.\n///\t@return\tThe value as a std::string\ntemplate <typename T>\nAI_FORCE_INLINE\nstd::string to_string( T value ) {\n    std::ostringstream os;\n    os << value;\n\n    return os.str();\n}\n\n///\t@fn\t\tai_strtof\n///\t@brief\tThe portable version of strtof.\n///\t@param\tbegin   The first character of the string.\n/// @param  end     The last character\n///\t@return\tThe float value, 0.0f in cas of an error.\nAI_FORCE_INLINE\nfloat ai_strtof( const char *begin, const char *end ) {\n    if ( nullptr == begin ) {\n        return 0.0f;\n    }\n    float val( 0.0f );\n    if ( nullptr == end ) {\n        val = static_cast< float >( ::atof( begin ) );\n    } else {\n        std::string::size_type len( end - begin );\n        std::string token( begin, len );\n        val = static_cast< float >( ::atof( token.c_str() ) );\n    }\n\n    return val;\n}\n\n///\t@fn\t\tDecimalToHexa\n///\t@brief\tThe portable to convert a decimal value into a hexadecimal string.\n///\t@param\ttoConvert   Value to convert\n///\t@return\tThe hexadecimal string, is empty in case of an error.\ntemplate<class T>\nAI_FORCE_INLINE\nstd::string DecimalToHexa( T toConvert ) {\n    std::string result;\n    std::stringstream ss;\n    ss << std::hex << toConvert;\n    ss >> result;\n\n    for ( size_t i = 0; i < result.size(); ++i ) {\n        result[ i ] = toupper( result[ i ] );\n    }\n\n    return result;\n}\n\n#endif // INCLUDED_AI_STRINGUTILS_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/StringUtils.h b/include/assimp/StringUtils.h
--- a/include/assimp/StringUtils.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/StringUtils.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -39,9 +39,14 @@
 
 ----------------------------------------------------------------------
 */
+#pragma once
 #ifndef INCLUDED_AI_STRINGUTILS_H
 #define INCLUDED_AI_STRINGUTILS_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/defs.h>
 
 #include <sstream>
Index: include/assimp/vector3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n/** @file vector3.h\n *  @brief 3D vector structure, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_VECTOR3D_H_INC\n#define AI_VECTOR3D_H_INC\n\n#ifdef __cplusplus\n#   include <cmath>\n#else\n#   include <math.h>\n#endif\n\n#include \"defs.h\"\n\n#ifdef __cplusplus\n\ntemplate<typename TReal> class aiMatrix3x3t;\ntemplate<typename TReal> class aiMatrix4x4t;\n\n// ---------------------------------------------------------------------------\n/** Represents a three-dimensional vector. */\ntemplate <typename TReal>\nclass aiVector3t\n{\npublic:\n    aiVector3t() AI_NO_EXCEPT : x(), y(), z() {}\n    aiVector3t(TReal _x, TReal _y, TReal _z) : x(_x), y(_y), z(_z) {}\n    explicit aiVector3t (TReal _xyz ) : x(_xyz), y(_xyz), z(_xyz) {}\n    aiVector3t( const aiVector3t& o ) = default;\n\npublic:\n\n    // combined operators\n    const aiVector3t& operator += (const aiVector3t& o);\n    const aiVector3t& operator -= (const aiVector3t& o);\n    const aiVector3t& operator *= (TReal f);\n    const aiVector3t& operator /= (TReal f);\n\n    // transform vector by matrix\n    aiVector3t& operator *= (const aiMatrix3x3t<TReal>& mat);\n    aiVector3t& operator *= (const aiMatrix4x4t<TReal>& mat);\n\n    // access a single element\n    TReal operator[](unsigned int i) const;\n    TReal& operator[](unsigned int i);\n\n    // comparison\n    bool operator== (const aiVector3t& other) const;\n    bool operator!= (const aiVector3t& other) const;\n    bool operator < (const aiVector3t& other) const;\n\n    bool Equal(const aiVector3t& other, TReal epsilon = 1e-6) const;\n\n    template <typename TOther>\n    operator aiVector3t<TOther> () const;\n\npublic:\n    /** @brief Set the components of a vector\n     *  @param pX X component\n     *  @param pY Y component\n     *  @param pZ Z component  */\n    void Set( TReal pX, TReal pY, TReal pZ);\n\n    /** @brief Get the squared length of the vector\n     *  @return Square length */\n    TReal SquareLength() const;\n\n    /** @brief Get the length of the vector\n     *  @return length */\n    TReal Length() const;\n\n\n    /** @brief Normalize the vector */\n    aiVector3t& Normalize();\n\n    /** @brief Normalize the vector with extra check for zero vectors */\n    aiVector3t& NormalizeSafe();\n\n    /** @brief Componentwise multiplication of two vectors\n     *\n     *  Note that vec*vec yields the dot product.\n     *  @param o Second factor */\n    const aiVector3t SymMul(const aiVector3t& o);\n\n    TReal x, y, z;\n};\n\n\ntypedef aiVector3t<ai_real> aiVector3D;\n\n#else\n\nstruct aiVector3D {\n    ai_real x, y, z;\n};\n\n#endif // __cplusplus\n\n#ifdef __cplusplus\n\n#endif // __cplusplus\n\n#endif // AI_VECTOR3D_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/vector3.h b/include/assimp/vector3.h
--- a/include/assimp/vector3.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/vector3.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -47,13 +47,17 @@
 #ifndef AI_VECTOR3D_H_INC
 #define AI_VECTOR3D_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
 #   include <cmath>
 #else
 #   include <math.h>
 #endif
 
-#include "defs.h"
+#include <assimp/defs.h>
 
 #ifdef __cplusplus
 
@@ -63,16 +67,13 @@
 // ---------------------------------------------------------------------------
 /** Represents a three-dimensional vector. */
 template <typename TReal>
-class aiVector3t
-{
+class aiVector3t {
 public:
     aiVector3t() AI_NO_EXCEPT : x(), y(), z() {}
     aiVector3t(TReal _x, TReal _y, TReal _z) : x(_x), y(_y), z(_z) {}
     explicit aiVector3t (TReal _xyz ) : x(_xyz), y(_xyz), z(_xyz) {}
     aiVector3t( const aiVector3t& o ) = default;
 
-public:
-
     // combined operators
     const aiVector3t& operator += (const aiVector3t& o);
     const aiVector3t& operator -= (const aiVector3t& o);
@@ -97,7 +98,6 @@
     template <typename TOther>
     operator aiVector3t<TOther> () const;
 
-public:
     /** @brief Set the components of a vector
      *  @param pX X component
      *  @param pY Y component
Index: cmake-files/FindGLAD.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-files/FindGLAD.cmake b/cmake-files/FindGLAD.cmake
new file mode 100644
--- /dev/null	(date 1617533572000)
+++ b/cmake-files/FindGLAD.cmake	(date 1617533572000)
@@ -0,0 +1,18 @@
+find_path(GLAD_INCLUDE_PATH
+        NAMES glad/glad.h
+        PATHS /usr/local/Cellar/glad
+        PATH_SUFFIXES include)
+
+find_library(GLAD_LIBRARIES
+        NAMES libglad.a glad.lib
+        PATHS /usr/local/Cellar/glad
+        PATH_SUFFIXES lib)
+
+
+set(GLAD_FOUND "NO")
+if (GLAD_INCLUDE_PATH AND GLAD_LIBRARIES)
+    set(GLAD_FOUND "YES")
+    message("EXTERNAL LIBRARY 'GLAD' FOUND")
+else ()
+    message("ERROR: EXTERNAL LIBRARY 'GLAD' NOT FOUND")
+endif (GLAD_INCLUDE_PATH AND GLAD_LIBRARIES)
\ No newline at end of file
Index: include/assimp/aabb.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n#pragma once\n#ifndef AI_AABB_H_INC\n#define AI_AABB_H_INC\n\n#include <assimp/vector3.h>\n\nstruct aiAABB {\n    C_STRUCT aiVector3D mMin;\n    C_STRUCT aiVector3D mMax;\n\n#ifdef __cplusplus\n\n    aiAABB()\n    : mMin()\n    , mMax() {\n        // empty\n    }\n\n    aiAABB(const aiVector3D &min, const aiVector3D &max )\n    : mMin(min)\n    , mMax(max) {\n        // empty\n    }\n\n    ~aiAABB() {\n        // empty\n    }\n\n#endif \n};\n\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/aabb.h b/include/assimp/aabb.h
--- a/include/assimp/aabb.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/aabb.h	(date 1617519895000)
@@ -3,9 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -45,6 +43,10 @@
 #ifndef AI_AABB_H_INC
 #define AI_AABB_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/vector3.h>
 
 struct aiAABB {
@@ -69,8 +71,9 @@
         // empty
     }
 
-#endif 
+#endif // __cplusplus
+
 };
 
 
-#endif
+#endif // AI_AABB_H_INC
Index: include/assimp/SpatialSort.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** Small helper classes to optimise finding vertizes close to a given location */\n#ifndef AI_SPATIALSORT_H_INC\n#define AI_SPATIALSORT_H_INC\n\n#include <vector>\n#include <assimp/types.h>\n\nnamespace Assimp {\n\n// ------------------------------------------------------------------------------------------------\n/** A little helper class to quickly find all vertices in the epsilon environment of a given\n * position. Construct an instance with an array of positions. The class stores the given positions\n * by their indices and sorts them by their distance to an arbitrary chosen plane.\n * You can then query the instance for all vertices close to a given position in an average O(log n)\n * time, with O(n) worst case complexity when all vertices lay on the plane. The plane is chosen\n * so that it avoids common planes in usual data sets. */\n// ------------------------------------------------------------------------------------------------\nclass ASSIMP_API SpatialSort\n{\npublic:\n\n    SpatialSort();\n\n    // ------------------------------------------------------------------------------------\n    /** Constructs a spatially sorted representation from the given position array.\n     * Supply the positions in its layout in memory, the class will only refer to them\n     * by index.\n     * @param pPositions Pointer to the first position vector of the array.\n     * @param pNumPositions Number of vectors to expect in that array.\n     * @param pElementOffset Offset in bytes from the beginning of one vector in memory\n     *   to the beginning of the next vector. */\n    SpatialSort( const aiVector3D* pPositions, unsigned int pNumPositions,\n        unsigned int pElementOffset);\n\n    /** Destructor */\n    ~SpatialSort();\n\npublic:\n\n    // ------------------------------------------------------------------------------------\n    /** Sets the input data for the SpatialSort. This replaces existing data, if any.\n     *  The new data receives new indices in ascending order.\n     *\n     * @param pPositions Pointer to the first position vector of the array.\n     * @param pNumPositions Number of vectors to expect in that array.\n     * @param pElementOffset Offset in bytes from the beginning of one vector in memory\n     *   to the beginning of the next vector.\n     * @param pFinalize Specifies whether the SpatialSort's internal representation\n     *   is finalized after the new data has been added. Finalization is\n     *   required in order to use #FindPosition() or #GenerateMappingTable().\n     *   If you don't finalize yet, you can use #Append() to add data from\n     *   other sources.*/\n    void Fill( const aiVector3D* pPositions, unsigned int pNumPositions,\n        unsigned int pElementOffset,\n        bool pFinalize = true);\n\n\n    // ------------------------------------------------------------------------------------\n    /** Same as #Fill(), except the method appends to existing data in the #SpatialSort. */\n    void Append( const aiVector3D* pPositions, unsigned int pNumPositions,\n        unsigned int pElementOffset,\n        bool pFinalize = true);\n\n\n    // ------------------------------------------------------------------------------------\n    /** Finalize the spatial hash data structure. This can be useful after\n     *  multiple calls to #Append() with the pFinalize parameter set to false.\n     *  This is finally required before one of #FindPositions() and #GenerateMappingTable()\n     *  can be called to query the spatial sort.*/\n    void Finalize();\n\n    // ------------------------------------------------------------------------------------\n    /** Returns an iterator for all positions close to the given position.\n     * @param pPosition The position to look for vertices.\n     * @param pRadius Maximal distance from the position a vertex may have to be counted in.\n     * @param poResults The container to store the indices of the found positions.\n     *   Will be emptied by the call so it may contain anything.\n     * @return An iterator to iterate over all vertices in the given area.*/\n    void FindPositions( const aiVector3D& pPosition, ai_real pRadius,\n        std::vector<unsigned int>& poResults) const;\n\n    // ------------------------------------------------------------------------------------\n    /** Fills an array with indices of all positions identical to the given position. In\n     *  opposite to FindPositions(), not an epsilon is used but a (very low) tolerance of\n     *  four floating-point units.\n     * @param pPosition The position to look for vertices.\n     * @param poResults The container to store the indices of the found positions.\n     *   Will be emptied by the call so it may contain anything.*/\n    void FindIdenticalPositions( const aiVector3D& pPosition,\n        std::vector<unsigned int>& poResults) const;\n\n    // ------------------------------------------------------------------------------------\n    /** Compute a table that maps each vertex ID referring to a spatially close\n     *  enough position to the same output ID. Output IDs are assigned in ascending order\n     *  from 0...n.\n     * @param fill Will be filled with numPositions entries.\n     * @param pRadius Maximal distance from the position a vertex may have to\n     *   be counted in.\n     *  @return Number of unique vertices (n).  */\n    unsigned int GenerateMappingTable(std::vector<unsigned int>& fill,\n        ai_real pRadius) const;\n\nprotected:\n    /** Normal of the sorting plane, normalized. The center is always at (0, 0, 0) */\n    aiVector3D mPlaneNormal;\n\n    /** An entry in a spatially sorted position array. Consists of a vertex index,\n     * its position and its pre-calculated distance from the reference plane */\n    struct Entry {\n        unsigned int mIndex; ///< The vertex referred by this entry\n        aiVector3D mPosition; ///< Position\n        ai_real mDistance; ///< Distance of this vertex to the sorting plane\n\n        Entry() AI_NO_EXCEPT\n        : mIndex( 999999999 ), mPosition(), mDistance( 99999. ) {\n            // empty        \n        }\n        Entry( unsigned int pIndex, const aiVector3D& pPosition, ai_real pDistance)\n        : mIndex( pIndex), mPosition( pPosition), mDistance( pDistance) {\n            // empty\n        }\n\n        bool operator < (const Entry& e) const { return mDistance < e.mDistance; }\n    };\n\n    // all positions, sorted by distance to the sorting plane\n    std::vector<Entry> mPositions;\n};\n\n} // end of namespace Assimp\n\n#endif // AI_SPATIALSORT_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SpatialSort.h b/include/assimp/SpatialSort.h
--- a/include/assimp/SpatialSort.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SpatialSort.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -41,9 +41,14 @@
 */
 
 /** Small helper classes to optimise finding vertizes close to a given location */
+#pragma once
 #ifndef AI_SPATIALSORT_H_INC
 #define AI_SPATIALSORT_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <vector>
 #include <assimp/types.h>
 
Index: include/assimp/material.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file material.h\n *  @brief Defines the material system of the library\n */\n#pragma once\n#ifndef AI_MATERIAL_H_INC\n#define AI_MATERIAL_H_INC\n\n#include \"types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Name for default materials (2nd is used if meshes have UV coords)\n#define AI_DEFAULT_MATERIAL_NAME          \"DefaultMaterial\"\n\n// ---------------------------------------------------------------------------\n/** @brief Defines how the Nth texture of a specific type is combined with\n *  the result of all previous layers.\n *\n *  Example (left: key, right: value): <br>\n *  @code\n *  DiffColor0     - gray\n *  DiffTextureOp0 - aiTextureOpMultiply\n *  DiffTexture0   - tex1.png\n *  DiffTextureOp0 - aiTextureOpAdd\n *  DiffTexture1   - tex2.png\n *  @endcode\n *  Written as equation, the final diffuse term for a specific pixel would be:\n *  @code\n *  diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +\n *     sampleTex(DiffTexture1,UV0) * diffContrib;\n *  @endcode\n *  where 'diffContrib' is the intensity of the incoming light for that pixel.\n */\nenum aiTextureOp\n{\n    /** T = T1 * T2 */\n    aiTextureOp_Multiply = 0x0,\n\n    /** T = T1 + T2 */\n    aiTextureOp_Add = 0x1,\n\n    /** T = T1 - T2 */\n    aiTextureOp_Subtract = 0x2,\n\n    /** T = T1 / T2 */\n    aiTextureOp_Divide = 0x3,\n\n    /** T = (T1 + T2) - (T1 * T2) */\n    aiTextureOp_SmoothAdd = 0x4,\n\n    /** T = T1 + (T2-0.5) */\n    aiTextureOp_SignedAdd = 0x5,\n\n\n#ifndef SWIG\n    _aiTextureOp_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Defines how UV coordinates outside the [0...1] range are handled.\n *\n *  Commonly referred to as 'wrapping mode'.\n */\nenum aiTextureMapMode\n{\n    /** A texture coordinate u|v is translated to u%1|v%1\n     */\n    aiTextureMapMode_Wrap = 0x0,\n\n    /** Texture coordinates outside [0...1]\n     *  are clamped to the nearest valid value.\n     */\n    aiTextureMapMode_Clamp = 0x1,\n\n    /** If the texture coordinates for a pixel are outside [0...1]\n     *  the texture is not applied to that pixel\n     */\n    aiTextureMapMode_Decal = 0x3,\n\n    /** A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and\n     *  1-(u%1)|1-(v%1) otherwise\n     */\n    aiTextureMapMode_Mirror = 0x2,\n\n#ifndef SWIG\n    _aiTextureMapMode_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Defines how the mapping coords for a texture are generated.\n *\n *  Real-time applications typically require full UV coordinates, so the use of\n *  the aiProcess_GenUVCoords step is highly recommended. It generates proper\n *  UV channels for non-UV mapped objects, as long as an accurate description\n *  how the mapping should look like (e.g spherical) is given.\n *  See the #AI_MATKEY_MAPPING property for more details.\n */\nenum aiTextureMapping\n{\n    /** The mapping coordinates are taken from an UV channel.\n     *\n     *  The #AI_MATKEY_UVWSRC key specifies from which UV channel\n     *  the texture coordinates are to be taken from (remember,\n     *  meshes can have more than one UV channel).\n    */\n    aiTextureMapping_UV = 0x0,\n\n     /** Spherical mapping */\n    aiTextureMapping_SPHERE = 0x1,\n\n     /** Cylindrical mapping */\n    aiTextureMapping_CYLINDER = 0x2,\n\n     /** Cubic mapping */\n    aiTextureMapping_BOX = 0x3,\n\n     /** Planar mapping */\n    aiTextureMapping_PLANE = 0x4,\n\n     /** Undefined mapping. Have fun. */\n    aiTextureMapping_OTHER = 0x5,\n\n\n#ifndef SWIG\n    _aiTextureMapping_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Defines the purpose of a texture\n *\n *  This is a very difficult topic. Different 3D packages support different\n *  kinds of textures. For very common texture types, such as bumpmaps, the\n *  rendering results depend on implementation details in the rendering\n *  pipelines of these applications. Assimp loads all texture references from\n *  the model file and tries to determine which of the predefined texture\n *  types below is the best choice to match the original use of the texture\n *  as closely as possible.<br>\n *\n *  In content pipelines you'll usually define how textures have to be handled,\n *  and the artists working on models have to conform to this specification,\n *  regardless which 3D tool they're using.\n */\nenum aiTextureType\n{\n    /** Dummy value.\n     *\n     *  No texture, but the value to be used as 'texture semantic'\n     *  (#aiMaterialProperty::mSemantic) for all material properties\n     *  *not* related to textures.\n     */\n    aiTextureType_NONE = 0,\n\n    /** LEGACY API MATERIALS \n     * Legacy refers to materials which \n     * Were originally implemented in the specifications around 2000.\n     * These must never be removed, as most engines support them.\n     */\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n    aiTextureType_DIFFUSE = 1,\n\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    aiTextureType_SPECULAR = 2,\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    aiTextureType_AMBIENT = 3,\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    aiTextureType_EMISSIVE = 4,\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    aiTextureType_HEIGHT = 5,\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n    aiTextureType_NORMALS = 6,\n\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n    */\n    aiTextureType_SHININESS = 7,\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n    */\n    aiTextureType_OPACITY = 8,\n\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n    */\n    aiTextureType_DISPLACEMENT = 9,\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n    */\n    aiTextureType_LIGHTMAP = 10,\n\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n    */\n    aiTextureType_REFLECTION = 11,\n\n    /** PBR Materials\n     * PBR definitions from maya and other modelling packages now use this standard.\n     * This was originally introduced around 2012.\n     * Support for this is in game engines like Godot, Unreal or Unity3D.\n     * Modelling packages which use this are very common now.\n     */\n\n    aiTextureType_BASE_COLOR = 12,\n    aiTextureType_NORMAL_CAMERA = 13,\n    aiTextureType_EMISSION_COLOR = 14,\n    aiTextureType_METALNESS = 15,\n    aiTextureType_DIFFUSE_ROUGHNESS = 16,\n    aiTextureType_AMBIENT_OCCLUSION = 17,\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further post-processing.\n    */\n    aiTextureType_UNKNOWN = 18,\n\n\n#ifndef SWIG\n    _aiTextureType_Force32Bit = INT_MAX\n#endif\n};\n\n#define AI_TEXTURE_TYPE_MAX  aiTextureType_UNKNOWN\n\n// ---------------------------------------------------------------------------\n/** @brief Defines all shading models supported by the library\n *\n *  The list of shading modes has been taken from Blender.\n *  See Blender documentation for more information. The API does\n *  not distinguish between \"specular\" and \"diffuse\" shaders (thus the\n *  specular term for diffuse shading models like Oren-Nayar remains\n *  undefined). <br>\n *  Again, this value is just a hint. Assimp tries to select the shader whose\n *  most common implementation matches the original rendering results of the\n *  3D modeller which wrote a particular model as closely as possible.\n */\nenum aiShadingMode\n{\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    aiShadingMode_Flat = 0x1,\n\n    /** Simple Gouraud shading.\n     */\n    aiShadingMode_Gouraud = 0x2,\n\n    /** Phong-Shading -\n     */\n    aiShadingMode_Phong = 0x3,\n\n    /** Phong-Blinn-Shading\n     */\n    aiShadingMode_Blinn = 0x4,\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    aiShadingMode_Toon = 0x5,\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    aiShadingMode_OrenNayar = 0x6,\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    aiShadingMode_Minnaert = 0x7,\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    aiShadingMode_CookTorrance = 0x8,\n\n    /** No shading at all. Constant light influence of 1.0.\n    */\n    aiShadingMode_NoShading = 0x9,\n\n     /** Fresnel shading\n     */\n    aiShadingMode_Fresnel = 0xa,\n\n\n#ifndef SWIG\n    _aiShadingMode_Force32Bit = INT_MAX\n#endif\n};\n\n\n// ---------------------------------------------------------------------------\n/** @brief Defines some mixed flags for a particular texture.\n *\n *  Usually you'll instruct your cg artists how textures have to look like ...\n *  and how they will be processed in your application. However, if you use\n *  Assimp for completely generic loading purposes you might also need to\n *  process these flags in order to display as many 'unknown' 3D models as\n *  possible correctly.\n *\n *  This corresponds to the #AI_MATKEY_TEXFLAGS property.\n*/\nenum aiTextureFlags\n{\n    /** The texture's color values have to be inverted (component-wise 1-n)\n     */\n    aiTextureFlags_Invert = 0x1,\n\n    /** Explicit request to the application to process the alpha channel\n     *  of the texture.\n     *\n     *  Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These\n     *  flags are set if the library can say for sure that the alpha\n     *  channel is used/is not used. If the model format does not\n     *  define this, it is left to the application to decide whether\n     *  the texture alpha channel - if any - is evaluated or not.\n     */\n    aiTextureFlags_UseAlpha = 0x2,\n\n    /** Explicit request to the application to ignore the alpha channel\n     *  of the texture.\n     *\n     *  Mutually exclusive with #aiTextureFlags_UseAlpha.\n     */\n    aiTextureFlags_IgnoreAlpha = 0x4,\n\n#ifndef SWIG\n      _aiTextureFlags_Force32Bit = INT_MAX\n#endif\n};\n\n\n// ---------------------------------------------------------------------------\n/** @brief Defines alpha-blend flags.\n *\n *  If you're familiar with OpenGL or D3D, these flags aren't new to you.\n *  They define *how* the final color value of a pixel is computed, basing\n *  on the previous color at that pixel and the new color value from the\n *  material.\n *  The blend formula is:\n *  @code\n *    SourceColor * SourceBlend + DestColor * DestBlend\n *  @endcode\n *  where DestColor is the previous color in the framebuffer at this\n *  position and SourceColor is the material color before the transparency\n *  calculation.<br>\n *  This corresponds to the #AI_MATKEY_BLEND_FUNC property.\n*/\nenum aiBlendMode\n{\n    /**\n     *  Formula:\n     *  @code\n     *  SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)\n     *  @endcode\n     */\n    aiBlendMode_Default = 0x0,\n\n    /** Additive blending\n     *\n     *  Formula:\n     *  @code\n     *  SourceColor*1 + DestColor*1\n     *  @endcode\n     */\n    aiBlendMode_Additive = 0x1,\n\n    // we don't need more for the moment, but we might need them\n    // in future versions ...\n\n#ifndef SWIG\n    _aiBlendMode_Force32Bit = INT_MAX\n#endif\n};\n\n\n#include \"./Compiler/pushpack1.h\"\n\n// ---------------------------------------------------------------------------\n/** @brief Defines how an UV channel is transformed.\n *\n *  This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.\n *  See its documentation for more details.\n *\n *  Typically you'll want to build a matrix of this information. However,\n *  we keep separate scaling/translation/rotation values to make it\n *  easier to process and optimize UV transformations internally.\n */\nstruct aiUVTransform\n{\n    /** Translation on the u and v axes.\n     *\n     *  The default value is (0|0).\n     */\n    C_STRUCT aiVector2D mTranslation;\n\n    /** Scaling on the u and v axes.\n     *\n     *  The default value is (1|1).\n     */\n    C_STRUCT aiVector2D mScaling;\n\n    /** Rotation - in counter-clockwise direction.\n     *\n     *  The rotation angle is specified in radians. The\n     *  rotation center is 0.5f|0.5f. The default value\n     *  0.f.\n     */\n    ai_real mRotation;\n\n\n#ifdef __cplusplus\n    aiUVTransform() AI_NO_EXCEPT\n        :   mTranslation (0.0,0.0)\n        ,   mScaling    (1.0,1.0)\n        ,   mRotation   (0.0)\n    {\n        // nothing to be done here ...\n    }\n#endif\n\n};\n\n#include \"./Compiler/poppack1.h\"\n\n//! @cond AI_DOX_INCLUDE_INTERNAL\n// ---------------------------------------------------------------------------\n/** @brief A very primitive RTTI system for the contents of material\n *  properties.\n */\nenum aiPropertyTypeInfo\n{\n    /** Array of single-precision (32 Bit) floats\n     *\n     *  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API\n     *  aiMaterial::Get()) to query properties stored in floating-point format.\n     *  The material system performs the type conversion automatically.\n    */\n    aiPTI_Float   = 0x1,\n\n    /** Array of double-precision (64 Bit) floats\n     *\n     *  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API\n     *  aiMaterial::Get()) to query properties stored in floating-point format.\n     *  The material system performs the type conversion automatically.\n    */\n    aiPTI_Double   = 0x2,\n\n    /** The material property is an aiString.\n     *\n     *  Arrays of strings aren't possible, aiGetMaterialString() (or the\n     *  C++-API aiMaterial::Get()) *must* be used to query a string property.\n    */\n    aiPTI_String  = 0x3,\n\n    /** Array of (32 Bit) integers\n     *\n     *  It is possible to use aiGetMaterialFloat[Array]() (or the C++-API\n     *  aiMaterial::Get()) to query properties stored in integer format.\n     *  The material system performs the type conversion automatically.\n    */\n    aiPTI_Integer = 0x4,\n\n\n    /** Simple binary buffer, content undefined. Not convertible to anything.\n    */\n    aiPTI_Buffer  = 0x5,\n\n\n     /** This value is not used. It is just there to force the\n     *  compiler to map this enum to a 32 Bit integer.\n     */\n#ifndef SWIG\n     _aiPTI_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Data structure for a single material property\n *\n *  As an user, you'll probably never need to deal with this data structure.\n *  Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family\n *  of functions to query material properties easily. Processing them\n *  manually is faster, but it is not the recommended way. It isn't worth\n *  the effort. <br>\n *  Material property names follow a simple scheme:\n *  @code\n *    $<name>\n *    ?<name>\n *       A public property, there must be corresponding AI_MATKEY_XXX define\n *       2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials\n *       post-processing step.\n *    ~<name>\n *       A temporary property for internal use.\n *  @endcode\n *  @see aiMaterial\n */\nstruct aiMaterialProperty\n{\n    /** Specifies the name of the property (key)\n     *  Keys are generally case insensitive.\n     */\n    C_STRUCT aiString mKey;\n\n    /** Textures: Specifies their exact usage semantic.\n     * For non-texture properties, this member is always 0\n     * (or, better-said, #aiTextureType_NONE).\n     */\n    unsigned int mSemantic;\n\n    /** Textures: Specifies the index of the texture.\n     *  For non-texture properties, this member is always 0.\n     */\n    unsigned int mIndex;\n\n    /** Size of the buffer mData is pointing to, in bytes.\n     *  This value may not be 0.\n     */\n    unsigned int mDataLength;\n\n    /** Type information for the property.\n     *\n     * Defines the data layout inside the data buffer. This is used\n     * by the library internally to perform debug checks and to\n     * utilize proper type conversions.\n     * (It's probably a hacky solution, but it works.)\n     */\n    C_ENUM aiPropertyTypeInfo mType;\n\n    /** Binary buffer to hold the property's value.\n     * The size of the buffer is always mDataLength.\n     */\n    char* mData;\n\n#ifdef __cplusplus\n\n    aiMaterialProperty() AI_NO_EXCEPT\n    : mSemantic( 0 )\n    , mIndex( 0 )\n    , mDataLength( 0 )\n    , mType( aiPTI_Float )\n    , mData(nullptr) {\n        // empty\n    }\n\n    ~aiMaterialProperty()   {\n        delete[] mData;\n        mData = nullptr;\n    }\n\n#endif\n};\n//! @endcond\n\n#ifdef __cplusplus\n} // We need to leave the \"C\" block here to allow template member functions\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief Data structure for a material\n*\n*  Material data is stored using a key-value structure. A single key-value\n*  pair is called a 'material property'. C++ users should use the provided\n*  member functions of aiMaterial to process material properties, C users\n*  have to stick with the aiMaterialGetXXX family of unbound functions.\n*  The library defines a set of standard keys (AI_MATKEY_XXX).\n*/\n#ifdef __cplusplus\nstruct ASSIMP_API aiMaterial\n#else\nstruct aiMaterial\n#endif\n{\n\n#ifdef __cplusplus\n\npublic:\n\n    aiMaterial();\n    ~aiMaterial();\n\n    // -------------------------------------------------------------------\n    /**\n      * @brief  Returns the name of the material.\n      * @return The name of the material.\n      */\n    // -------------------------------------------------------------------\n    aiString GetName();\n\n    // -------------------------------------------------------------------\n    /** @brief Retrieve an array of Type values with a specific key\n     *  from the material\n     *\n     * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n     * @param type .. set by AI_MATKEY_XXX\n     * @param idx .. set by AI_MATKEY_XXX\n     * @param pOut Pointer to a buffer to receive the result.\n     * @param pMax Specifies the size of the given buffer, in Type's.\n     * Receives the number of values (not bytes!) read.\n     * NULL is a valid value for this parameter.\n     */\n    template <typename Type>\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, Type* pOut, unsigned int* pMax) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, int* pOut, unsigned int* pMax) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, ai_real* pOut, unsigned int* pMax) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Retrieve a Type value with a specific key\n     *  from the material\n     *\n     * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n    * @param type Specifies the type of the texture to be retrieved (\n    *    e.g. diffuse, specular, height map ...)\n    * @param idx Index of the texture to be retrieved.\n     * @param pOut Reference to receive the output value\n     */\n    template <typename Type>\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx,Type& pOut) const;\n\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, int& pOut) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, ai_real& pOut) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, aiString& pOut) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, aiColor3D& pOut) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, aiColor4D& pOut) const;\n\n    aiReturn Get(const char* pKey,unsigned int type,\n        unsigned int idx, aiUVTransform& pOut) const;\n\n    // -------------------------------------------------------------------\n    /** Get the number of textures for a particular texture type.\n     *  @param type Texture type to check for\n     *  @return Number of textures for this type.\n     *  @note A texture can be easily queried using #GetTexture() */\n    unsigned int GetTextureCount(aiTextureType type) const;\n\n    // -------------------------------------------------------------------\n    /** Helper function to get all parameters pertaining to a\n     *  particular texture slot from a material.\n     *\n     *  This function is provided just for convenience, you could also\n     *  read the single material properties manually.\n     *  @param type Specifies the type of the texture to be retrieved (\n     *    e.g. diffuse, specular, height map ...)\n     *  @param index Index of the texture to be retrieved. The function fails\n     *    if there is no texture of that type with this index.\n     *    #GetTextureCount() can be used to determine the number of textures\n     *    per texture type.\n     *  @param path Receives the path to the texture.\n     *    If the texture is embedded, receives a '*' followed by the id of\n     *    the texture (for the textures stored in the corresponding scene) which\n     *    can be converted to an int using a function like atoi.\n     *    NULL is a valid value.\n     *  @param mapping The texture mapping.\n     *    NULL is allowed as value.\n     *  @param uvindex Receives the UV index of the texture.\n     *    NULL is a valid value.\n     *  @param blend Receives the blend factor for the texture\n     *    NULL is a valid value.\n     *  @param op Receives the texture operation to be performed between\n     *    this texture and the previous texture. NULL is allowed as value.\n     *  @param mapmode Receives the mapping modes to be used for the texture.\n     *    The parameter may be NULL but if it is a valid pointer it MUST\n     *    point to an array of 3 aiTextureMapMode's (one for each\n     *    axis: UVW order (=XYZ)).\n     */\n    // -------------------------------------------------------------------\n    aiReturn GetTexture(aiTextureType type,\n        unsigned int  index,\n        C_STRUCT aiString* path,\n        aiTextureMapping* mapping   = NULL,\n        unsigned int* uvindex       = NULL,\n        ai_real* blend              = NULL,\n        aiTextureOp* op             = NULL,\n        aiTextureMapMode* mapmode   = NULL) const;\n\n\n    // Setters\n\n\n    // ------------------------------------------------------------------------------\n    /** @brief Add a property with a given key and type info to the material\n     *  structure\n     *\n     *  @param pInput Pointer to input data\n     *  @param pSizeInBytes Size of input data\n     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)\n     *  @param type Set by the AI_MATKEY_XXX macro\n     *  @param index Set by the AI_MATKEY_XXX macro\n     *  @param pType Type information hint */\n    aiReturn AddBinaryProperty (const void* pInput,\n        unsigned int pSizeInBytes,\n        const char* pKey,\n        unsigned int type ,\n        unsigned int index ,\n        aiPropertyTypeInfo pType);\n\n    // ------------------------------------------------------------------------------\n    /** @brief Add a string property with a given key and type info to the\n     *  material structure\n     *\n     *  @param pInput Input string\n     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)\n     *  @param type Set by the AI_MATKEY_XXX macro\n     *  @param index Set by the AI_MATKEY_XXX macro */\n    aiReturn AddProperty (const aiString* pInput,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    // ------------------------------------------------------------------------------\n    /** @brief Add a property with a given key to the material structure\n     *  @param pInput Pointer to the input data\n     *  @param pNumValues Number of values in the array\n     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)\n     *  @param type Set by the AI_MATKEY_XXX macro\n     *  @param index Set by the AI_MATKEY_XXX macro  */\n    template<class TYPE>\n    aiReturn AddProperty (const TYPE* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const aiVector3D* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const aiColor3D* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const aiColor4D* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const int* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const float* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const double* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    aiReturn AddProperty (const aiUVTransform* pInput,\n        unsigned int pNumValues,\n        const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    // ------------------------------------------------------------------------------\n    /** @brief Remove a given key from the list.\n     *\n     *  The function fails if the key isn't found\n     *  @param pKey Key to be deleted\n     *  @param type Set by the AI_MATKEY_XXX macro\n     *  @param index Set by the AI_MATKEY_XXX macro  */\n    aiReturn RemoveProperty (const char* pKey,\n        unsigned int type  = 0,\n        unsigned int index = 0);\n\n    // ------------------------------------------------------------------------------\n    /** @brief Removes all properties from the material.\n     *\n     *  The data array remains allocated so adding new properties is quite fast.  */\n    void Clear();\n\n    // ------------------------------------------------------------------------------\n    /** Copy the property list of a material\n     *  @param pcDest Destination material\n     *  @param pcSrc Source material\n     */\n    static void CopyPropertyList(aiMaterial* pcDest,\n        const aiMaterial* pcSrc);\n\n\n#endif\n\n    /** List of all material properties loaded. */\n    C_STRUCT aiMaterialProperty** mProperties;\n\n    /** Number of properties in the data base */\n    unsigned int mNumProperties;\n\n     /** Storage allocated */\n    unsigned int mNumAllocated;\n};\n\n// Go back to extern \"C\" again\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_NAME \"?mat.name\",0,0\n#define AI_MATKEY_TWOSIDED \"$mat.twosided\",0,0\n#define AI_MATKEY_SHADING_MODEL \"$mat.shadingm\",0,0\n#define AI_MATKEY_ENABLE_WIREFRAME \"$mat.wireframe\",0,0\n#define AI_MATKEY_BLEND_FUNC \"$mat.blend\",0,0\n#define AI_MATKEY_OPACITY \"$mat.opacity\",0,0\n#define AI_MATKEY_TRANSPARENCYFACTOR \"$mat.transparencyfactor\",0,0\n#define AI_MATKEY_BUMPSCALING \"$mat.bumpscaling\",0,0\n#define AI_MATKEY_SHININESS \"$mat.shininess\",0,0\n#define AI_MATKEY_REFLECTIVITY \"$mat.reflectivity\",0,0\n#define AI_MATKEY_SHININESS_STRENGTH \"$mat.shinpercent\",0,0\n#define AI_MATKEY_REFRACTI \"$mat.refracti\",0,0\n#define AI_MATKEY_COLOR_DIFFUSE \"$clr.diffuse\",0,0\n#define AI_MATKEY_COLOR_AMBIENT \"$clr.ambient\",0,0\n#define AI_MATKEY_COLOR_SPECULAR \"$clr.specular\",0,0\n#define AI_MATKEY_COLOR_EMISSIVE \"$clr.emissive\",0,0\n#define AI_MATKEY_COLOR_TRANSPARENT \"$clr.transparent\",0,0\n#define AI_MATKEY_COLOR_REFLECTIVE \"$clr.reflective\",0,0\n#define AI_MATKEY_GLOBAL_BACKGROUND_IMAGE \"?bg.global\",0,0\n#define AI_MATKEY_GLOBAL_SHADERLANG \"?sh.lang\",0,0\n#define AI_MATKEY_SHADER_VERTEX \"?sh.vs\",0,0\n#define AI_MATKEY_SHADER_FRAGMENT \"?sh.fs\",0,0\n#define AI_MATKEY_SHADER_GEO \"?sh.gs\",0,0\n#define AI_MATKEY_SHADER_TESSELATION \"?sh.ts\",0,0\n#define AI_MATKEY_SHADER_PRIMITIVE \"?sh.ps\",0,0\n#define AI_MATKEY_SHADER_COMPUTE \"?sh.cs\",0,0\n\n// ---------------------------------------------------------------------------\n// Pure key names for all texture-related properties\n//! @cond MATS_DOC_FULL\n#define _AI_MATKEY_TEXTURE_BASE         \"$tex.file\"\n#define _AI_MATKEY_UVWSRC_BASE          \"$tex.uvwsrc\"\n#define _AI_MATKEY_TEXOP_BASE           \"$tex.op\"\n#define _AI_MATKEY_MAPPING_BASE         \"$tex.mapping\"\n#define _AI_MATKEY_TEXBLEND_BASE        \"$tex.blend\"\n#define _AI_MATKEY_MAPPINGMODE_U_BASE   \"$tex.mapmodeu\"\n#define _AI_MATKEY_MAPPINGMODE_V_BASE   \"$tex.mapmodev\"\n#define _AI_MATKEY_TEXMAP_AXIS_BASE     \"$tex.mapaxis\"\n#define _AI_MATKEY_UVTRANSFORM_BASE     \"$tex.uvtrafo\"\n#define _AI_MATKEY_TEXFLAGS_BASE        \"$tex.flags\"\n//! @endcond\n\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_TEXTURE(type, N) _AI_MATKEY_TEXTURE_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_TEXTURE_DIFFUSE(N)    \\\n    AI_MATKEY_TEXTURE(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_TEXTURE_SPECULAR(N)   \\\n    AI_MATKEY_TEXTURE(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_TEXTURE_AMBIENT(N)    \\\n    AI_MATKEY_TEXTURE(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_TEXTURE_EMISSIVE(N)   \\\n    AI_MATKEY_TEXTURE(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_TEXTURE_NORMALS(N)    \\\n    AI_MATKEY_TEXTURE(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_TEXTURE_HEIGHT(N) \\\n    AI_MATKEY_TEXTURE(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_TEXTURE_SHININESS(N)  \\\n    AI_MATKEY_TEXTURE(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_TEXTURE_OPACITY(N)    \\\n    AI_MATKEY_TEXTURE(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_TEXTURE_DISPLACEMENT(N)   \\\n    AI_MATKEY_TEXTURE(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_TEXTURE_LIGHTMAP(N)   \\\n    AI_MATKEY_TEXTURE(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_TEXTURE_REFLECTION(N) \\\n    AI_MATKEY_TEXTURE(aiTextureType_REFLECTION,N)\n\n//! @endcond\n\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_UVWSRC(type, N) _AI_MATKEY_UVWSRC_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_UVWSRC_DIFFUSE(N) \\\n    AI_MATKEY_UVWSRC(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_UVWSRC_SPECULAR(N)    \\\n    AI_MATKEY_UVWSRC(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_UVWSRC_AMBIENT(N) \\\n    AI_MATKEY_UVWSRC(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_UVWSRC_EMISSIVE(N)    \\\n    AI_MATKEY_UVWSRC(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_UVWSRC_NORMALS(N) \\\n    AI_MATKEY_UVWSRC(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_UVWSRC_HEIGHT(N)  \\\n    AI_MATKEY_UVWSRC(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_UVWSRC_SHININESS(N)   \\\n    AI_MATKEY_UVWSRC(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_UVWSRC_OPACITY(N) \\\n    AI_MATKEY_UVWSRC(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_UVWSRC_DISPLACEMENT(N)    \\\n    AI_MATKEY_UVWSRC(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_UVWSRC_LIGHTMAP(N)    \\\n    AI_MATKEY_UVWSRC(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_UVWSRC_REFLECTION(N)  \\\n    AI_MATKEY_UVWSRC(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_TEXOP(type, N) _AI_MATKEY_TEXOP_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_TEXOP_DIFFUSE(N)  \\\n    AI_MATKEY_TEXOP(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_TEXOP_SPECULAR(N) \\\n    AI_MATKEY_TEXOP(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_TEXOP_AMBIENT(N)  \\\n    AI_MATKEY_TEXOP(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_TEXOP_EMISSIVE(N) \\\n    AI_MATKEY_TEXOP(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_TEXOP_NORMALS(N)  \\\n    AI_MATKEY_TEXOP(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_TEXOP_HEIGHT(N)   \\\n    AI_MATKEY_TEXOP(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_TEXOP_SHININESS(N)    \\\n    AI_MATKEY_TEXOP(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_TEXOP_OPACITY(N)  \\\n    AI_MATKEY_TEXOP(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_TEXOP_DISPLACEMENT(N) \\\n    AI_MATKEY_TEXOP(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_TEXOP_LIGHTMAP(N) \\\n    AI_MATKEY_TEXOP(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_TEXOP_REFLECTION(N)   \\\n    AI_MATKEY_TEXOP(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_MAPPING(type, N) _AI_MATKEY_MAPPING_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_MAPPING_DIFFUSE(N)    \\\n    AI_MATKEY_MAPPING(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_MAPPING_SPECULAR(N)   \\\n    AI_MATKEY_MAPPING(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_MAPPING_AMBIENT(N)    \\\n    AI_MATKEY_MAPPING(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_MAPPING_EMISSIVE(N)   \\\n    AI_MATKEY_MAPPING(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_MAPPING_NORMALS(N)    \\\n    AI_MATKEY_MAPPING(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_MAPPING_HEIGHT(N) \\\n    AI_MATKEY_MAPPING(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_MAPPING_SHININESS(N)  \\\n    AI_MATKEY_MAPPING(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_MAPPING_OPACITY(N)    \\\n    AI_MATKEY_MAPPING(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_MAPPING_DISPLACEMENT(N)   \\\n    AI_MATKEY_MAPPING(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_MAPPING_LIGHTMAP(N)   \\\n    AI_MATKEY_MAPPING(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_MAPPING_REFLECTION(N) \\\n    AI_MATKEY_MAPPING(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_TEXBLEND(type, N) _AI_MATKEY_TEXBLEND_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_TEXBLEND_DIFFUSE(N)   \\\n    AI_MATKEY_TEXBLEND(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_TEXBLEND_SPECULAR(N)  \\\n    AI_MATKEY_TEXBLEND(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_TEXBLEND_AMBIENT(N)   \\\n    AI_MATKEY_TEXBLEND(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_TEXBLEND_EMISSIVE(N)  \\\n    AI_MATKEY_TEXBLEND(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_TEXBLEND_NORMALS(N)   \\\n    AI_MATKEY_TEXBLEND(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_TEXBLEND_HEIGHT(N)    \\\n    AI_MATKEY_TEXBLEND(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_TEXBLEND_SHININESS(N) \\\n    AI_MATKEY_TEXBLEND(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_TEXBLEND_OPACITY(N)   \\\n    AI_MATKEY_TEXBLEND(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_TEXBLEND_DISPLACEMENT(N)  \\\n    AI_MATKEY_TEXBLEND(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_TEXBLEND_LIGHTMAP(N)  \\\n    AI_MATKEY_TEXBLEND(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_TEXBLEND_REFLECTION(N)    \\\n    AI_MATKEY_TEXBLEND(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_MAPPINGMODE_U(type, N) _AI_MATKEY_MAPPINGMODE_U_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_MAPPINGMODE_U_DIFFUSE(N)  \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_SPECULAR(N) \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_AMBIENT(N)  \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_EMISSIVE(N) \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_NORMALS(N)  \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_HEIGHT(N)   \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_SHININESS(N)    \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_OPACITY(N)  \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_DISPLACEMENT(N) \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_LIGHTMAP(N) \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_MAPPINGMODE_U_REFLECTION(N)   \\\n    AI_MATKEY_MAPPINGMODE_U(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_MAPPINGMODE_V(type, N) _AI_MATKEY_MAPPINGMODE_V_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_MAPPINGMODE_V_DIFFUSE(N)  \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_SPECULAR(N) \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_AMBIENT(N)  \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_EMISSIVE(N) \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_NORMALS(N)  \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_HEIGHT(N)   \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_SHININESS(N)    \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_OPACITY(N)  \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_DISPLACEMENT(N) \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_LIGHTMAP(N) \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_MAPPINGMODE_V_REFLECTION(N)   \\\n    AI_MATKEY_MAPPINGMODE_V(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_TEXMAP_AXIS(type, N) _AI_MATKEY_TEXMAP_AXIS_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_TEXMAP_AXIS_DIFFUSE(N)    \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_SPECULAR(N)   \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_AMBIENT(N)    \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_EMISSIVE(N)   \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_NORMALS(N)    \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_HEIGHT(N) \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_SHININESS(N)  \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_OPACITY(N)    \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_DISPLACEMENT(N)   \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_LIGHTMAP(N)   \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_TEXMAP_AXIS_REFLECTION(N) \\\n    AI_MATKEY_TEXMAP_AXIS(aiTextureType_REFLECTION,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_UVTRANSFORM(type, N) _AI_MATKEY_UVTRANSFORM_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_UVTRANSFORM_DIFFUSE(N)    \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_UVTRANSFORM_SPECULAR(N)   \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_UVTRANSFORM_AMBIENT(N)    \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_UVTRANSFORM_EMISSIVE(N)   \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_UVTRANSFORM_NORMALS(N)    \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_UVTRANSFORM_HEIGHT(N) \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_UVTRANSFORM_SHININESS(N)  \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_UVTRANSFORM_OPACITY(N)    \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_UVTRANSFORM_DISPLACEMENT(N)   \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_UVTRANSFORM_LIGHTMAP(N)   \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_UVTRANSFORM_REFLECTION(N) \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_REFLECTION,N)\n\n#define AI_MATKEY_UVTRANSFORM_UNKNOWN(N)    \\\n    AI_MATKEY_UVTRANSFORM(aiTextureType_UNKNOWN,N)\n\n//! @endcond\n// ---------------------------------------------------------------------------\n#define AI_MATKEY_TEXFLAGS(type, N) _AI_MATKEY_TEXFLAGS_BASE,type,N\n\n// For backward compatibility and simplicity\n//! @cond MATS_DOC_FULL\n#define AI_MATKEY_TEXFLAGS_DIFFUSE(N)   \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_DIFFUSE,N)\n\n#define AI_MATKEY_TEXFLAGS_SPECULAR(N)  \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_SPECULAR,N)\n\n#define AI_MATKEY_TEXFLAGS_AMBIENT(N)   \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_AMBIENT,N)\n\n#define AI_MATKEY_TEXFLAGS_EMISSIVE(N)  \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_EMISSIVE,N)\n\n#define AI_MATKEY_TEXFLAGS_NORMALS(N)   \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_NORMALS,N)\n\n#define AI_MATKEY_TEXFLAGS_HEIGHT(N)    \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_HEIGHT,N)\n\n#define AI_MATKEY_TEXFLAGS_SHININESS(N) \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_SHININESS,N)\n\n#define AI_MATKEY_TEXFLAGS_OPACITY(N)   \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_OPACITY,N)\n\n#define AI_MATKEY_TEXFLAGS_DISPLACEMENT(N)  \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_DISPLACEMENT,N)\n\n#define AI_MATKEY_TEXFLAGS_LIGHTMAP(N)  \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_LIGHTMAP,N)\n\n#define AI_MATKEY_TEXFLAGS_REFLECTION(N)    \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_REFLECTION,N)\n\n#define AI_MATKEY_TEXFLAGS_UNKNOWN(N)   \\\n    AI_MATKEY_TEXFLAGS(aiTextureType_UNKNOWN,N)\n\n//! @endcond\n//!\n// ---------------------------------------------------------------------------\n/** @brief Retrieve a material property with a specific key from the material\n *\n * @param pMat Pointer to the input material. May not be NULL\n * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n * @param type Specifies the type of the texture to be retrieved (\n *    e.g. diffuse, specular, height map ...)\n * @param index Index of the texture to be retrieved.\n * @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty\n *        structure or NULL if the key has not been found. */\n// ---------------------------------------------------------------------------\nASSIMP_API C_ENUM aiReturn aiGetMaterialProperty(\n    const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int  index,\n    const C_STRUCT aiMaterialProperty** pPropOut);\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve an array of float values with a specific key\n *  from the material\n *\n * Pass one of the AI_MATKEY_XXX constants for the last three parameters (the\n * example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)\n * @code\n * aiUVTransform trafo;\n * unsigned int max = sizeof(aiUVTransform);\n * if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),\n *    (float*)&trafo, &max) || sizeof(aiUVTransform) != max)\n * {\n *   // error handling\n * }\n * @endcode\n *\n * @param pMat Pointer to the input material. May not be NULL\n * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n * @param pOut Pointer to a buffer to receive the result.\n * @param pMax Specifies the size of the given buffer, in float's.\n *        Receives the number of values (not bytes!) read.\n * @param type (see the code sample above)\n * @param index (see the code sample above)\n * @return Specifies whether the key has been found. If not, the output\n *   arrays remains unmodified and pMax is set to 0.*/\n// ---------------------------------------------------------------------------\nASSIMP_API C_ENUM aiReturn aiGetMaterialFloatArray(\n    const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    ai_real* pOut,\n    unsigned int* pMax);\n\n\n#ifdef __cplusplus\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve a single float property with a specific key from the material.\n*\n* Pass one of the AI_MATKEY_XXX constants for the last three parameters (the\n* example reads the #AI_MATKEY_SHININESS_STRENGTH property of the first diffuse texture)\n* @code\n* float specStrength = 1.f; // default value, remains unmodified if we fail.\n* aiGetMaterialFloat(mat, AI_MATKEY_SHININESS_STRENGTH,\n*    (float*)&specStrength);\n* @endcode\n*\n* @param pMat Pointer to the input material. May not be NULL\n* @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n* @param pOut Receives the output float.\n* @param type (see the code sample above)\n* @param index (see the code sample above)\n* @return Specifies whether the key has been found. If not, the output\n*   float remains unmodified.*/\n// ---------------------------------------------------------------------------\ninline aiReturn aiGetMaterialFloat(const aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    ai_real* pOut)\n{\n    return aiGetMaterialFloatArray(pMat,pKey,type,index,pOut,(unsigned int*)0x0);\n}\n\n#else\n\n// Use our friend, the C preprocessor\n#define aiGetMaterialFloat (pMat, type, index, pKey, pOut) \\\n    aiGetMaterialFloatArray(pMat, type, index, pKey, pOut, NULL)\n\n#endif //!__cplusplus\n\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve an array of integer values with a specific key\n *  from a material\n *\n * See the sample for aiGetMaterialFloatArray for more information.*/\nASSIMP_API C_ENUM aiReturn aiGetMaterialIntegerArray(const C_STRUCT aiMaterial* pMat,\n     const char* pKey,\n     unsigned int  type,\n     unsigned int  index,\n     int* pOut,\n     unsigned int* pMax);\n\n\n#ifdef __cplusplus\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve an integer property with a specific key from a material\n *\n * See the sample for aiGetMaterialFloat for more information.*/\n// ---------------------------------------------------------------------------\ninline aiReturn aiGetMaterialInteger(const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    int* pOut)\n{\n    return aiGetMaterialIntegerArray(pMat,pKey,type,index,pOut,(unsigned int*)0x0);\n}\n\n#else\n\n// use our friend, the C preprocessor\n#define aiGetMaterialInteger (pMat, type, index, pKey, pOut) \\\n    aiGetMaterialIntegerArray(pMat, type, index, pKey, pOut, NULL)\n\n#endif //!__cplusplus\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve a color value from the material property table\n*\n* See the sample for aiGetMaterialFloat for more information*/\n// ---------------------------------------------------------------------------\nASSIMP_API C_ENUM aiReturn aiGetMaterialColor(const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    C_STRUCT aiColor4D* pOut);\n\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve a aiUVTransform value from the material property table\n*\n* See the sample for aiGetMaterialFloat for more information*/\n// ---------------------------------------------------------------------------\nASSIMP_API C_ENUM aiReturn aiGetMaterialUVTransform(const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    C_STRUCT aiUVTransform* pOut);\n\n\n// ---------------------------------------------------------------------------\n/** @brief Retrieve a string from the material property table\n*\n* See the sample for aiGetMaterialFloat for more information.*/\n// ---------------------------------------------------------------------------\nASSIMP_API C_ENUM aiReturn aiGetMaterialString(const C_STRUCT aiMaterial* pMat,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index,\n    C_STRUCT aiString* pOut);\n\n// ---------------------------------------------------------------------------\n/** Get the number of textures for a particular texture type.\n *  @param[in] pMat Pointer to the input material. May not be NULL\n *  @param type Texture type to check for\n *  @return Number of textures for this type.\n *  @note A texture can be easily queried using #aiGetMaterialTexture() */\n// ---------------------------------------------------------------------------\nASSIMP_API unsigned int aiGetMaterialTextureCount(const C_STRUCT aiMaterial* pMat,\n    C_ENUM aiTextureType type);\n\n// ---------------------------------------------------------------------------\n/** @brief Helper function to get all values pertaining to a particular\n *  texture slot from a material structure.\n *\n *  This function is provided just for convenience. You could also read the\n *  texture by parsing all of its properties manually. This function bundles\n *  all of them in a huge function monster.\n *\n *  @param[in] mat Pointer to the input material. May not be NULL\n *  @param[in] type Specifies the texture stack to read from (e.g. diffuse,\n *     specular, height map ...).\n *  @param[in] index Index of the texture. The function fails if the\n *     requested index is not available for this texture type.\n *     #aiGetMaterialTextureCount() can be used to determine the number of\n *     textures in a particular texture stack.\n *  @param[out] path Receives the output path\n *     If the texture is embedded, receives a '*' followed by the id of\n *     the texture (for the textures stored in the corresponding scene) which\n *     can be converted to an int using a function like atoi.\n *     This parameter must be non-null.\n *  @param mapping The texture mapping mode to be used.\n *      Pass NULL if you're not interested in this information.\n *  @param[out] uvindex For UV-mapped textures: receives the index of the UV\n *      source channel. Unmodified otherwise.\n *      Pass NULL if you're not interested in this information.\n *  @param[out] blend Receives the blend factor for the texture\n *      Pass NULL if you're not interested in this information.\n *  @param[out] op Receives the texture blend operation to be perform between\n *      this texture and the previous texture.\n *      Pass NULL if you're not interested in this information.\n *  @param[out] mapmode Receives the mapping modes to be used for the texture.\n *      Pass NULL if you're not interested in this information. Otherwise,\n *      pass a pointer to an array of two aiTextureMapMode's (one for each\n *      axis, UV order).\n *  @param[out] flags Receives the the texture flags.\n *  @return AI_SUCCESS on success, otherwise something else. Have fun.*/\n// ---------------------------------------------------------------------------\n#ifdef __cplusplus\nASSIMP_API aiReturn aiGetMaterialTexture(const C_STRUCT aiMaterial* mat,\n    aiTextureType type,\n    unsigned int  index,\n    aiString* path,\n    aiTextureMapping* mapping   = NULL,\n    unsigned int* uvindex       = NULL,\n    ai_real* blend              = NULL,\n    aiTextureOp* op             = NULL,\n    aiTextureMapMode* mapmode   = NULL,\n    unsigned int* flags         = NULL);\n#else\nC_ENUM aiReturn aiGetMaterialTexture(const C_STRUCT aiMaterial* mat,\n    C_ENUM aiTextureType type,\n    unsigned int  index,\n    C_STRUCT aiString* path,\n    C_ENUM aiTextureMapping* mapping    /*= NULL*/,\n    unsigned int* uvindex               /*= NULL*/,\n    ai_real* blend                      /*= NULL*/,\n    C_ENUM aiTextureOp* op              /*= NULL*/,\n    C_ENUM aiTextureMapMode* mapmode    /*= NULL*/,\n    unsigned int* flags                 /*= NULL*/);\n#endif // !#ifdef __cplusplus\n\n\n#ifdef __cplusplus\n}\n\n#include \"material.inl\"\n\n#endif //!__cplusplus\n\n#endif //!!AI_MATERIAL_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/material.h b/include/assimp/material.h
--- a/include/assimp/material.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/material.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,7 +48,11 @@
 #ifndef AI_MATERIAL_H_INC
 #define AI_MATERIAL_H_INC
 
-#include "types.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -308,6 +312,10 @@
 
 #define AI_TEXTURE_TYPE_MAX  aiTextureType_UNKNOWN
 
+// -------------------------------------------------------------------------------
+// Get a string for a given aiTextureType
+ASSIMP_API const char* TextureTypeToString(enum aiTextureType in);
+
 // ---------------------------------------------------------------------------
 /** @brief Defines all shading models supported by the library
  *
Index: include/assimp/CreateAnimMesh.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file CreateAnimMesh.h\n *  Create AnimMesh from Mesh\n */\n#ifndef INCLUDED_AI_CREATE_ANIM_MESH_H\n#define INCLUDED_AI_CREATE_ANIM_MESH_H\n\n#include <assimp/mesh.h>\n\nnamespace Assimp    {\n\n/** Create aiAnimMesh from aiMesh. */\nASSIMP_API aiAnimMesh *aiCreateAnimMesh(const aiMesh *mesh);\n\n} // end of namespace Assimp\n#endif // INCLUDED_AI_CREATE_ANIM_MESH_H\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/CreateAnimMesh.h b/include/assimp/CreateAnimMesh.h
--- a/include/assimp/CreateAnimMesh.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/CreateAnimMesh.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -43,16 +43,26 @@
 /** @file CreateAnimMesh.h
  *  Create AnimMesh from Mesh
  */
+#pragma once
 #ifndef INCLUDED_AI_CREATE_ANIM_MESH_H
 #define INCLUDED_AI_CREATE_ANIM_MESH_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/mesh.h>
 
-namespace Assimp    {
+namespace Assimp {
 
-/** Create aiAnimMesh from aiMesh. */
+/**
+ *  Create aiAnimMesh from aiMesh.
+ *  @param  mesh    The input mesh to create an animated mesh from.
+ *  @return The new created animated mesh.
+ */
 ASSIMP_API aiAnimMesh *aiCreateAnimMesh(const aiMesh *mesh);
 
 } // end of namespace Assimp
+
 #endif // INCLUDED_AI_CREATE_ANIM_MESH_H
 
Index: include/assimp/config.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2018, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file config.h\n *  @brief Defines constants for configurable properties for the library\n *\n *  Typically these properties are set via\n *  #Assimp::Importer::SetPropertyFloat,\n *  #Assimp::Importer::SetPropertyInteger or\n *  #Assimp::Importer::SetPropertyString,\n *  depending on the data type of a property. All properties have a\n *  default value. See the doc for the mentioned methods for more details.\n *\n *  <br><br>\n *  The corresponding functions for use with the plain-c API are:\n *  #aiSetImportPropertyInteger,\n *  #aiSetImportPropertyFloat,\n *  #aiSetImportPropertyString\n */\n#pragma once\n#ifndef AI_CONFIG_H_INC\n#define AI_CONFIG_H_INC\n\n\n// ###########################################################################\n// LIBRARY SETTINGS\n// General, global settings\n// ###########################################################################\n\n// ---------------------------------------------------------------------------\n/** @brief Enables time measurements.\n *\n *  If enabled, measures the time needed for each part of the loading\n *  process (i.e. IO time, importing, postprocessing, ..) and dumps\n *  these timings to the DefaultLogger. See the @link perf Performance\n *  Page@endlink for more information on this topic.\n *\n * Property type: bool. Default value: false.\n */\n#define AI_CONFIG_GLOB_MEASURE_TIME  \\\n    \"GLOB_MEASURE_TIME\"\n\n\n// ---------------------------------------------------------------------------\n/** @brief Global setting to disable generation of skeleton dummy meshes\n *\n * Skeleton dummy meshes are generated as a visualization aid in cases which\n * the input data contains no geometry, but only animation data.\n * Property data type: bool. Default value: false\n */\n// ---------------------------------------------------------------------------\n#define AI_CONFIG_IMPORT_NO_SKELETON_MESHES \\\n    \"IMPORT_NO_SKELETON_MESHES\"\n\n\n\n# if 0 // not implemented yet\n// ---------------------------------------------------------------------------\n/** @brief Set Assimp's multithreading policy.\n *\n * This setting is ignored if Assimp was built without boost.thread\n * support (ASSIMP_BUILD_NO_THREADING, which is implied by ASSIMP_BUILD_BOOST_WORKAROUND).\n * Possible values are: -1 to let Assimp decide what to do, 0 to disable\n * multithreading entirely and any number larger than 0 to force a specific\n * number of threads. Assimp is always free to ignore this settings, which is\n * merely a hint. Usually, the default value (-1) will be fine. However, if\n * Assimp is used concurrently from multiple user threads, it might be useful\n * to limit each Importer instance to a specific number of cores.\n *\n * For more information, see the @link threading Threading page@endlink.\n * Property type: int, default value: -1.\n */\n#define AI_CONFIG_GLOB_MULTITHREADING  \\\n    \"GLOB_MULTITHREADING\"\n#endif\n\n// ###########################################################################\n// POST PROCESSING SETTINGS\n// Various stuff to fine-tune the behavior of a specific post processing step.\n// ###########################################################################\n\n\n// ---------------------------------------------------------------------------\n/** @brief Maximum bone count per mesh for the SplitbyBoneCount step.\n *\n * Meshes are split until the maximum number of bones is reached. The default\n * value is AI_SBBC_DEFAULT_MAX_BONES, which may be altered at\n * compile-time.\n * Property data type: integer.\n */\n// ---------------------------------------------------------------------------\n#define AI_CONFIG_PP_SBBC_MAX_BONES \\\n    \"PP_SBBC_MAX_BONES\"\n\n\n// default limit for bone count\n#if (!defined AI_SBBC_DEFAULT_MAX_BONES)\n#   define AI_SBBC_DEFAULT_MAX_BONES        60\n#endif\n\n\n// ---------------------------------------------------------------------------\n/** @brief  Specifies the maximum angle that may be between two vertex tangents\n *         that their tangents and bi-tangents are smoothed.\n *\n * This applies to the CalcTangentSpace-Step. The angle is specified\n * in degrees. The maximum value is 175.\n * Property type: float. Default value: 45 degrees\n */\n#define AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE \\\n    \"PP_CT_MAX_SMOOTHING_ANGLE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Source UV channel for tangent space computation.\n *\n * The specified channel must exist or an error will be raised.\n * Property type: integer. Default value: 0\n */\n// ---------------------------------------------------------------------------\n#define AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX \\\n    \"PP_CT_TEXTURE_CHANNEL_INDEX\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Specifies the maximum angle that may be between two face normals\n *          at the same vertex position that their are smoothed together.\n *\n * Sometimes referred to as 'crease angle'.\n * This applies to the GenSmoothNormals-Step. The angle is specified\n * in degrees, so 180 is PI. The default value is 175 degrees (all vertex\n * normals are smoothed). The maximum value is 175, too. Property type: float.\n * Warning: setting this option may cause a severe loss of performance. The\n * performance is unaffected if the #AI_CONFIG_FAVOUR_SPEED flag is set but\n * the output quality may be reduced.\n */\n#define AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE \\\n    \"PP_GSN_MAX_SMOOTHING_ANGLE\"\n\n\n// ---------------------------------------------------------------------------\n/** @brief Sets the colormap (= palette) to be used to decode embedded\n *         textures in MDL (Quake or 3DGS) files.\n *\n * This must be a valid path to a file. The file is 768 (256*3) bytes\n * large and contains RGB triplets for each of the 256 palette entries.\n * The default value is colormap.lmp. If the file is not found,\n * a default palette (from Quake 1) is used.\n * Property type: string.\n */\n#define AI_CONFIG_IMPORT_MDL_COLORMAP       \\\n    \"IMPORT_MDL_COLORMAP\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_RemoveRedundantMaterials step to\n *  keep materials matching a name in a given list.\n *\n * This is a list of 1 to n strings, ' ' serves as delimiter character.\n * Identifiers containing whitespaces must be enclosed in *single*\n * quotation marks. For example:<tt>\n * \"keep-me and_me_to anotherMaterialToBeKept \\'name with whitespace\\'\"</tt>.\n * If a material matches on of these names, it will not be modified or\n * removed by the postprocessing step nor will other materials be replaced\n * by a reference to it. <br>\n * This option might be useful if you are using some magic material names\n * to pass additional semantics through the content pipeline. This ensures\n * they won't be optimized away, but a general optimization is still\n * performed for materials not contained in the list.\n * Property type: String. Default value: n/a\n * @note Linefeeds, tabs or carriage returns are treated as whitespace.\n *   Material names are case sensitive.\n */\n#define AI_CONFIG_PP_RRM_EXCLUDE_LIST   \\\n    \"PP_RRM_EXCLUDE_LIST\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_PreTransformVertices step to\n *  keep the scene hierarchy. Meshes are moved to worldspace, but\n *  no optimization is performed (read: meshes with equal materials are not\n *  joined. The total number of meshes won't change).\n *\n * This option could be of use for you if the scene hierarchy contains\n * important additional information which you intend to parse.\n * For rendering, you can still render all meshes in the scene without\n * any transformations.\n * Property type: bool. Default value: false.\n */\n#define AI_CONFIG_PP_PTV_KEEP_HIERARCHY     \\\n    \"PP_PTV_KEEP_HIERARCHY\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_PreTransformVertices step to normalize\n *  all vertex components into the [-1,1] range. That is, a bounding box\n *  for the whole scene is computed, the maximum component is taken and all\n *  meshes are scaled appropriately (uniformly of course!).\n *  This might be useful if you don't know the spatial dimension of the input\n *  data*/\n#define AI_CONFIG_PP_PTV_NORMALIZE  \\\n    \"PP_PTV_NORMALIZE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_PreTransformVertices step to use\n *  a users defined matrix as the scene root node transformation before\n *  transforming vertices.\n *  Property type: bool. Default value: false.\n */\n#define AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION    \\\n    \"PP_PTV_ADD_ROOT_TRANSFORMATION\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_PreTransformVertices step to use\n *  a users defined matrix as the scene root node transformation before\n *  transforming vertices. This property correspond to the 'a1' component\n *  of the transformation matrix.\n *  Property type: aiMatrix4x4.\n */\n#define AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION    \\\n    \"PP_PTV_ROOT_TRANSFORMATION\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_FindDegenerates step to\n *  remove degenerated primitives from the import - immediately.\n *\n * The default behaviour converts degenerated triangles to lines and\n * degenerated lines to points. See the documentation to the\n * #aiProcess_FindDegenerates step for a detailed example of the various ways\n * to get rid of these lines and points if you don't want them.\n * Property type: bool. Default value: false.\n */\n#define AI_CONFIG_PP_FD_REMOVE \\\n    \"PP_FD_REMOVE\"\n\n// ---------------------------------------------------------------------------\n/**\n *  @brief  Configures the #aiProcess_FindDegenerates to check the area of a\n *  trinagle to be greates than e-6. If this is not the case the triangle will\n *  be removed if #AI_CONFIG_PP_FD_REMOVE is set to true.\n */\n#define AI_CONFIG_PP_FD_CHECKAREA \\\n    \"PP_FD_CHECKAREA\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the #aiProcess_OptimizeGraph step to preserve nodes\n * matching a name in a given list.\n *\n * This is a list of 1 to n strings, ' ' serves as delimiter character.\n * Identifiers containing whitespaces must be enclosed in *single*\n * quotation marks. For example:<tt>\n * \"keep-me and_me_to anotherNodeToBeKept \\'name with whitespace\\'\"</tt>.\n * If a node matches on of these names, it will not be modified or\n * removed by the postprocessing step.<br>\n * This option might be useful if you are using some magic node names\n * to pass additional semantics through the content pipeline. This ensures\n * they won't be optimized away, but a general optimization is still\n * performed for nodes not contained in the list.\n * Property type: String. Default value: n/a\n * @note Linefeeds, tabs or carriage returns are treated as whitespace.\n *   Node names are case sensitive.\n */\n#define AI_CONFIG_PP_OG_EXCLUDE_LIST    \\\n    \"PP_OG_EXCLUDE_LIST\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Set the maximum number of triangles in a mesh.\n *\n * This is used by the \"SplitLargeMeshes\" PostProcess-Step to determine\n * whether a mesh must be split or not.\n * @note The default value is AI_SLM_DEFAULT_MAX_TRIANGLES\n * Property type: integer.\n */\n#define AI_CONFIG_PP_SLM_TRIANGLE_LIMIT \\\n    \"PP_SLM_TRIANGLE_LIMIT\"\n\n// default value for AI_CONFIG_PP_SLM_TRIANGLE_LIMIT\n#if (!defined AI_SLM_DEFAULT_MAX_TRIANGLES)\n#   define AI_SLM_DEFAULT_MAX_TRIANGLES     1000000\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief  Set the maximum number of vertices in a mesh.\n *\n * This is used by the \"SplitLargeMeshes\" PostProcess-Step to determine\n * whether a mesh must be split or not.\n * @note The default value is AI_SLM_DEFAULT_MAX_VERTICES\n * Property type: integer.\n */\n#define AI_CONFIG_PP_SLM_VERTEX_LIMIT \\\n    \"PP_SLM_VERTEX_LIMIT\"\n\n// default value for AI_CONFIG_PP_SLM_VERTEX_LIMIT\n#if (!defined AI_SLM_DEFAULT_MAX_VERTICES)\n#   define AI_SLM_DEFAULT_MAX_VERTICES      1000000\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief Set the maximum number of bones affecting a single vertex\n *\n * This is used by the #aiProcess_LimitBoneWeights PostProcess-Step.\n * @note The default value is AI_LMW_MAX_WEIGHTS\n * Property type: integer.*/\n#define AI_CONFIG_PP_LBW_MAX_WEIGHTS    \\\n    \"PP_LBW_MAX_WEIGHTS\"\n\n// default value for AI_CONFIG_PP_LBW_MAX_WEIGHTS\n#if (!defined AI_LMW_MAX_WEIGHTS)\n#   define AI_LMW_MAX_WEIGHTS   0x4\n#endif // !! AI_LMW_MAX_WEIGHTS\n\n// ---------------------------------------------------------------------------\n/** @brief Lower the deboning threshold in order to remove more bones.\n *\n * This is used by the #aiProcess_Debone PostProcess-Step.\n * @note The default value is AI_DEBONE_THRESHOLD\n * Property type: float.*/\n#define AI_CONFIG_PP_DB_THRESHOLD \\\n    \"PP_DB_THRESHOLD\"\n\n// default value for AI_CONFIG_PP_LBW_MAX_WEIGHTS\n#if (!defined AI_DEBONE_THRESHOLD)\n#   define AI_DEBONE_THRESHOLD  1.0f\n#endif // !! AI_DEBONE_THRESHOLD\n\n// ---------------------------------------------------------------------------\n/** @brief Require all bones qualify for deboning before removing any\n *\n * This is used by the #aiProcess_Debone PostProcess-Step.\n * @note The default value is 0\n * Property type: bool.*/\n#define AI_CONFIG_PP_DB_ALL_OR_NONE \\\n    \"PP_DB_ALL_OR_NONE\"\n\n/** @brief Default value for the #AI_CONFIG_PP_ICL_PTCACHE_SIZE property\n */\n#ifndef PP_ICL_PTCACHE_SIZE\n#   define PP_ICL_PTCACHE_SIZE 12\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief Set the size of the post-transform vertex cache to optimize the\n *    vertices for. This configures the #aiProcess_ImproveCacheLocality step.\n *\n * The size is given in vertices. Of course you can't know how the vertex\n * format will exactly look like after the import returns, but you can still\n * guess what your meshes will probably have.\n * @note The default value is #PP_ICL_PTCACHE_SIZE. That results in slight\n * performance improvements for most nVidia/AMD cards since 2002.\n * Property type: integer.\n */\n#define AI_CONFIG_PP_ICL_PTCACHE_SIZE   \"PP_ICL_PTCACHE_SIZE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Enumerates components of the aiScene and aiMesh data structures\n *  that can be excluded from the import using the #aiProcess_RemoveComponent step.\n *\n *  See the documentation to #aiProcess_RemoveComponent for more details.\n */\nenum aiComponent\n{\n    /** Normal vectors */\n#ifdef SWIG\n    aiComponent_NORMALS = 0x2,\n#else\n    aiComponent_NORMALS = 0x2u,\n#endif\n\n    /** Tangents and bitangents go always together ... */\n#ifdef SWIG\n    aiComponent_TANGENTS_AND_BITANGENTS = 0x4,\n#else\n    aiComponent_TANGENTS_AND_BITANGENTS = 0x4u,\n#endif\n\n    /** ALL color sets\n     * Use aiComponent_COLORn(N) to specify the N'th set */\n    aiComponent_COLORS = 0x8,\n\n    /** ALL texture UV sets\n     * aiComponent_TEXCOORDn(N) to specify the N'th set  */\n    aiComponent_TEXCOORDS = 0x10,\n\n    /** Removes all bone weights from all meshes.\n     * The scenegraph nodes corresponding to the bones are NOT removed.\n     * use the #aiProcess_OptimizeGraph step to do this */\n    aiComponent_BONEWEIGHTS = 0x20,\n\n    /** Removes all node animations (aiScene::mAnimations).\n     * The corresponding scenegraph nodes are NOT removed.\n     * use the #aiProcess_OptimizeGraph step to do this */\n    aiComponent_ANIMATIONS = 0x40,\n\n    /** Removes all embedded textures (aiScene::mTextures) */\n    aiComponent_TEXTURES = 0x80,\n\n    /** Removes all light sources (aiScene::mLights).\n     * The corresponding scenegraph nodes are NOT removed.\n     * use the #aiProcess_OptimizeGraph step to do this */\n    aiComponent_LIGHTS = 0x100,\n\n    /** Removes all cameras (aiScene::mCameras).\n     * The corresponding scenegraph nodes are NOT removed.\n     * use the #aiProcess_OptimizeGraph step to do this */\n    aiComponent_CAMERAS = 0x200,\n\n    /** Removes all meshes (aiScene::mMeshes). */\n    aiComponent_MESHES = 0x400,\n\n    /** Removes all materials. One default material will\n     * be generated, so aiScene::mNumMaterials will be 1. */\n    aiComponent_MATERIALS = 0x800,\n\n\n    /** This value is not used. It is just there to force the\n     *  compiler to map this enum to a 32 Bit integer. */\n#ifndef SWIG\n    _aiComponent_Force32Bit = 0x9fffffff\n#endif\n};\n\n// Remove a specific color channel 'n'\n#define aiComponent_COLORSn(n) (1u << (n+20u))\n\n// Remove a specific UV channel 'n'\n#define aiComponent_TEXCOORDSn(n) (1u << (n+25u))\n\n// ---------------------------------------------------------------------------\n/** @brief Input parameter to the #aiProcess_RemoveComponent step:\n *  Specifies the parts of the data structure to be removed.\n *\n * See the documentation to this step for further details. The property\n * is expected to be an integer, a bitwise combination of the\n * #aiComponent flags defined above in this header. The default\n * value is 0. Important: if no valid mesh is remaining after the\n * step has been executed (e.g you thought it was funny to specify ALL\n * of the flags defined above) the import FAILS. Mainly because there is\n * no data to work on anymore ...\n */\n#define AI_CONFIG_PP_RVC_FLAGS              \\\n    \"PP_RVC_FLAGS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Input parameter to the #aiProcess_SortByPType step:\n *  Specifies which primitive types are removed by the step.\n *\n *  This is a bitwise combination of the aiPrimitiveType flags.\n *  Specifying all of them is illegal, of course. A typical use would\n *  be to exclude all line and point meshes from the import. This\n *  is an integer property, its default value is 0.\n */\n#define AI_CONFIG_PP_SBP_REMOVE             \\\n    \"PP_SBP_REMOVE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Input parameter to the #aiProcess_FindInvalidData step:\n *  Specifies the floating-point accuracy for animation values. The step\n *  checks for animation tracks where all frame values are absolutely equal\n *  and removes them. This tweakable controls the epsilon for floating-point\n *  comparisons - two keys are considered equal if the invariant\n *  abs(n0-n1)>epsilon holds true for all vector respectively quaternion\n *  components. The default value is 0.f - comparisons are exact then.\n */\n#define AI_CONFIG_PP_FID_ANIM_ACCURACY              \\\n    \"PP_FID_ANIM_ACCURACY\"\n\n// ---------------------------------------------------------------------------\n/** @brief Input parameter to the #aiProcess_FindInvalidData step:\n *  Set to true to ignore texture coordinates. This may be useful if you have\n *  to assign different kind of textures like one for the summer or one for the winter.\n */\n#define AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS        \\\n    \"PP_FID_IGNORE_TEXTURECOORDS\"\n\n// TransformUVCoords evaluates UV scalings\n#define AI_UVTRAFO_SCALING 0x1\n\n// TransformUVCoords evaluates UV rotations\n#define AI_UVTRAFO_ROTATION 0x2\n\n// TransformUVCoords evaluates UV translation\n#define AI_UVTRAFO_TRANSLATION 0x4\n\n// Everything baked together -> default value\n#define AI_UVTRAFO_ALL (AI_UVTRAFO_SCALING | AI_UVTRAFO_ROTATION | AI_UVTRAFO_TRANSLATION)\n\n// ---------------------------------------------------------------------------\n/** @brief Input parameter to the #aiProcess_TransformUVCoords step:\n *  Specifies which UV transformations are evaluated.\n *\n *  This is a bitwise combination of the AI_UVTRAFO_XXX flags (integer\n *  property, of course). By default all transformations are enabled\n * (AI_UVTRAFO_ALL).\n */\n#define AI_CONFIG_PP_TUV_EVALUATE               \\\n    \"PP_TUV_EVALUATE\"\n\n// ---------------------------------------------------------------------------\n/** @brief A hint to assimp to favour speed against import quality.\n *\n * Enabling this option may result in faster loading, but it needn't.\n * It represents just a hint to loaders and post-processing steps to use\n * faster code paths, if possible.\n * This property is expected to be an integer, != 0 stands for true.\n * The default value is 0.\n */\n#define AI_CONFIG_FAVOUR_SPEED              \\\n \"FAVOUR_SPEED\"\n\n\n// ###########################################################################\n// IMPORTER SETTINGS\n// Various stuff to fine-tune the behaviour of specific importer plugins.\n// ###########################################################################\n\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will merge all geometry layers present\n *    in the source file or take only the first.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS \\\n    \"IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read all materials present in the\n *    source file or take only the referenced materials.\n *\n * This is void unless IMPORT_FBX_READ_MATERIALS=1.\n *\n * The default value is false (0)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS \\\n    \"IMPORT_FBX_READ_ALL_MATERIALS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read materials.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_MATERIALS \\\n    \"IMPORT_FBX_READ_MATERIALS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read embedded textures.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_TEXTURES \\\n    \"IMPORT_FBX_READ_TEXTURES\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read cameras.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_CAMERAS \\\n    \"IMPORT_FBX_READ_CAMERAS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read light sources.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_LIGHTS \\\n    \"IMPORT_FBX_READ_LIGHTS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will read animations.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS \\\n    \"IMPORT_FBX_READ_ANIMATIONS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will act in strict mode in which only\n *    FBX 2013 is supported and any other sub formats are rejected. FBX 2013\n *    is the primary target for the importer, so this format is best\n *    supported and well-tested.\n *\n * The default value is false (0)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_STRICT_MODE \\\n    \"IMPORT_FBX_STRICT_MODE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will preserve pivot points for\n *    transformations (as extra nodes). If set to false, pivots and offsets\n *    will be evaluated whenever possible.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS \\\n    \"IMPORT_FBX_PRESERVE_PIVOTS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Specifies whether the importer will drop empty animation curves or\n *    animation curves which match the bind pose transformation over their\n *    entire defined range.\n *\n * The default value is true (1)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES \\\n    \"IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES\"\n\n// ---------------------------------------------------------------------------\n/** @brief Set whether the fbx importer will use the legacy embedded texture naming.\n *\n * The default value is false (0)\n * Property type: bool\n */\n#define AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING \\\n\t\"AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Set wether the importer shall not remove empty bones.\n *  \n *  Empty bone are often used to define connections for other models.\n */\n#define AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES \\\n    \"AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES\"\n\n\n// ---------------------------------------------------------------------------\n/** @brief  Set wether the FBX importer shall convert the unit from cm to m.\n */\n#define AI_CONFIG_FBX_CONVERT_TO_M \\\n    \"AI_CONFIG_FBX_CONVERT_TO_M\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Set the vertex animation keyframe to be imported\n *\n * ASSIMP does not support vertex keyframes (only bone animation is supported).\n * The library reads only one frame of models with vertex animations.\n * By default this is the first frame.\n * \\note The default value is 0. This option applies to all importers.\n *   However, it is also possible to override the global setting\n *   for a specific loader. You can use the AI_CONFIG_IMPORT_XXX_KEYFRAME\n *   options (where XXX is a placeholder for the file format for which you\n *   want to override the global setting).\n * Property type: integer.\n */\n#define AI_CONFIG_IMPORT_GLOBAL_KEYFRAME    \"IMPORT_GLOBAL_KEYFRAME\"\n\n#define AI_CONFIG_IMPORT_MD3_KEYFRAME       \"IMPORT_MD3_KEYFRAME\"\n#define AI_CONFIG_IMPORT_MD2_KEYFRAME       \"IMPORT_MD2_KEYFRAME\"\n#define AI_CONFIG_IMPORT_MDL_KEYFRAME       \"IMPORT_MDL_KEYFRAME\"\n#define AI_CONFIG_IMPORT_MDC_KEYFRAME       \"IMPORT_MDC_KEYFRAME\"\n#define AI_CONFIG_IMPORT_SMD_KEYFRAME       \"IMPORT_SMD_KEYFRAME\"\n#define AI_CONFIG_IMPORT_UNREAL_KEYFRAME    \"IMPORT_UNREAL_KEYFRAME\"\n\n// ---------------------------------------------------------------------------\n/** Smd load multiple animations\n *\n *  Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST \"IMPORT_SMD_LOAD_ANIMATION_LIST\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the AC loader to collect all surfaces which have the\n *    \"Backface cull\" flag set in separate meshes.\n *\n *  Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL \\\n    \"IMPORT_AC_SEPARATE_BFCULL\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures whether the AC loader evaluates subdivision surfaces (\n *  indicated by the presence of the 'subdiv' attribute in the file). By\n *  default, Assimp performs the subdivision using the standard\n *  Catmull-Clark algorithm\n *\n * * Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION    \\\n    \"IMPORT_AC_EVAL_SUBDIVISION\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the UNREAL 3D loader to separate faces with different\n *    surface flags (e.g. two-sided vs. single-sided).\n *\n * * Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS \\\n    \"UNREAL_HANDLE_FLAGS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Configures the terragen import plugin to compute uv's for\n *  terrains, if not given. Furthermore a default texture is assigned.\n *\n * UV coordinates for terrains are so simple to compute that you'll usually\n * want to compute them on your own, if you need them. This option is intended\n * for model viewers which want to offer an easy way to apply textures to\n * terrains.\n * * Property type: bool. Default value: false.\n */\n#define AI_CONFIG_IMPORT_TER_MAKE_UVS \\\n    \"IMPORT_TER_MAKE_UVS\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the ASE loader to always reconstruct normal vectors\n *  basing on the smoothing groups loaded from the file.\n *\n * Some ASE files have carry invalid normals, other don't.\n * * Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS    \\\n    \"IMPORT_ASE_RECONSTRUCT_NORMALS\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the M3D loader to detect and process multi-part\n *    Quake player models.\n *\n * These models usually consist of 3 files, lower.md3, upper.md3 and\n * head.md3. If this property is set to true, Assimp will try to load and\n * combine all three files if one of them is loaded.\n * Property type: bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART \\\n    \"IMPORT_MD3_HANDLE_MULTIPART\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Tells the MD3 loader which skin files to load.\n *\n * When loading MD3 files, Assimp checks whether a file\n * [md3_file_name]_[skin_name].skin is existing. These files are used by\n * Quake III to be able to assign different skins (e.g. red and blue team)\n * to models. 'default', 'red', 'blue' are typical skin names.\n * Property type: String. Default value: \"default\".\n */\n#define AI_CONFIG_IMPORT_MD3_SKIN_NAME \\\n    \"IMPORT_MD3_SKIN_NAME\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Specify the Quake 3 shader file to be used for a particular\n *  MD3 file. This can also be a search path.\n *\n * By default Assimp's behaviour is as follows: If a MD3 file\n * <tt>any_path/models/any_q3_subdir/model_name/file_name.md3</tt> is\n * loaded, the library tries to locate the corresponding shader file in\n * <tt>any_path/scripts/model_name.shader</tt>. This property overrides this\n * behaviour. It can either specify a full path to the shader to be loaded\n * or alternatively the path (relative or absolute) to the directory where\n * the shaders for all MD3s to be loaded reside. Assimp attempts to open\n * <tt>IMPORT_MD3_SHADER_SRC/model_name.shader</tt> first, <tt>IMPORT_MD3_SHADER_SRC/file_name.shader</tt>\n * is the fallback file. Note that IMPORT_MD3_SHADER_SRC should have a terminal (back)slash.\n * Property type: String. Default value: n/a.\n */\n#define AI_CONFIG_IMPORT_MD3_SHADER_SRC \\\n    \"IMPORT_MD3_SHADER_SRC\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the LWO loader to load just one layer from the model.\n *\n * LWO files consist of layers and in some cases it could be useful to load\n * only one of them. This property can be either a string - which specifies\n * the name of the layer - or an integer - the index of the layer. If the\n * property is not set the whole LWO model is loaded. Loading fails if the\n * requested layer is not available. The layer index is zero-based and the\n * layer name may not be empty.<br>\n * Property type: Integer. Default value: all layers are loaded.\n */\n#define AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY         \\\n    \"IMPORT_LWO_ONE_LAYER_ONLY\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Configures the MD5 loader to not load the MD5ANIM file for\n *  a MD5MESH file automatically.\n *\n * The default strategy is to look for a file with the same name but the\n * MD5ANIM extension in the same directory. If it is found, it is loaded\n * and combined with the MD5MESH file. This configuration option can be\n * used to disable this behaviour.\n *\n * * Property type: bool. Default value: false.\n */\n#define AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD           \\\n    \"IMPORT_MD5_NO_ANIM_AUTOLOAD\"\n\n// ---------------------------------------------------------------------------\n/** @brief Defines the begin of the time range for which the LWS loader\n *    evaluates animations and computes aiNodeAnim's.\n *\n * Assimp provides full conversion of LightWave's envelope system, including\n * pre and post conditions. The loader computes linearly subsampled animation\n * chanels with the frame rate given in the LWS file. This property defines\n * the start time. Note: animation channels are only generated if a node\n * has at least one envelope with more tan one key assigned. This property.\n * is given in frames, '0' is the first frame. By default, if this property\n * is not set, the importer takes the animation start from the input LWS\n * file ('FirstFrame' line)<br>\n * Property type: Integer. Default value: taken from file.\n *\n * @see AI_CONFIG_IMPORT_LWS_ANIM_END - end of the imported time range\n */\n#define AI_CONFIG_IMPORT_LWS_ANIM_START         \\\n    \"IMPORT_LWS_ANIM_START\"\n#define AI_CONFIG_IMPORT_LWS_ANIM_END           \\\n    \"IMPORT_LWS_ANIM_END\"\n\n// ---------------------------------------------------------------------------\n/** @brief Defines the output frame rate of the IRR loader.\n *\n * IRR animations are difficult to convert for Assimp and there will\n * always be a loss of quality. This setting defines how many keys per second\n * are returned by the converter.<br>\n * Property type: integer. Default value: 100\n */\n#define AI_CONFIG_IMPORT_IRR_ANIM_FPS               \\\n    \"IMPORT_IRR_ANIM_FPS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Ogre Importer will try to find referenced materials from this file.\n *\n * Ogre meshes reference with material names, this does not tell Assimp the file\n * where it is located in. Assimp will try to find the source file in the following\n * order: <material-name>.material, <mesh-filename-base>.material and\n * lastly the material name defined by this config property.\n * <br>\n * Property type: String. Default value: Scene.material.\n */\n#define AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE \\\n    \"IMPORT_OGRE_MATERIAL_FILE\"\n\n// ---------------------------------------------------------------------------\n/** @brief Ogre Importer detect the texture usage from its filename.\n *\n * Ogre material texture units do not define texture type, the textures usage\n * depends on the used shader or Ogre's fixed pipeline. If this config property\n * is true Assimp will try to detect the type from the textures filename postfix:\n * _n, _nrm, _nrml, _normal, _normals and _normalmap for normal map, _s, _spec,\n * _specular and _specularmap for specular map, _l, _light, _lightmap, _occ\n * and _occlusion for light map, _disp and _displacement for displacement map.\n * The matching is case insensitive. Post fix is taken between the last\n * underscore and the last period.\n * Default behavior is to detect type from lower cased texture unit name by\n * matching against: normalmap, specularmap, lightmap and displacementmap.\n * For both cases if no match is found aiTextureType_DIFFUSE is used.\n * <br>\n * Property type: Bool. Default value: false.\n */\n#define AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME \\\n    \"IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME\"\n\n /** @brief Specifies whether the Android JNI asset extraction is supported.\n  *\n  * Turn on this option if you want to manage assets in native\n  * Android application without having to keep the internal directory and asset\n  * manager pointer.\n  */\n #define AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT \"AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT\"\n\n// ---------------------------------------------------------------------------\n/** @brief Specifies whether the IFC loader skips over IfcSpace elements.\n *\n * IfcSpace elements (and their geometric representations) are used to\n * represent, well, free space in a building storey.<br>\n * Property type: Bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS \"IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS\"\n\n// ---------------------------------------------------------------------------\n/** @brief Specifies whether the IFC loader will use its own, custom triangulation\n *   algorithm to triangulate wall and floor meshes.\n *\n * If this property is set to false, walls will be either triangulated by\n * #aiProcess_Triangulate or will be passed through as huge polygons with\n * faked holes (i.e. holes that are connected with the outer boundary using\n * a dummy edge). It is highly recommended to set this property to true\n * if you want triangulated data because #aiProcess_Triangulate is known to\n * have problems with the kind of polygons that the IFC loader spits out for\n * complicated meshes.\n * Property type: Bool. Default value: true.\n */\n#define AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION \"IMPORT_IFC_CUSTOM_TRIANGULATION\"\n\n// ---------------------------------------------------------------------------\n/** @brief  Set the tessellation conic angle for IFC smoothing curves.\n *\n * This is used by the IFC importer to determine the tessellation parameter\n * for smoothing curves.\n * @note The default value is AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE and the\n * accepted values are in range [5.0, 120.0].\n * Property type: Float.\n */\n#define AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE \"IMPORT_IFC_SMOOTHING_ANGLE\"\n\n// default value for AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE\n#if (!defined AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE)\n#   define AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE 10.0f\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief  Set the tessellation for IFC cylindrical shapes.\n *\n * This is used by the IFC importer to determine the tessellation parameter\n * for cylindrical shapes, i.e. the number of segments used to approximate a circle.\n * @note The default value is AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION and the\n * accepted values are in range [3, 180].\n * Property type: Integer.\n */\n#define AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION \"IMPORT_IFC_CYLINDRICAL_TESSELLATION\"\n\n// default value for AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION\n#if (!defined AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION)\n#   define AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION 32\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief Specifies whether the Collada loader will ignore the provided up direction.\n *\n * If this property is set to true, the up direction provided in the file header will\n * be ignored and the file will be loaded as is.\n * Property type: Bool. Default value: false.\n */\n#define AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION \"IMPORT_COLLADA_IGNORE_UP_DIRECTION\"\n\n// ---------------------------------------------------------------------------\n/** @brief Specifies whether the Collada loader should use Collada names as node names.\n *\n * If this property is set to true, the Collada names will be used as the\n * node name. The default is to use the id tag (resp. sid tag, if no id tag is present)\n * instead.\n * Property type: Bool. Default value: false.\n */\n#define AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES \"IMPORT_COLLADA_USE_COLLADA_NAMES\"\n\n// ---------- All the Export defines ------------\n\n/** @brief Specifies the xfile use double for real values of float\n *\n * Property type: Bool. Default value: false.\n */\n\n#define AI_CONFIG_EXPORT_XFILE_64BIT \"EXPORT_XFILE_64BIT\"\n\n/** @brief Specifies whether the assimp export shall be able to export point clouds\n * \n *  When this flag is not defined the render data has to contain valid faces.\n *  Point clouds are only a collection of vertices which have nor spatial organization\n *  by a face and the validation process will remove them. Enabling this feature will\n *  switch off the flag and enable the functionality to export pure point clouds.\n */\n#define AI_CONFIG_EXPORT_POINT_CLOUDS \"EXPORT_POINT_CLOUDS\"\n\n/**\n *  @brief  Specifies a gobal key factor for scale, float value\n */\n#define AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY \"GLOBAL_SCALE_FACTOR\"\n\n#if (!defined AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT)\n#   define AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT  1.0f\n#endif // !! AI_DEBONE_THRESHOLD\n\n#define AI_CONFIG_APP_SCALE_KEY \"APP_SCALE_FACTOR\"\n\n#if (!defined AI_CONFIG_APP_SCALE_KEY)\n#   define AI_CONFIG_APP_SCALE_KEY 1.0\n#endif // AI_CONFIG_APP_SCALE_KEY\n\n\n// ---------- All the Build/Compile-time defines ------------\n\n/** @brief Specifies if double precision is supported inside assimp\n *\n * Property type: Bool. Default value: undefined.\n */\n\n#cmakedefine ASSIMP_DOUBLE_PRECISION 1\n\n#endif // !! AI_CONFIG_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/config.h.in b/include/assimp/config.h.in
--- a/include/assimp/config.h.in	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/config.h.in	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2018, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -695,6 +695,73 @@
 #define AI_CONFIG_IMPORT_SMD_KEYFRAME       "IMPORT_SMD_KEYFRAME"
 #define AI_CONFIG_IMPORT_UNREAL_KEYFRAME    "IMPORT_UNREAL_KEYFRAME"
 
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read animations.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS "IMPORT_MDL_HL1_READ_ANIMATIONS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read animation events.
+ * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS "IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read blend controllers.
+ * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS "IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read sequence transition graph.
+ * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS "IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read attachments info.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS "IMPORT_MDL_HL1_READ_ATTACHMENTS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read bone controllers info.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS "IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read hitboxes info.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES "IMPORT_MDL_HL1_READ_HITBOXES"
+
+// ---------------------------------------------------------------------------
+/** @brief Set whether the MDL (HL1) importer will read miscellaneous global model info.
+ *
+ * The default value is true (1)
+ * Property type: bool
+ */
+#define AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO "IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"
+
 // ---------------------------------------------------------------------------
 /** Smd load multiple animations
  *
Index: include/assimp/Vertex.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n/** @file Defines a helper class to represent an interleaved vertex\n  along with arithmetic operations to support vertex operations\n  such as subdivision, smoothing etc.\n\n  While the code is kept as general as possible, arithmetic operations\n  that are not currently well-defined (and would cause compile errors\n  due to missing operators in the math library), are commented.\n  */\n#ifndef AI_VERTEX_H_INC\n#define AI_VERTEX_H_INC\n\n#include <assimp/vector3.h>\n#include <assimp/mesh.h>\n#include <assimp/ai_assert.h>\n#include <functional>\n\nnamespace Assimp    {\n\n    ///////////////////////////////////////////////////////////////////////////\n    // std::plus-family operates on operands with identical types - we need to\n    // support all the (vectype op float) combinations in vector maths.\n    // Providing T(float) would open the way to endless implicit conversions.\n    ///////////////////////////////////////////////////////////////////////////\n    namespace Intern {\n        template <typename T0, typename T1, typename TRES = T0> struct plus {\n            TRES operator() (const T0& t0, const T1& t1) const {\n                return t0+t1;\n            }\n        };\n        template <typename T0, typename T1, typename TRES = T0> struct minus {\n            TRES operator() (const T0& t0, const T1& t1) const {\n                return t0-t1;\n            }\n        };\n        template <typename T0, typename T1, typename TRES = T0> struct multiplies {\n            TRES operator() (const T0& t0, const T1& t1) const {\n                return t0*t1;\n            }\n        };\n        template <typename T0, typename T1, typename TRES = T0> struct divides {\n            TRES operator() (const T0& t0, const T1& t1) const {\n                return t0/t1;\n            }\n        };\n    }\n\n// ------------------------------------------------------------------------------------------------\n/** Intermediate description a vertex with all possible components. Defines a full set of\n *  operators, so you may use such a 'Vertex' in basic arithmetics. All operators are applied\n *  to *all* vertex components equally. This is useful for stuff like interpolation\n *  or subdivision, but won't work if special handling is required for some vertex components. */\n// ------------------------------------------------------------------------------------------------\nclass Vertex\n{\n    friend Vertex operator + (const Vertex&,const Vertex&);\n    friend Vertex operator - (const Vertex&,const Vertex&);\n\n//  friend Vertex operator + (const Vertex&,ai_real);\n//  friend Vertex operator - (const Vertex&,ai_real);\n    friend Vertex operator * (const Vertex&,ai_real);\n    friend Vertex operator / (const Vertex&,ai_real);\n\n//  friend Vertex operator + (ai_real, const Vertex&);\n//  friend Vertex operator - (ai_real, const Vertex&);\n    friend Vertex operator * (ai_real, const Vertex&);\n//  friend Vertex operator / (ai_real, const Vertex&);\n\npublic:\n\n    Vertex() {}\n\n    // ----------------------------------------------------------------------------\n    /** Extract a particular vertex from a mesh and interleave all components */\n    explicit Vertex(const aiMesh* msh, unsigned int idx) {\n        ai_assert(idx < msh->mNumVertices);\n        position = msh->mVertices[idx];\n\n        if (msh->HasNormals()) {\n            normal = msh->mNormals[idx];\n        }\n\n        if (msh->HasTangentsAndBitangents()) {\n            tangent = msh->mTangents[idx];\n            bitangent = msh->mBitangents[idx];\n        }\n\n        for (unsigned int i = 0; msh->HasTextureCoords(i); ++i) {\n            texcoords[i] = msh->mTextureCoords[i][idx];\n        }\n\n        for (unsigned int i = 0; msh->HasVertexColors(i); ++i) {\n            colors[i] = msh->mColors[i][idx];\n        }\n    }\n\n    // ----------------------------------------------------------------------------\n    /** Extract a particular vertex from a anim mesh and interleave all components */\n    explicit Vertex(const aiAnimMesh* msh, unsigned int idx) {\n        ai_assert(idx < msh->mNumVertices);\n        position = msh->mVertices[idx];\n\n        if (msh->HasNormals()) {\n            normal = msh->mNormals[idx];\n        }\n\n        if (msh->HasTangentsAndBitangents()) {\n            tangent = msh->mTangents[idx];\n            bitangent = msh->mBitangents[idx];\n        }\n\n        for (unsigned int i = 0; msh->HasTextureCoords(i); ++i) {\n            texcoords[i] = msh->mTextureCoords[i][idx];\n        }\n\n        for (unsigned int i = 0; msh->HasVertexColors(i); ++i) {\n           colors[i] = msh->mColors[i][idx];\n        }\n    }\n\npublic:\n\n    Vertex& operator += (const Vertex& v) {\n        *this = *this+v;\n        return *this;\n    }\n\n    Vertex& operator -= (const Vertex& v) {\n        *this = *this-v;\n        return *this;\n    }\n\n\n/*\n    Vertex& operator += (ai_real v) {\n        *this = *this+v;\n        return *this;\n    }\n\n    Vertex& operator -= (ai_real v) {\n        *this = *this-v;\n        return *this;\n    }\n*/\n    Vertex& operator *= (ai_real v) {\n        *this = *this*v;\n        return *this;\n    }\n\n    Vertex& operator /= (ai_real v) {\n        *this = *this/v;\n        return *this;\n    }\n\npublic:\n\n    // ----------------------------------------------------------------------------\n    /** Convert back to non-interleaved storage */\n    void SortBack(aiMesh* out, unsigned int idx) const {\n\n        ai_assert(idx<out->mNumVertices);\n        out->mVertices[idx] = position;\n\n        if (out->HasNormals()) {\n            out->mNormals[idx] = normal;\n        }\n\n        if (out->HasTangentsAndBitangents()) {\n            out->mTangents[idx] = tangent;\n            out->mBitangents[idx] = bitangent;\n        }\n\n        for(unsigned int i = 0; out->HasTextureCoords(i); ++i) {\n            out->mTextureCoords[i][idx] = texcoords[i];\n        }\n\n        for(unsigned int i = 0; out->HasVertexColors(i); ++i) {\n            out->mColors[i][idx] = colors[i];\n        }\n    }\n\nprivate:\n\n    // ----------------------------------------------------------------------------\n    /** Construct from two operands and a binary operation to combine them */\n    template <template <typename t> class op> static Vertex BinaryOp(const Vertex& v0, const Vertex& v1) {\n        // this is a heavy task for the compiler to optimize ... *pray*\n\n        Vertex res;\n        res.position  = op<aiVector3D>()(v0.position,v1.position);\n        res.normal    = op<aiVector3D>()(v0.normal,v1.normal);\n        res.tangent   = op<aiVector3D>()(v0.tangent,v1.tangent);\n        res.bitangent = op<aiVector3D>()(v0.bitangent,v1.bitangent);\n\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {\n            res.texcoords[i] = op<aiVector3D>()(v0.texcoords[i],v1.texcoords[i]);\n        }\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {\n            res.colors[i] = op<aiColor4D>()(v0.colors[i],v1.colors[i]);\n        }\n        return res;\n    }\n\n    // ----------------------------------------------------------------------------\n    /** This time binary arithmetics of v0 with a floating-point number */\n    template <template <typename, typename, typename> class op> static Vertex BinaryOp(const Vertex& v0, ai_real f) {\n        // this is a heavy task for the compiler to optimize ... *pray*\n\n        Vertex res;\n        res.position  = op<aiVector3D,ai_real,aiVector3D>()(v0.position,f);\n        res.normal    = op<aiVector3D,ai_real,aiVector3D>()(v0.normal,f);\n        res.tangent   = op<aiVector3D,ai_real,aiVector3D>()(v0.tangent,f);\n        res.bitangent = op<aiVector3D,ai_real,aiVector3D>()(v0.bitangent,f);\n\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {\n            res.texcoords[i] = op<aiVector3D,ai_real,aiVector3D>()(v0.texcoords[i],f);\n        }\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {\n            res.colors[i] = op<aiColor4D,ai_real,aiColor4D>()(v0.colors[i],f);\n        }\n        return res;\n    }\n\n    // ----------------------------------------------------------------------------\n    /** This time binary arithmetics of v0 with a floating-point number */\n    template <template <typename, typename, typename> class op> static Vertex BinaryOp(ai_real f, const Vertex& v0) {\n        // this is a heavy task for the compiler to optimize ... *pray*\n\n        Vertex res;\n        res.position  = op<ai_real,aiVector3D,aiVector3D>()(f,v0.position);\n        res.normal    = op<ai_real,aiVector3D,aiVector3D>()(f,v0.normal);\n        res.tangent   = op<ai_real,aiVector3D,aiVector3D>()(f,v0.tangent);\n        res.bitangent = op<ai_real,aiVector3D,aiVector3D>()(f,v0.bitangent);\n\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {\n            res.texcoords[i] = op<ai_real,aiVector3D,aiVector3D>()(f,v0.texcoords[i]);\n        }\n        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {\n            res.colors[i] = op<ai_real,aiColor4D,aiColor4D>()(f,v0.colors[i]);\n        }\n        return res;\n    }\n\npublic:\n\n    aiVector3D position;\n    aiVector3D normal;\n    aiVector3D tangent, bitangent;\n\n    aiVector3D texcoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n    aiColor4D colors[AI_MAX_NUMBER_OF_COLOR_SETS];\n};\n\n\n\n// ------------------------------------------------------------------------------------------------\nAI_FORCE_INLINE Vertex operator + (const Vertex& v0,const Vertex& v1) {\n    return Vertex::BinaryOp<std::plus>(v0,v1);\n}\n\nAI_FORCE_INLINE Vertex operator - (const Vertex& v0,const Vertex& v1) {\n    return Vertex::BinaryOp<std::minus>(v0,v1);\n}\n\n\n// ------------------------------------------------------------------------------------------------\n/*\nAI_FORCE_INLINE Vertex operator + (const Vertex& v0,ai_real f) {\n    return Vertex::BinaryOp<Intern::plus>(v0,f);\n}\n\nAI_FORCE_INLINE Vertex operator - (const Vertex& v0,ai_real f) {\n    return Vertex::BinaryOp<Intern::minus>(v0,f);\n}\n\n*/\n\nAI_FORCE_INLINE Vertex operator * (const Vertex& v0,ai_real f) {\n    return Vertex::BinaryOp<Intern::multiplies>(v0,f);\n}\n\nAI_FORCE_INLINE Vertex operator / (const Vertex& v0,ai_real f) {\n    return Vertex::BinaryOp<Intern::multiplies>(v0,1.f/f);\n}\n\n// ------------------------------------------------------------------------------------------------\n/*\nAI_FORCE_INLINE Vertex operator + (ai_real f,const Vertex& v0) {\n    return Vertex::BinaryOp<Intern::plus>(f,v0);\n}\n\nAI_FORCE_INLINE Vertex operator - (ai_real f,const Vertex& v0) {\n    return Vertex::BinaryOp<Intern::minus>(f,v0);\n}\n*/\n\nAI_FORCE_INLINE Vertex operator * (ai_real f,const Vertex& v0) {\n    return Vertex::BinaryOp<Intern::multiplies>(f,v0);\n}\n\n/*\nAI_FORCE_INLINE Vertex operator / (ai_real f,const Vertex& v0) {\n    return Vertex::BinaryOp<Intern::divides>(f,v0);\n}\n*/\n\n}\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Vertex.h b/include/assimp/Vertex.h
--- a/include/assimp/Vertex.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Vertex.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -47,12 +47,18 @@
   that are not currently well-defined (and would cause compile errors
   due to missing operators in the math library), are commented.
   */
+#pragma once
 #ifndef AI_VERTEX_H_INC
 #define AI_VERTEX_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/vector3.h>
 #include <assimp/mesh.h>
 #include <assimp/ai_assert.h>
+
 #include <functional>
 
 namespace Assimp    {
@@ -91,23 +97,14 @@
  *  to *all* vertex components equally. This is useful for stuff like interpolation
  *  or subdivision, but won't work if special handling is required for some vertex components. */
 // ------------------------------------------------------------------------------------------------
-class Vertex
-{
+class Vertex {
     friend Vertex operator + (const Vertex&,const Vertex&);
     friend Vertex operator - (const Vertex&,const Vertex&);
-
-//  friend Vertex operator + (const Vertex&,ai_real);
-//  friend Vertex operator - (const Vertex&,ai_real);
     friend Vertex operator * (const Vertex&,ai_real);
     friend Vertex operator / (const Vertex&,ai_real);
-
-//  friend Vertex operator + (ai_real, const Vertex&);
-//  friend Vertex operator - (ai_real, const Vertex&);
     friend Vertex operator * (ai_real, const Vertex&);
-//  friend Vertex operator / (ai_real, const Vertex&);
 
 public:
-
     Vertex() {}
 
     // ----------------------------------------------------------------------------
@@ -158,8 +155,6 @@
         }
     }
 
-public:
-
     Vertex& operator += (const Vertex& v) {
         *this = *this+v;
         return *this;
@@ -170,18 +165,6 @@
         return *this;
     }
 
-
-/*
-    Vertex& operator += (ai_real v) {
-        *this = *this+v;
-        return *this;
-    }
-
-    Vertex& operator -= (ai_real v) {
-        *this = *this-v;
-        return *this;
-    }
-*/
     Vertex& operator *= (ai_real v) {
         *this = *this*v;
         return *this;
@@ -192,12 +175,9 @@
         return *this;
     }
 
-public:
-
     // ----------------------------------------------------------------------------
     /** Convert back to non-interleaved storage */
     void SortBack(aiMesh* out, unsigned int idx) const {
-
         ai_assert(idx<out->mNumVertices);
         out->mVertices[idx] = position;
 
@@ -291,8 +271,6 @@
     aiColor4D colors[AI_MAX_NUMBER_OF_COLOR_SETS];
 };
 
-
-
 // ------------------------------------------------------------------------------------------------
 AI_FORCE_INLINE Vertex operator + (const Vertex& v0,const Vertex& v1) {
     return Vertex::BinaryOp<std::plus>(v0,v1);
@@ -302,19 +280,6 @@
     return Vertex::BinaryOp<std::minus>(v0,v1);
 }
 
-
-// ------------------------------------------------------------------------------------------------
-/*
-AI_FORCE_INLINE Vertex operator + (const Vertex& v0,ai_real f) {
-    return Vertex::BinaryOp<Intern::plus>(v0,f);
-}
-
-AI_FORCE_INLINE Vertex operator - (const Vertex& v0,ai_real f) {
-    return Vertex::BinaryOp<Intern::minus>(v0,f);
-}
-
-*/
-
 AI_FORCE_INLINE Vertex operator * (const Vertex& v0,ai_real f) {
     return Vertex::BinaryOp<Intern::multiplies>(v0,f);
 }
@@ -323,26 +288,10 @@
     return Vertex::BinaryOp<Intern::multiplies>(v0,1.f/f);
 }
 
-// ------------------------------------------------------------------------------------------------
-/*
-AI_FORCE_INLINE Vertex operator + (ai_real f,const Vertex& v0) {
-    return Vertex::BinaryOp<Intern::plus>(f,v0);
-}
-
-AI_FORCE_INLINE Vertex operator - (ai_real f,const Vertex& v0) {
-    return Vertex::BinaryOp<Intern::minus>(f,v0);
-}
-*/
-
 AI_FORCE_INLINE Vertex operator * (ai_real f,const Vertex& v0) {
     return Vertex::BinaryOp<Intern::multiplies>(f,v0);
 }
 
-/*
-AI_FORCE_INLINE Vertex operator / (ai_real f,const Vertex& v0) {
-    return Vertex::BinaryOp<Intern::divides>(f,v0);
 }
-*/
 
-}
-#endif
+#endif // AI_VERTEX_H_INC
Index: include/assimp/LogStream.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file LogStream.hpp\n *  @brief Abstract base class 'LogStream', representing an output log stream.\n */\n#ifndef INCLUDED_AI_LOGSTREAM_H\n#define INCLUDED_AI_LOGSTREAM_H\n\n#include \"types.h\"\n\nnamespace Assimp    {\n\nclass IOSystem;\n\n// ------------------------------------------------------------------------------------\n/** @brief CPP-API: Abstract interface for log stream implementations.\n *\n *  Several default implementations are provided, see #aiDefaultLogStream for more\n *  details. Writing your own implementation of LogStream is just necessary if these\n *  are not enough for your purpose. */\nclass ASSIMP_API LogStream\n#ifndef SWIG\n    : public Intern::AllocateFromAssimpHeap\n#endif\n{\nprotected:\n    /** @brief  Default constructor */\n    LogStream() AI_NO_EXCEPT;\n\npublic:\n    /** @brief  Virtual destructor  */\n    virtual ~LogStream();\n\n    // -------------------------------------------------------------------\n    /** @brief  Overwrite this for your own output methods\n     *\n     *  Log messages *may* consist of multiple lines and you shouldn't\n     *  expect a consistent formatting. If you want custom formatting\n     *  (e.g. generate HTML), supply a custom instance of Logger to\n     *  #DefaultLogger:set(). Usually you can *expect* that a log message\n     *  is exactly one line and terminated with a single \\n character.\n     *  @param message Message to be written */\n    virtual void write(const char* message) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Creates a default log stream\n     *  @param streams Type of the default stream\n     *  @param name For aiDefaultLogStream_FILE: name of the output file\n     *  @param io For aiDefaultLogStream_FILE: IOSystem to be used to open the output\n     *   file. Pass NULL for the default implementation.\n     *  @return New LogStream instance.  */\n    static LogStream* createDefaultStream(aiDefaultLogStream stream,\n        const char* name = \"AssimpLog.txt\",\n        IOSystem* io = nullptr );\n\n}; // !class LogStream\n\ninline\nLogStream::LogStream() AI_NO_EXCEPT {\n    // empty\n}\n\ninline\nLogStream::~LogStream() {\n    // empty\n}\n\n// ------------------------------------------------------------------------------------\n} // Namespace Assimp\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/LogStream.hpp b/include/assimp/LogStream.hpp
--- a/include/assimp/LogStream.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/LogStream.hpp	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
Index: include/assimp/MathFunctions.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2016, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n#pragma once\n\n/** @file  MathFunctions.h\n*  @brief Implementation of math utility functions.\n *\n*/\n\n#include <limits>\n\nnamespace Assimp {\nnamespace Math {\n\n// TODO: use binary GCD for unsigned integers ....\ntemplate < typename IntegerType >\ninline\nIntegerType gcd( IntegerType a, IntegerType b ) {\n\tconst IntegerType zero = (IntegerType)0;\n\twhile ( true ) {\n\t\tif ( a == zero )\n\t\t\treturn b;\n\t\tb %= a;\n\n\t\tif ( b == zero )\n\t\t\treturn a;\n\t\ta %= b;\n\t}\n}\n\ntemplate < typename IntegerType >\ninline\nIntegerType lcm( IntegerType a, IntegerType b ) {\n\tconst IntegerType t = gcd (a,b);\n\tif (!t)\n        return t;\n\treturn a / t * b;\n}\n\ntemplate<class T>\ninline\nT getEpsilon() {\n    return std::numeric_limits<T>::epsilon();\n}\n\n}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/MathFunctions.h b/include/assimp/MathFunctions.h
--- a/include/assimp/MathFunctions.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/MathFunctions.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2016, assimp team
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -41,6 +41,10 @@
 
 #pragma once
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 /** @file  MathFunctions.h
 *  @brief Implementation of math utility functions.
  *
Index: include/assimp/DefaultLogger.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n/** @file DefaultLogger.hpp\n*/\n\n#ifndef INCLUDED_AI_DEFAULTLOGGER\n#define INCLUDED_AI_DEFAULTLOGGER\n\n#include \"Logger.hpp\"\n#include \"LogStream.hpp\"\n#include \"NullLogger.hpp\"\n#include <vector>\n\nnamespace Assimp    {\n// ------------------------------------------------------------------------------------\nclass IOStream;\nstruct LogStreamInfo;\n\n/** default name of logfile */\n#define ASSIMP_DEFAULT_LOG_NAME \"AssimpLog.txt\"\n\n// ------------------------------------------------------------------------------------\n/** @brief CPP-API: Primary logging facility of Assimp.\n *\n *  The library stores its primary #Logger as a static member of this class.\n *  #get() returns this primary logger. By default the underlying implementation is\n *  just a #NullLogger which rejects all log messages. By calling #create(), logging\n *  is turned on. To capture the log output multiple log streams (#LogStream) can be\n *  attach to the logger. Some default streams for common streaming locations (such as\n *  a file, std::cout, OutputDebugString()) are also provided.\n *\n *  If you wish to customize the logging at an even deeper level supply your own\n *  implementation of #Logger to #set().\n *  @note The whole logging stuff causes a small extra overhead for all imports. */\nclass ASSIMP_API DefaultLogger :\n    public Logger   {\n\npublic:\n\n    // ----------------------------------------------------------------------\n    /** @brief Creates a logging instance.\n     *  @param name Name for log file. Only valid in combination\n     *    with the aiDefaultLogStream_FILE flag.\n     *  @param severity Log severity, VERBOSE turns on debug messages\n     *  @param defStreams  Default log streams to be attached. Any bitwise\n     *    combination of the aiDefaultLogStream enumerated values.\n     *    If #aiDefaultLogStream_FILE is specified but an empty string is\n     *    passed for 'name', no log file is created at all.\n     *  @param  io IOSystem to be used to open external files (such as the\n     *   log file). Pass NULL to rely on the default implementation.\n     *  This replaces the default #NullLogger with a #DefaultLogger instance. */\n    static Logger *create(const char* name = ASSIMP_DEFAULT_LOG_NAME,\n        LogSeverity severity    = NORMAL,\n        unsigned int defStreams = aiDefaultLogStream_DEBUGGER | aiDefaultLogStream_FILE,\n        IOSystem* io            = NULL);\n\n    // ----------------------------------------------------------------------\n    /** @brief Setup a custom #Logger implementation.\n     *\n     *  Use this if the provided #DefaultLogger class doesn't fit into\n     *  your needs. If the provided message formatting is OK for you,\n     *  it's much easier to use #create() and to attach your own custom\n     *  output streams to it.\n     *  @param logger Pass NULL to setup a default NullLogger*/\n    static void set (Logger *logger);\n\n    // ----------------------------------------------------------------------\n    /** @brief  Getter for singleton instance\n     *   @return Only instance. This is never null, but it could be a\n     *  NullLogger. Use isNullLogger to check this.*/\n    static Logger *get();\n\n    // ----------------------------------------------------------------------\n    /** @brief  Return whether a #NullLogger is currently active\n     *  @return true if the current logger is a #NullLogger.\n     *  Use create() or set() to setup a logger that does actually do\n     *  something else than just rejecting all log messages. */\n    static bool isNullLogger();\n\n    // ----------------------------------------------------------------------\n    /** @brief  Kills the current singleton logger and replaces it with a\n     *  #NullLogger instance. */\n    static void kill();\n\n    // ----------------------------------------------------------------------\n    /** @copydoc Logger::attachStream   */\n    bool attachStream(LogStream *pStream,\n        unsigned int severity);\n\n    // ----------------------------------------------------------------------\n    /** @copydoc Logger::detatchStream */\n    bool detatchStream(LogStream *pStream,\n        unsigned int severity);\n\nprivate:\n    // ----------------------------------------------------------------------\n    /** @briefPrivate construction for internal use by create().\n     *  @param severity Logging granularity  */\n    explicit DefaultLogger(LogSeverity severity);\n\n    // ----------------------------------------------------------------------\n    /** @briefDestructor    */\n    ~DefaultLogger();\n\n    /** @brief  Logs debug infos, only been written when severity level VERBOSE is set */\n    void OnDebug(const char* message);\n\n    /** @brief  Logs an info message */\n    void OnInfo(const char*  message);\n\n    /** @brief  Logs a warning message */\n    void OnWarn(const char*  message);\n\n    /** @brief  Logs an error message */\n    void OnError(const char* message);\n\n    // ----------------------------------------------------------------------\n    /** @brief Writes a message to all streams */\n    void WriteToStreams(const char* message, ErrorSeverity ErrorSev );\n\n    // ----------------------------------------------------------------------\n    /** @brief Returns the thread id.\n     *  @note This is an OS specific feature, if not supported, a\n     *    zero will be returned.\n     */\n    unsigned int GetThreadID();\n\nprivate:\n    //  Aliases for stream container\n    typedef std::vector<LogStreamInfo*> StreamArray;\n    typedef std::vector<LogStreamInfo*>::iterator StreamIt;\n    typedef std::vector<LogStreamInfo*>::const_iterator ConstStreamIt;\n\n    //! only logging instance\n    static Logger *m_pLogger;\n    static NullLogger s_pNullLogger;\n\n    //! Attached streams\n    StreamArray m_StreamArray;\n\n    bool noRepeatMsg;\n    char lastMsg[MAX_LOG_MESSAGE_LENGTH*2];\n    size_t lastLen;\n};\n// ------------------------------------------------------------------------------------\n\n} // Namespace Assimp\n\n#endif // !! INCLUDED_AI_DEFAULTLOGGER\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/DefaultLogger.hpp b/include/assimp/DefaultLogger.hpp
--- a/include/assimp/DefaultLogger.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/DefaultLogger.hpp	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
Index: include/assimp/Logger.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Logger.hpp\n *  @brief Abstract base class 'Logger', base of the logging system.\n */\n#ifndef INCLUDED_AI_LOGGER_H\n#define INCLUDED_AI_LOGGER_H\n\n#include <assimp/types.h>\n#include <assimp/TinyFormatter.h>\n\nnamespace Assimp {\n\nclass LogStream;\n\n// Maximum length of a log message. Longer messages are rejected.\n#define MAX_LOG_MESSAGE_LENGTH 1024u\n\n// ----------------------------------------------------------------------------------\n/** @brief CPP-API: Abstract interface for logger implementations.\n *  Assimp provides a default implementation and uses it for almost all\n *  logging stuff ('DefaultLogger'). This class defines just basic logging\n *  behavior and is not of interest for you. Instead, take a look at #DefaultLogger. */\nclass ASSIMP_API Logger\n#ifndef SWIG\n    : public Intern::AllocateFromAssimpHeap\n#endif\n{\npublic:\n\n    // ----------------------------------------------------------------------\n    /** @enum   LogSeverity\n     *  @brief  Log severity to describe the granularity of logging.\n     */\n    enum LogSeverity {\n        NORMAL,     //!< Normal granularity of logging\n        VERBOSE     //!< Debug infos will be logged, too\n    };\n\n    // ----------------------------------------------------------------------\n    /** @enum   ErrorSeverity\n     *  @brief  Description for severity of a log message.\n     *\n     *  Every LogStream has a bitwise combination of these flags.\n     *  A LogStream doesn't receive any messages of a specific type\n     *  if it doesn't specify the corresponding ErrorSeverity flag.\n     */\n    enum ErrorSeverity {\n        Debugging   = 1,    //!< Debug log message\n        Info        = 2,    //!< Info log message\n        Warn        = 4,    //!< Warn log message\n        Err         = 8     //!< Error log message\n    };\n\npublic:\n\n    /** @brief  Virtual destructor */\n    virtual ~Logger();\n\n    // ----------------------------------------------------------------------\n    /** @brief  Writes a debug message\n     *   @param message Debug message*/\n    void debug(const char* message);\n    void debug(const std::string &message);\n\n    // ----------------------------------------------------------------------\n    /** @brief  Writes a info message\n     *  @param  message Info message*/\n    void info(const char* message);\n    void info(const std::string &message);\n\n    // ----------------------------------------------------------------------\n    /** @brief  Writes a warning message\n     *  @param  message Warn message*/\n    void warn(const char* message);\n    void warn(const std::string &message);\n\n    // ----------------------------------------------------------------------\n    /** @brief  Writes an error message\n     *  @param  message Error message*/\n    void error(const char* message);\n    void error(const std::string &message);\n\n    // ----------------------------------------------------------------------\n    /** @brief  Set a new log severity.\n     *  @param  log_severity New severity for logging*/\n    void setLogSeverity(LogSeverity log_severity);\n\n    // ----------------------------------------------------------------------\n    /** @brief Get the current log severity*/\n    LogSeverity getLogSeverity() const;\n\n    // ----------------------------------------------------------------------\n    /** @brief  Attach a new log-stream\n     *\n     *  The logger takes ownership of the stream and is responsible\n     *  for its destruction (which is done using ::delete when the logger\n     *  itself is destroyed). Call detachStream to detach a stream and to\n     *  gain ownership of it again.\n     *   @param pStream  Log-stream to attach\n     *  @param severity  Message filter, specified which types of log\n     *    messages are dispatched to the stream. Provide a bitwise\n     *    combination of the ErrorSeverity flags.\n     *  @return true if the stream has been attached, false otherwise.*/\n    virtual bool attachStream(LogStream *pStream,\n        unsigned int severity = Debugging | Err | Warn | Info) = 0;\n\n    // ----------------------------------------------------------------------\n    /** @brief  Detach a still attached stream from the logger (or\n     *          modify the filter flags bits)\n     *   @param pStream Log-stream instance for detaching\n     *  @param severity Provide a bitwise combination of the ErrorSeverity\n     *    flags. This value is &~ed with the current flags of the stream,\n     *    if the result is 0 the stream is detached from the Logger and\n     *    the caller retakes the possession of the stream.\n     *  @return true if the stream has been detached, false otherwise.*/\n    virtual bool detatchStream(LogStream *pStream,\n        unsigned int severity = Debugging | Err | Warn | Info) = 0;\n\nprotected:\n    /**\n     *  Default constructor\n     */\n    Logger() AI_NO_EXCEPT;\n\n    /**\n     *  Construction with a given log severity\n     */\n    explicit Logger(LogSeverity severity);\n\n    // ----------------------------------------------------------------------\n    /**\n     *  @brief Called as a request to write a specific debug message\n     *  @param  message Debug message. Never longer than\n     *    MAX_LOG_MESSAGE_LENGTH characters (excluding the '0').\n     *  @note  The message string is only valid until the scope of\n     *    the function is left.\n     */\n    virtual void OnDebug(const char* message)= 0;\n\n    // ----------------------------------------------------------------------\n    /**\n     *  @brief Called as a request to write a specific info message\n     *  @param  message Info message. Never longer than\n     *    MAX_LOG_MESSAGE_LENGTH characters (ecxluding the '0').\n     *  @note  The message string is only valid until the scope of\n     *    the function is left.\n     */\n    virtual void OnInfo(const char* message) = 0;\n\n    // ----------------------------------------------------------------------\n    /**\n     *  @brief Called as a request to write a specific warn message\n     *  @param  message Warn message. Never longer than\n     *    MAX_LOG_MESSAGE_LENGTH characters (exluding the '0').\n     *  @note  The message string is only valid until the scope of\n     *    the function is left.\n     */\n    virtual void OnWarn(const char* essage) = 0;\n\n    // ----------------------------------------------------------------------\n    /**\n     *  @brief Called as a request to write a specific error message\n     *  @param  message Error message. Never longer than\n     *    MAX_LOG_MESSAGE_LENGTH characters (exluding the '0').\n     *  @note  The message string is only valid until the scope of\n     *    the function is left.\n     */\n    virtual void OnError(const char* message) = 0;\n\nprotected:\n    LogSeverity m_Severity;\n};\n\n// ----------------------------------------------------------------------------------\n//  Default constructor\ninline\nLogger::Logger() AI_NO_EXCEPT\n: m_Severity(NORMAL) {\n    // empty\n}\n\n// ----------------------------------------------------------------------------------\n//  Virtual destructor\ninline\nLogger::~Logger() {\n    // empty\n}\n\n// ----------------------------------------------------------------------------------\n// Construction with given logging severity\ninline\nLogger::Logger(LogSeverity severity)\n: m_Severity(severity) {\n    // empty\n}\n\n// ----------------------------------------------------------------------------------\n// Log severity setter\ninline\nvoid Logger::setLogSeverity(LogSeverity log_severity){\n    m_Severity = log_severity;\n}\n\n// ----------------------------------------------------------------------------------\n// Log severity getter\ninline\nLogger::LogSeverity Logger::getLogSeverity() const {\n    return m_Severity;\n}\n\n// ----------------------------------------------------------------------------------\ninline\nvoid Logger::debug(const std::string &message) {\n    return debug(message.c_str());\n}\n\n// ----------------------------------------------------------------------------------\ninline\nvoid Logger::error(const std::string &message) {\n    return error(message.c_str());\n}\n\n// ----------------------------------------------------------------------------------\ninline\nvoid Logger::warn(const std::string &message) {\n    return warn(message.c_str());\n}\n\n// ----------------------------------------------------------------------------------\ninline\nvoid Logger::info(const std::string &message) {\n    return info(message.c_str());\n}\n\n// ------------------------------------------------------------------------------------------------\n#define ASSIMP_LOG_WARN_F(string,...)\\\n    DefaultLogger::get()->warn((Formatter::format(string),__VA_ARGS__))\n\n#define ASSIMP_LOG_ERROR_F(string,...)\\\n    DefaultLogger::get()->error((Formatter::format(string),__VA_ARGS__))\n\n#define ASSIMP_LOG_DEBUG_F(string,...)\\\n    DefaultLogger::get()->debug((Formatter::format(string),__VA_ARGS__))\n\n#define ASSIMP_LOG_INFO_F(string,...)\\\n    DefaultLogger::get()->info((Formatter::format(string),__VA_ARGS__))\n\n\n#define ASSIMP_LOG_WARN(string)\\\n    DefaultLogger::get()->warn(string)\n\n#define ASSIMP_LOG_ERROR(string)\\\n    DefaultLogger::get()->error(string)\n\n#define ASSIMP_LOG_DEBUG(string)\\\n    DefaultLogger::get()->debug(string)\n\n#define ASSIMP_LOG_INFO(string)\\\n    DefaultLogger::get()->info(string)\n\n\n} // Namespace Assimp\n\n#endif // !! INCLUDED_AI_LOGGER_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Logger.hpp b/include/assimp/Logger.hpp
--- a/include/assimp/Logger.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Logger.hpp	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
Index: include/assimp/ByteSwapper.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Helper class tp perform various byte oder swappings\n   (e.g. little to big endian) */\n#ifndef AI_BYTESWAPPER_H_INC\n#define AI_BYTESWAPPER_H_INC\n\n#include <assimp/ai_assert.h>\n#include <assimp/types.h>\n#include <stdint.h>\n\n#if _MSC_VER >= 1400\n#include <stdlib.h>\n#endif\n\nnamespace Assimp    {\n// --------------------------------------------------------------------------------------\n/** Defines some useful byte order swap routines.\n *\n * This is required to read big-endian model formats on little-endian machines,\n * and vice versa. Direct use of this class is DEPRECATED. Use #StreamReader instead. */\n// --------------------------------------------------------------------------------------\nclass ByteSwap {\n    ByteSwap() AI_NO_EXCEPT {}\n\npublic:\n\n    // ----------------------------------------------------------------------\n    /** Swap two bytes of data\n     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */\n    static inline void Swap2(void* _szOut)\n    {\n        ai_assert(_szOut);\n\n#if _MSC_VER >= 1400\n        uint16_t* const szOut = reinterpret_cast<uint16_t*>(_szOut);\n        *szOut = _byteswap_ushort(*szOut);\n#else\n        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);\n        std::swap(szOut[0],szOut[1]);\n#endif\n    }\n\n    // ----------------------------------------------------------------------\n    /** Swap four bytes of data\n     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */\n    static inline void Swap4(void* _szOut)\n    {\n        ai_assert(_szOut);\n\n#if _MSC_VER >= 1400\n        uint32_t* const szOut = reinterpret_cast<uint32_t*>(_szOut);\n        *szOut = _byteswap_ulong(*szOut);\n#else\n        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);\n        std::swap(szOut[0],szOut[3]);\n        std::swap(szOut[1],szOut[2]);\n#endif\n    }\n\n    // ----------------------------------------------------------------------\n    /** Swap eight bytes of data\n     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */\n    static inline void Swap8(void* _szOut)\n    {\n    ai_assert(_szOut);\n\n#if _MSC_VER >= 1400\n        uint64_t* const szOut = reinterpret_cast<uint64_t*>(_szOut);\n        *szOut = _byteswap_uint64(*szOut);\n#else\n        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);\n        std::swap(szOut[0],szOut[7]);\n        std::swap(szOut[1],szOut[6]);\n        std::swap(szOut[2],szOut[5]);\n        std::swap(szOut[3],szOut[4]);\n#endif\n    }\n\n    // ----------------------------------------------------------------------\n    /** ByteSwap a float. Not a joke.\n     *  @param[inout] fOut ehm. .. */\n    static inline void Swap(float* fOut) {\n        Swap4(fOut);\n    }\n\n    // ----------------------------------------------------------------------\n    /** ByteSwap a double. Not a joke.\n     *  @param[inout] fOut ehm. .. */\n    static inline void Swap(double* fOut) {\n        Swap8(fOut);\n    }\n\n\n    // ----------------------------------------------------------------------\n    /** ByteSwap an int16t. Not a joke.\n     *  @param[inout] fOut ehm. .. */\n    static inline void Swap(int16_t* fOut) {\n        Swap2(fOut);\n    }\n\n    static inline void Swap(uint16_t* fOut) {\n        Swap2(fOut);\n    }\n\n    // ----------------------------------------------------------------------\n    /** ByteSwap an int32t. Not a joke.\n     *  @param[inout] fOut ehm. .. */\n    static inline void Swap(int32_t* fOut){\n        Swap4(fOut);\n    }\n\n    static inline void Swap(uint32_t* fOut){\n        Swap4(fOut);\n    }\n\n    // ----------------------------------------------------------------------\n    /** ByteSwap an int64t. Not a joke.\n     *  @param[inout] fOut ehm. .. */\n    static inline void Swap(int64_t* fOut) {\n        Swap8(fOut);\n    }\n\n    static inline void Swap(uint64_t* fOut) {\n        Swap8(fOut);\n    }\n\n    // ----------------------------------------------------------------------\n    //! Templatized ByteSwap\n    //! \\returns param tOut as swapped\n    template<typename Type>\n    static inline Type Swapped(Type tOut)\n    {\n        return _swapper<Type,sizeof(Type)>()(tOut);\n    }\n\nprivate:\n\n    template <typename T, size_t size> struct _swapper;\n};\n\ntemplate <typename T> struct ByteSwap::_swapper<T,2> {\n    T operator() (T tOut) {\n        Swap2(&tOut);\n        return tOut;\n    }\n};\n\ntemplate <typename T> struct ByteSwap::_swapper<T,4> {\n    T operator() (T tOut) {\n        Swap4(&tOut);\n        return tOut;\n    }\n};\n\ntemplate <typename T> struct ByteSwap::_swapper<T,8> {\n    T operator() (T tOut) {\n        Swap8(&tOut);\n        return tOut;\n    }\n};\n\n\n// --------------------------------------------------------------------------------------\n// ByteSwap macros for BigEndian/LittleEndian support\n// --------------------------------------------------------------------------------------\n#if (defined AI_BUILD_BIG_ENDIAN)\n#   define AI_LE(t) (t)\n#   define AI_BE(t) ByteSwap::Swapped(t)\n#   define AI_LSWAP2(p)\n#   define AI_LSWAP4(p)\n#   define AI_LSWAP8(p)\n#   define AI_LSWAP2P(p)\n#   define AI_LSWAP4P(p)\n#   define AI_LSWAP8P(p)\n#   define LE_NCONST const\n#   define AI_SWAP2(p) ByteSwap::Swap2(&(p))\n#   define AI_SWAP4(p) ByteSwap::Swap4(&(p))\n#   define AI_SWAP8(p) ByteSwap::Swap8(&(p))\n#   define AI_SWAP2P(p) ByteSwap::Swap2((p))\n#   define AI_SWAP4P(p) ByteSwap::Swap4((p))\n#   define AI_SWAP8P(p) ByteSwap::Swap8((p))\n#   define BE_NCONST\n#else\n#   define AI_BE(t) (t)\n#   define AI_LE(t) ByteSwap::Swapped(t)\n#   define AI_SWAP2(p)\n#   define AI_SWAP4(p)\n#   define AI_SWAP8(p)\n#   define AI_SWAP2P(p)\n#   define AI_SWAP4P(p)\n#   define AI_SWAP8P(p)\n#   define BE_NCONST const\n#   define AI_LSWAP2(p)     ByteSwap::Swap2(&(p))\n#   define AI_LSWAP4(p)     ByteSwap::Swap4(&(p))\n#   define AI_LSWAP8(p)     ByteSwap::Swap8(&(p))\n#   define AI_LSWAP2P(p)    ByteSwap::Swap2((p))\n#   define AI_LSWAP4P(p)    ByteSwap::Swap4((p))\n#   define AI_LSWAP8P(p)    ByteSwap::Swap8((p))\n#   define LE_NCONST\n#endif\n\n\nnamespace Intern {\n\n// --------------------------------------------------------------------------------------------\ntemplate <typename T, bool doit>\nstruct ByteSwapper  {\n    void operator() (T* inout) {\n        ByteSwap::Swap(inout);\n    }\n};\n\ntemplate <typename T>\nstruct ByteSwapper<T,false> {\n    void operator() (T*) {\n    }\n};\n\n// --------------------------------------------------------------------------------------------\ntemplate <bool SwapEndianess, typename T, bool RuntimeSwitch>\nstruct Getter {\n    void operator() (T* inout, bool le) {\n#ifdef AI_BUILD_BIG_ENDIAN\n        le =  le;\n#else\n        le =  !le;\n#endif\n        if (le) {\n            ByteSwapper<T,(sizeof(T)>1?true:false)> () (inout);\n        }\n        else ByteSwapper<T,false> () (inout);\n    }\n};\n\ntemplate <bool SwapEndianess, typename T>\nstruct Getter<SwapEndianess,T,false> {\n\n    void operator() (T* inout, bool /*le*/) {\n        // static branch\n        ByteSwapper<T,(SwapEndianess && sizeof(T)>1)> () (inout);\n    }\n};\n} // end Intern\n} // end Assimp\n\n#endif //!! AI_BYTESWAPPER_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/ByteSwapper.h b/include/assimp/ByteSwapper.h
--- a/include/assimp/ByteSwapper.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/ByteSwapper.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -42,9 +42,14 @@
 
 /** @file Helper class tp perform various byte oder swappings
    (e.g. little to big endian) */
+#pragma once
 #ifndef AI_BYTESWAPPER_H_INC
 #define AI_BYTESWAPPER_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/ai_assert.h>
 #include <assimp/types.h>
 #include <stdint.h>
Index: include/assimp/StreamReader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Defines the StreamReader class which reads data from\n *  a binary stream with a well-defined endianness.\n */\n\n#ifndef AI_STREAMREADER_H_INCLUDED\n#define AI_STREAMREADER_H_INCLUDED\n\n#include <assimp/IOStream.hpp>\n#include <assimp/Defines.h>\n\n#include \"ByteSwapper.h\"\n#include \"Exceptional.h\"\n#include <memory>\n\nnamespace Assimp {\n\n// --------------------------------------------------------------------------------------------\n/** Wrapper class around IOStream to allow for consistent reading of binary data in both\n *  little and big endian format. Don't attempt to instance the template directly. Use\n *  StreamReaderLE to read from a little-endian stream and StreamReaderBE to read from a\n *  BE stream. The class expects that the endianness of any input data is known at\n *  compile-time, which should usually be true (#BaseImporter::ConvertToUTF8 implements\n *  runtime endianness conversions for text files).\n *\n *  XXX switch from unsigned int for size types to size_t? or ptrdiff_t?*/\n// --------------------------------------------------------------------------------------------\ntemplate <bool SwapEndianess = false, bool RuntimeSwitch = false>\nclass StreamReader {\npublic:\n    // FIXME: use these data types throughout the whole library,\n    // then change them to 64 bit values :-)\n    using diff = int;\n    using pos  = unsigned int;\n\n    // ---------------------------------------------------------------------\n    /** Construction from a given stream with a well-defined endianness.\n     *\n     *  The StreamReader holds a permanent strong reference to the\n     *  stream, which is released upon destruction.\n     *  @param stream Input stream. The stream is not restarted if\n     *    its file pointer is not at 0. Instead, the stream reader\n     *    reads from the current position to the end of the stream.\n     *  @param le If @c RuntimeSwitch is true: specifies whether the\n     *    stream is in little endian byte order. Otherwise the\n     *    endianness information is contained in the @c SwapEndianess\n     *    template parameter and this parameter is meaningless.  */\n    StreamReader(std::shared_ptr<IOStream> stream, bool le = false)\n        : stream(stream)\n        , le(le)\n    {\n        ai_assert(stream);\n        InternBegin();\n    }\n\n    // ---------------------------------------------------------------------\n    StreamReader(IOStream* stream, bool le = false)\n        : stream(std::shared_ptr<IOStream>(stream))\n        , le(le)\n    {\n        ai_assert(stream);\n        InternBegin();\n    }\n\n    // ---------------------------------------------------------------------\n    ~StreamReader() {\n        delete[] buffer;\n    }\n\n    // deprecated, use overloaded operator>> instead\n\n    // ---------------------------------------------------------------------\n    /** Read a float from the stream  */\n    float GetF4()\n    {\n        return Get<float>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a double from the stream  */\n    double GetF8()  {\n        return Get<double>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a signed 16 bit integer from the stream */\n    int16_t GetI2() {\n        return Get<int16_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a signed 8 bit integer from the stream */\n    int8_t GetI1()  {\n        return Get<int8_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read an signed 32 bit integer from the stream */\n    int32_t GetI4() {\n        return Get<int32_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a signed 64 bit integer from the stream */\n    int64_t GetI8() {\n        return Get<int64_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a unsigned 16 bit integer from the stream */\n    uint16_t GetU2()    {\n        return Get<uint16_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a unsigned 8 bit integer from the stream */\n    uint8_t GetU1() {\n        return Get<uint8_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read an unsigned 32 bit integer from the stream */\n    uint32_t GetU4()    {\n        return Get<uint32_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Read a unsigned 64 bit integer from the stream */\n    uint64_t GetU8()    {\n        return Get<uint64_t>();\n    }\n\n    // ---------------------------------------------------------------------\n    /** Get the remaining stream size (to the end of the stream) */\n    unsigned int GetRemainingSize() const {\n        return (unsigned int)(end - current);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Get the remaining stream size (to the current read limit). The\n     *  return value is the remaining size of the stream if no custom\n     *  read limit has been set. */\n    unsigned int GetRemainingSizeToLimit() const {\n        return (unsigned int)(limit - current);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Increase the file pointer (relative seeking)  */\n    void IncPtr(intptr_t plus)    {\n        current += plus;\n        if (current > limit) {\n            throw DeadlyImportError(\"End of file or read limit was reached\");\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    /** Get the current file pointer */\n    int8_t* GetPtr() const  {\n        return current;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Set current file pointer (Get it from #GetPtr). This is if you\n     *  prefer to do pointer arithmetics on your own or want to copy\n     *  large chunks of data at once.\n     *  @param p The new pointer, which is validated against the size\n     *    limit and buffer boundaries. */\n    void SetPtr(int8_t* p)  {\n        current = p;\n        if (current > limit || current < buffer) {\n            throw DeadlyImportError(\"End of file or read limit was reached\");\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    /** Copy n bytes to an external buffer\n     *  @param out Destination for copying\n     *  @param bytes Number of bytes to copy */\n    void CopyAndAdvance(void* out, size_t bytes)    {\n        int8_t* ur = GetPtr();\n        SetPtr(ur+bytes); // fire exception if eof\n\n        ::memcpy(out,ur,bytes);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Get the current offset from the beginning of the file */\n    int GetCurrentPos() const   {\n        return (unsigned int)(current - buffer);\n    }\n\n    void SetCurrentPos(size_t pos) {\n        SetPtr(buffer + pos);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Setup a temporary read limit\n     *\n     *  @param limit Maximum number of bytes to be read from\n     *    the beginning of the file. Specifying UINT_MAX\n     *    resets the limit to the original end of the stream.\n     *  Returns the previously set limit. */\n    unsigned int SetReadLimit(unsigned int _limit)  {\n        unsigned int prev = GetReadLimit();\n        if (UINT_MAX == _limit) {\n            limit = end;\n            return prev;\n        }\n\n        limit = buffer + _limit;\n        if (limit > end) {\n            throw DeadlyImportError(\"StreamReader: Invalid read limit\");\n        }\n        return prev;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Get the current read limit in bytes. Reading over this limit\n     *  accidentally raises an exception.  */\n    unsigned int GetReadLimit() const    {\n        return (unsigned int)(limit - buffer);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Skip to the read limit in bytes. Reading over this limit\n     *  accidentally raises an exception. */\n    void SkipToReadLimit()  {\n        current = limit;\n    }\n\n    // ---------------------------------------------------------------------\n    /** overload operator>> and allow chaining of >> ops. */\n    template <typename T>\n    StreamReader& operator >> (T& f) {\n        f = Get<T>();\n        return *this;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Generic read method. ByteSwap::Swap(T*) *must* be defined */\n    template <typename T>\n    T Get() {\n        if ( current + sizeof(T) > limit) {\n            throw DeadlyImportError(\"End of file or stream limit was reached\");\n        }\n\n        T f;\n        ::memcpy (&f, current, sizeof(T));\n        Intern::Getter<SwapEndianess,T,RuntimeSwitch>() (&f,le);\n        current += sizeof(T);\n\n        return f;\n    }\n\nprivate:\n    // ---------------------------------------------------------------------\n    void InternBegin() {\n        if (!stream) {\n            // in case someone wonders: StreamReader is frequently invoked with\n            // no prior validation whether the input stream is valid. Since\n            // no one bothers changing the error message, this message here\n            // is passed down to the caller and 'unable to open file'\n            // simply describes best what happened.\n            throw DeadlyImportError(\"StreamReader: Unable to open file\");\n        }\n\n        const size_t s = stream->FileSize() - stream->Tell();\n        if (!s) {\n            throw DeadlyImportError(\"StreamReader: File is empty or EOF is already reached\");\n        }\n\n        current = buffer = new int8_t[s];\n        const size_t read = stream->Read(current,1,s);\n        // (read < s) can only happen if the stream was opened in text mode, in which case FileSize() is not reliable\n        ai_assert(read <= s);\n        end = limit = &buffer[read-1] + 1;\n    }\n\nprivate:\n    std::shared_ptr<IOStream> stream;\n    int8_t *buffer, *current, *end, *limit;\n    bool le;\n};\n\n// --------------------------------------------------------------------------------------------\n// `static` StreamReaders. Their byte order is fixed and they might be a little bit faster.\n#ifdef AI_BUILD_BIG_ENDIAN\n    typedef StreamReader<true>  StreamReaderLE;\n    typedef StreamReader<false> StreamReaderBE;\n#else\n    typedef StreamReader<true>  StreamReaderBE;\n    typedef StreamReader<false> StreamReaderLE;\n#endif\n\n// `dynamic` StreamReader. The byte order of the input data is specified in the\n// c'tor. This involves runtime branching and might be a little bit slower.\ntypedef StreamReader<true,true> StreamReaderAny;\n\n} // end namespace Assimp\n\n#endif // !! AI_STREAMREADER_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/StreamReader.h b/include/assimp/StreamReader.h
--- a/include/assimp/StreamReader.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/StreamReader.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -44,15 +44,19 @@
 /** @file Defines the StreamReader class which reads data from
  *  a binary stream with a well-defined endianness.
  */
-
+#pragma once
 #ifndef AI_STREAMREADER_H_INCLUDED
 #define AI_STREAMREADER_H_INCLUDED
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/IOStream.hpp>
 #include <assimp/Defines.h>
+#include <assimp/ByteSwapper.h>
+#include <assimp/Exceptional.h>
 
-#include "ByteSwapper.h"
-#include "Exceptional.h"
 #include <memory>
 
 namespace Assimp {
Index: include/assimp/vector3.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  vector3.inl\n *  @brief Inline implementation of aiVector3t<TReal> operators\n */\n#pragma once\n#ifndef AI_VECTOR3D_INL_INC\n#define AI_VECTOR3D_INL_INC\n\n#ifdef __cplusplus\n#include \"vector3.h\"\n\n#include <cmath>\n\n// ------------------------------------------------------------------------------------------------\n/** Transformation of a vector by a 3x3 matrix */\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator * (const aiMatrix3x3t<TReal>& pMatrix, const aiVector3t<TReal>& pVector) {\n    aiVector3t<TReal> res;\n    res.x = pMatrix.a1 * pVector.x + pMatrix.a2 * pVector.y + pMatrix.a3 * pVector.z;\n    res.y = pMatrix.b1 * pVector.x + pMatrix.b2 * pVector.y + pMatrix.b3 * pVector.z;\n    res.z = pMatrix.c1 * pVector.x + pMatrix.c2 * pVector.y + pMatrix.c3 * pVector.z;\n    return res;\n}\n\n// ------------------------------------------------------------------------------------------------\n/** Transformation of a vector by a 4x4 matrix */\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator * (const aiMatrix4x4t<TReal>& pMatrix, const aiVector3t<TReal>& pVector) {\n    aiVector3t<TReal> res;\n    res.x = pMatrix.a1 * pVector.x + pMatrix.a2 * pVector.y + pMatrix.a3 * pVector.z + pMatrix.a4;\n    res.y = pMatrix.b1 * pVector.x + pMatrix.b2 * pVector.y + pMatrix.b3 * pVector.z + pMatrix.b4;\n    res.z = pMatrix.c1 * pVector.x + pMatrix.c2 * pVector.y + pMatrix.c3 * pVector.z + pMatrix.c4;\n    return res;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ntemplate <typename TOther>\naiVector3t<TReal>::operator aiVector3t<TOther> () const {\n    return aiVector3t<TOther>(static_cast<TOther>(x),static_cast<TOther>(y),static_cast<TOther>(z));\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nvoid aiVector3t<TReal>::Set( TReal pX, TReal pY, TReal pZ) {\n    x = pX;\n    y = pY;\n    z = pZ;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nTReal aiVector3t<TReal>::SquareLength() const {\n    return x*x + y*y + z*z;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nTReal aiVector3t<TReal>::Length() const {\n    return std::sqrt( SquareLength());\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal>& aiVector3t<TReal>::Normalize() {\n    *this /= Length();\n\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal>& aiVector3t<TReal>::NormalizeSafe() {\n    TReal len = Length();\n    if ( len > static_cast< TReal >( 0 ) ) {\n        *this /= len;\n    }\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nconst aiVector3t<TReal>& aiVector3t<TReal>::operator += (const aiVector3t<TReal>& o) {\n    x += o.x;\n    y += o.y;\n    z += o.z;\n\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nconst aiVector3t<TReal>& aiVector3t<TReal>::operator -= (const aiVector3t<TReal>& o) {\n    x -= o.x;\n    y -= o.y;\n    z -= o.z;\n\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nconst aiVector3t<TReal>& aiVector3t<TReal>::operator *= (TReal f) {\n    x *= f;\n    y *= f;\n    z *= f;\n\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nconst aiVector3t<TReal>& aiVector3t<TReal>::operator /= (TReal f) {\n    const TReal invF = (TReal) 1.0 / f;\n    x *= invF;\n    y *= invF;\n    z *= invF;\n\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal>& aiVector3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& mat){\n    return (*this =  mat * (*this));\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal>& aiVector3t<TReal>::operator *= (const aiMatrix4x4t<TReal>& mat){\n    return (*this = mat * (*this));\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nTReal aiVector3t<TReal>::operator[](unsigned int i) const {\n    switch (i) {\n        case 0:\n            return x;\n        case 1:\n            return y;\n        case 2:\n            return z;\n        default:\n            break;\n    }\n    return x;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nTReal& aiVector3t<TReal>::operator[](unsigned int i) {\n//    return *(&x + i);\n    switch (i) {\n        case 0:\n            return x;\n        case 1:\n            return y;\n        case 2:\n            return z;\n        default:\n            break;\n    }\n    return x;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nbool aiVector3t<TReal>::operator== (const aiVector3t<TReal>& other) const {\n    return x == other.x && y == other.y && z == other.z;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nbool aiVector3t<TReal>::operator!= (const aiVector3t<TReal>& other) const {\n    return x != other.x || y != other.y || z != other.z;\n}\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\nAI_FORCE_INLINE\nbool aiVector3t<TReal>::Equal(const aiVector3t<TReal>& other, TReal epsilon) const {\n    return\n        std::abs(x - other.x) <= epsilon &&\n        std::abs(y - other.y) <= epsilon &&\n        std::abs(z - other.z) <= epsilon;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nbool aiVector3t<TReal>::operator < (const aiVector3t<TReal>& other) const {\n    return x != other.x ? x < other.x : y != other.y ? y < other.y : z < other.z;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE\nconst aiVector3t<TReal> aiVector3t<TReal>::SymMul(const aiVector3t<TReal>& o) {\n    return aiVector3t<TReal>(x*o.x,y*o.y,z*o.z);\n}\n// ------------------------------------------------------------------------------------------------\n// symmetric addition\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator + (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2) {\n    return aiVector3t<TReal>( v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n}\n// ------------------------------------------------------------------------------------------------\n// symmetric subtraction\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator - (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2) {\n    return aiVector3t<TReal>( v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n}\n// ------------------------------------------------------------------------------------------------\n// scalar product\ntemplate <typename TReal>\nAI_FORCE_INLINE\nTReal operator * (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2) {\n    return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;\n}\n// ------------------------------------------------------------------------------------------------\n// scalar multiplication\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator * ( TReal f, const aiVector3t<TReal>& v) {\n    return aiVector3t<TReal>( f*v.x, f*v.y, f*v.z);\n}\n// ------------------------------------------------------------------------------------------------\n// and the other way around\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator * ( const aiVector3t<TReal>& v, TReal f) {\n    return aiVector3t<TReal>( f*v.x, f*v.y, f*v.z);\n}\n// ------------------------------------------------------------------------------------------------\n// scalar division\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator / ( const aiVector3t<TReal>& v, TReal f) {\n    return v * (1/f);\n}\n// ------------------------------------------------------------------------------------------------\n// vector division\ntemplate <typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator / ( const aiVector3t<TReal>& v, const aiVector3t<TReal>& v2) {\n    return aiVector3t<TReal>(v.x / v2.x,v.y / v2.y,v.z / v2.z);\n}\n// ------------------------------------------------------------------------------------------------\n// cross product\ntemplate<typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator ^ ( const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2) {\n    return aiVector3t<TReal>( v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);\n}\n// ------------------------------------------------------------------------------------------------\n// vector negation\ntemplate<typename TReal>\nAI_FORCE_INLINE\naiVector3t<TReal> operator - ( const aiVector3t<TReal>& v) {\n    return aiVector3t<TReal>( -v.x, -v.y, -v.z);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n#endif // __cplusplus\n#endif // AI_VECTOR3D_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/vector3.inl b/include/assimp/vector3.inl
--- a/include/assimp/vector3.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/vector3.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -49,7 +49,7 @@
 #define AI_VECTOR3D_INL_INC
 
 #ifdef __cplusplus
-#include "vector3.h"
+#include <assimp/vector3.h>
 
 #include <cmath>
 
Index: include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2016, assimp team\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Android implementation of IOSystem using the standard C file functions.\n * Aimed to ease the access to android assets */\n\n#if __ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)\n#ifndef AI_ANDROIDJNIIOSYSTEM_H_INC\n#define AI_ANDROIDJNIIOSYSTEM_H_INC\n\n#include <assimp/DefaultIOSystem.h>\n#include <android/asset_manager.h>\n#include <android/asset_manager_jni.h>\n#include <android/native_activity.h>\n\nnamespace Assimp\t{\n\n// ---------------------------------------------------------------------------\n/** Android extension to DefaultIOSystem using the standard C file functions */\nclass ASSIMP_API AndroidJNIIOSystem : public DefaultIOSystem\n{\npublic:\n\n\t/** Initialize android activity data */\n\tstd::string mApkWorkspacePath;\n\tAAssetManager* mApkAssetManager;\n\n\t/** Constructor. */\n\tAndroidJNIIOSystem(ANativeActivity* activity);\n\n\t/** Destructor. */\n\t~AndroidJNIIOSystem();\n\n\t// -------------------------------------------------------------------\n\t/** Tests for the existence of a file at the given path. */\n\tbool Exists( const char* pFile) const;\n\n\t// -------------------------------------------------------------------\n\t/** Opens a file at the given path, with given mode */\n\tIOStream* Open( const char* strFile, const char* strMode);\n\n\t// ------------------------------------------------------------------------------------------------\n\t// Inits Android extractor\n\tvoid AndroidActivityInit(ANativeActivity* activity);\n\n\t// ------------------------------------------------------------------------------------------------\n\t// Extracts android asset\n\tbool AndroidExtractAsset(std::string name);\n\n};\n\n} //!ns Assimp\n\n#endif //AI_ANDROIDJNIIOSYSTEM_H_INC\n#endif //__ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h b/include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h
--- a/include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2016, assimp team
+Copyright (c) 2006-2020, assimp team
 All rights reserved.
 
 Redistribution and use of this software in source and binary forms,
Index: include/assimp/color4.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  color4.inl\n *  @brief Inline implementation of aiColor4t<TReal> operators\n */\n#pragma once\n#ifndef AI_COLOR4D_INL_INC\n#define AI_COLOR4D_INL_INC\n\n#ifdef __cplusplus\n#include \"color4.h\"\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator += (const aiColor4t<TReal>& o) {\n    r += o.r; g += o.g; b += o.b; a += o.a;\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator -= (const aiColor4t<TReal>& o) {\n    r -= o.r; g -= o.g; b -= o.b; a -= o.a;\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator *= (TReal f) {\n    r *= f; g *= f; b *= f; a *= f;\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator /= (TReal f) {\n    r /= f; g /= f; b /= f; a /= f;\n    return *this;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE TReal aiColor4t<TReal>::operator[](unsigned int i) const {\n    switch ( i ) {\n        case 0:\n            return r;\n        case 1:\n            return g;\n        case 2:\n            return b;\n        case 3:\n            return a;\n        default:\n            break;\n    }\n    return r;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE TReal& aiColor4t<TReal>::operator[](unsigned int i) {\n    switch ( i ) {\n        case 0:\n            return r;\n        case 1:\n            return g;\n        case 2:\n            return b;\n        case 3:\n            return a;\n        default:\n            break;\n    }\n    return r;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE bool aiColor4t<TReal>::operator== (const aiColor4t<TReal>& other) const {\n    return r == other.r && g == other.g && b == other.b && a == other.a;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE bool aiColor4t<TReal>::operator!= (const aiColor4t<TReal>& other) const {\n    return r != other.r || g != other.g || b != other.b || a != other.a;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE bool aiColor4t<TReal>::operator< (const aiColor4t<TReal>& other) const {\n    return r < other.r || (\n        r == other.r && (\n            g < other.g || (\n                g == other.g && (\n                    b < other.b || (\n                        b == other.b && (\n                            a < other.a\n                        )\n                    )\n                )\n            )\n        )\n    );\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE aiColor4t<TReal> operator + (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {\n    return aiColor4t<TReal>( v1.r + v2.r, v1.g + v2.g, v1.b + v2.b, v1.a + v2.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE aiColor4t<TReal> operator - (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {\n    return aiColor4t<TReal>( v1.r - v2.r, v1.g - v2.g, v1.b - v2.b, v1.a - v2.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE aiColor4t<TReal> operator * (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {\n    return aiColor4t<TReal>( v1.r * v2.r, v1.g * v2.g, v1.b * v2.b, v1.a * v2.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE aiColor4t<TReal> operator / (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {\n    return aiColor4t<TReal>( v1.r / v2.r, v1.g / v2.g, v1.b / v2.b, v1.a / v2.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE aiColor4t<TReal> operator * ( TReal f, const aiColor4t<TReal>& v)   {\n    return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator * ( const aiColor4t<TReal>& v, TReal f)  {\n    return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator / ( const aiColor4t<TReal>& v, TReal f)  {\n    return v * (1/f);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator / ( TReal f,const aiColor4t<TReal>& v)   {\n    return aiColor4t<TReal>(f,f,f,f)/v;\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator + ( const aiColor4t<TReal>& v, TReal f)  {\n    return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator - ( const aiColor4t<TReal>& v, TReal f)  {\n    return aiColor4t<TReal>( v.r-f, v.g-f, v.b-f, v.a-f);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator + ( TReal f, const aiColor4t<TReal>& v)  {\n    return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);\n}\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\nAI_FORCE_INLINE  aiColor4t<TReal> operator - ( TReal f, const aiColor4t<TReal>& v)  {\n    return aiColor4t<TReal>( f-v.r, f-v.g, f-v.b, f-v.a);\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiColor4t<TReal> :: IsBlack() const {\n    // The alpha component doesn't care here. black is black.\n    static const TReal epsilon = 10e-3f;\n    return std::fabs( r ) < epsilon && std::fabs( g ) < epsilon && std::fabs( b ) < epsilon;\n}\n\n#endif // __cplusplus\n#endif // AI_VECTOR3D_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/color4.inl b/include/assimp/color4.inl
--- a/include/assimp/color4.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/color4.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,36 +48,61 @@
 #ifndef AI_COLOR4D_INL_INC
 #define AI_COLOR4D_INL_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
-#include "color4.h"
+#include <assimp/color4.h>
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator += (const aiColor4t<TReal>& o) {
-    r += o.r; g += o.g; b += o.b; a += o.a;
+AI_FORCE_INLINE
+const aiColor4t<TReal>& aiColor4t<TReal>::operator += (const aiColor4t<TReal>& o) {
+    r += o.r;
+    g += o.g;
+    b += o.b;
+    a += o.a;
+
     return *this;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator -= (const aiColor4t<TReal>& o) {
-    r -= o.r; g -= o.g; b -= o.b; a -= o.a;
+AI_FORCE_INLINE
+const aiColor4t<TReal>& aiColor4t<TReal>::operator -= (const aiColor4t<TReal>& o) {
+    r -= o.r;
+    g -= o.g;
+    b -= o.b;
+    a -= o.a;
+
     return *this;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator *= (TReal f) {
-    r *= f; g *= f; b *= f; a *= f;
+AI_FORCE_INLINE
+const aiColor4t<TReal>& aiColor4t<TReal>::operator *= (TReal f) {
+    r *= f;
+    g *= f;
+    b *= f;
+    a *= f;
+
     return *this;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE const aiColor4t<TReal>& aiColor4t<TReal>::operator /= (TReal f) {
-    r /= f; g /= f; b /= f; a /= f;
+AI_FORCE_INLINE
+const aiColor4t<TReal>& aiColor4t<TReal>::operator /= (TReal f) {
+    r /= f;
+    g /= f;
+    b /= f;
+    a /= f;
+
     return *this;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE TReal aiColor4t<TReal>::operator[](unsigned int i) const {
+AI_FORCE_INLINE
+TReal aiColor4t<TReal>::operator[](unsigned int i) const {
     switch ( i ) {
         case 0:
             return r;
@@ -94,7 +119,8 @@
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE TReal& aiColor4t<TReal>::operator[](unsigned int i) {
+AI_FORCE_INLINE
+TReal& aiColor4t<TReal>::operator[](unsigned int i) {
     switch ( i ) {
         case 0:
             return r;
@@ -111,17 +137,20 @@
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE bool aiColor4t<TReal>::operator== (const aiColor4t<TReal>& other) const {
+AI_FORCE_INLINE
+bool aiColor4t<TReal>::operator== (const aiColor4t<TReal>& other) const {
     return r == other.r && g == other.g && b == other.b && a == other.a;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE bool aiColor4t<TReal>::operator!= (const aiColor4t<TReal>& other) const {
+AI_FORCE_INLINE
+bool aiColor4t<TReal>::operator!= (const aiColor4t<TReal>& other) const {
     return r != other.r || g != other.g || b != other.b || a != other.a;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE bool aiColor4t<TReal>::operator< (const aiColor4t<TReal>& other) const {
+AI_FORCE_INLINE
+bool aiColor4t<TReal>::operator< (const aiColor4t<TReal>& other) const {
     return r < other.r || (
         r == other.r && (
             g < other.g || (
@@ -136,14 +165,17 @@
         )
     );
 }
+
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE aiColor4t<TReal> operator + (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator + (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
     return aiColor4t<TReal>( v1.r + v2.r, v1.g + v2.g, v1.b + v2.b, v1.a + v2.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE aiColor4t<TReal> operator - (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator - (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
     return aiColor4t<TReal>( v1.r - v2.r, v1.g - v2.g, v1.b - v2.b, v1.a - v2.a);
 }
 // ------------------------------------------------------------------------------------------------
@@ -153,53 +185,63 @@
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE aiColor4t<TReal> operator / (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator / (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)    {
     return aiColor4t<TReal>( v1.r / v2.r, v1.g / v2.g, v1.b / v2.b, v1.a / v2.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE aiColor4t<TReal> operator * ( TReal f, const aiColor4t<TReal>& v)   {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator * ( TReal f, const aiColor4t<TReal>& v)   {
     return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator * ( const aiColor4t<TReal>& v, TReal f)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator * ( const aiColor4t<TReal>& v, TReal f)  {
     return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator / ( const aiColor4t<TReal>& v, TReal f)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator / ( const aiColor4t<TReal>& v, TReal f)  {
     return v * (1/f);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator / ( TReal f,const aiColor4t<TReal>& v)   {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator / ( TReal f,const aiColor4t<TReal>& v)   {
     return aiColor4t<TReal>(f,f,f,f)/v;
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator + ( const aiColor4t<TReal>& v, TReal f)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator + ( const aiColor4t<TReal>& v, TReal f)  {
     return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator - ( const aiColor4t<TReal>& v, TReal f)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator - ( const aiColor4t<TReal>& v, TReal f)  {
     return aiColor4t<TReal>( v.r-f, v.g-f, v.b-f, v.a-f);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator + ( TReal f, const aiColor4t<TReal>& v)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator + ( TReal f, const aiColor4t<TReal>& v)  {
     return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);
 }
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-AI_FORCE_INLINE  aiColor4t<TReal> operator - ( TReal f, const aiColor4t<TReal>& v)  {
+AI_FORCE_INLINE
+aiColor4t<TReal> operator - ( TReal f, const aiColor4t<TReal>& v)  {
     return aiColor4t<TReal>( f-v.r, f-v.g, f-v.b, f-v.a);
 }
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiColor4t<TReal> :: IsBlack() const {
+AI_FORCE_INLINE
+bool aiColor4t<TReal>::IsBlack() const {
     // The alpha component doesn't care here. black is black.
     static const TReal epsilon = 10e-3f;
     return std::fabs( r ) < epsilon && std::fabs( g ) < epsilon && std::fabs( b ) < epsilon;
Index: include/assimp/cimport.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  cimport.h\n *  @brief Defines the C-API to the Open Asset Import Library.\n */\n#pragma once\n#ifndef AI_ASSIMP_H_INC\n#define AI_ASSIMP_H_INC\n\n#include <assimp/types.h>\n#include \"importerdesc.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct aiScene;  // aiScene.h\nstruct aiFileIO; // aiFileIO.h\ntypedef void (*aiLogStreamCallback)(const char* /* message */, char* /* user */);\n\n// --------------------------------------------------------------------------------\n/** C-API: Represents a log stream. A log stream receives all log messages and\n *  streams them _somewhere_.\n *  @see aiGetPredefinedLogStream\n *  @see aiAttachLogStream\n *  @see aiDetachLogStream */\n// --------------------------------------------------------------------------------\nstruct aiLogStream\n{\n    /** callback to be called */\n    aiLogStreamCallback callback;\n\n    /** user data to be passed to the callback */\n    char* user;\n};\n\n\n// --------------------------------------------------------------------------------\n/** C-API: Represents an opaque set of settings to be used during importing.\n *  @see aiCreatePropertyStore\n *  @see aiReleasePropertyStore\n *  @see aiImportFileExWithProperties\n *  @see aiSetPropertyInteger\n *  @see aiSetPropertyFloat\n *  @see aiSetPropertyString\n *  @see aiSetPropertyMatrix\n */\n// --------------------------------------------------------------------------------\nstruct aiPropertyStore { char sentinel; };\n\n/** Our own C boolean type */\ntypedef int aiBool;\n\n#define AI_FALSE 0\n#define AI_TRUE 1\n\n// --------------------------------------------------------------------------------\n/** Reads the given file and returns its content.\n *\n * If the call succeeds, the imported data is returned in an aiScene structure.\n * The data is intended to be read-only, it stays property of the ASSIMP\n * library and will be stable until aiReleaseImport() is called. After you're\n * done with it, call aiReleaseImport() to free the resources associated with\n * this file. If the import fails, NULL is returned instead. Call\n * aiGetErrorString() to retrieve a human-readable error text.\n * @param pFile Path and filename of the file to be imported,\n *   expected to be a null-terminated c-string. NULL is not a valid value.\n * @param pFlags Optional post processing steps to be executed after\n *   a successful import. Provide a bitwise combination of the\n *   #aiPostProcessSteps flags.\n * @return Pointer to the imported data or NULL if the import failed.\n */\nASSIMP_API const C_STRUCT aiScene* aiImportFile(\n    const char* pFile,\n    unsigned int pFlags);\n\n// --------------------------------------------------------------------------------\n/** Reads the given file using user-defined I/O functions and returns\n *   its content.\n *\n * If the call succeeds, the imported data is returned in an aiScene structure.\n * The data is intended to be read-only, it stays property of the ASSIMP\n * library and will be stable until aiReleaseImport() is called. After you're\n * done with it, call aiReleaseImport() to free the resources associated with\n * this file. If the import fails, NULL is returned instead. Call\n * aiGetErrorString() to retrieve a human-readable error text.\n * @param pFile Path and filename of the file to be imported,\n *   expected to be a null-terminated c-string. NULL is not a valid value.\n * @param pFlags Optional post processing steps to be executed after\n *   a successful import. Provide a bitwise combination of the\n *   #aiPostProcessSteps flags.\n * @param pFS aiFileIO structure. Will be used to open the model file itself\n *   and any other files the loader needs to open.  Pass NULL to use the default\n *   implementation.\n * @return Pointer to the imported data or NULL if the import failed.\n * @note Include <aiFileIO.h> for the definition of #aiFileIO.\n */\nASSIMP_API const C_STRUCT aiScene* aiImportFileEx(\n    const char* pFile,\n    unsigned int pFlags,\n    C_STRUCT aiFileIO* pFS);\n\n// --------------------------------------------------------------------------------\n/** Same as #aiImportFileEx, but adds an extra parameter containing importer settings.\n *\n * @param pFile Path and filename of the file to be imported,\n *   expected to be a null-terminated c-string. NULL is not a valid value.\n * @param pFlags Optional post processing steps to be executed after\n *   a successful import. Provide a bitwise combination of the\n *   #aiPostProcessSteps flags.\n * @param pFS aiFileIO structure. Will be used to open the model file itself\n *   and any other files the loader needs to open.  Pass NULL to use the default\n *   implementation.\n * @param pProps #aiPropertyStore instance containing import settings.\n * @return Pointer to the imported data or NULL if the import failed.\n * @note Include <aiFileIO.h> for the definition of #aiFileIO.\n * @see aiImportFileEx\n */\nASSIMP_API const C_STRUCT aiScene* aiImportFileExWithProperties(\n    const char* pFile,\n    unsigned int pFlags,\n    C_STRUCT aiFileIO* pFS,\n    const C_STRUCT aiPropertyStore* pProps);\n\n// --------------------------------------------------------------------------------\n/** Reads the given file from a given memory buffer,\n *\n * If the call succeeds, the contents of the file are returned as a pointer to an\n * aiScene object. The returned data is intended to be read-only, the importer keeps\n * ownership of the data and will destroy it upon destruction. If the import fails,\n * NULL is returned.\n * A human-readable error description can be retrieved by calling aiGetErrorString().\n * @param pBuffer Pointer to the file data\n * @param pLength Length of pBuffer, in bytes\n * @param pFlags Optional post processing steps to be executed after\n *   a successful import. Provide a bitwise combination of the\n *   #aiPostProcessSteps flags. If you wish to inspect the imported\n *   scene first in order to fine-tune your post-processing setup,\n *   consider to use #aiApplyPostProcessing().\n * @param pHint An additional hint to the library. If this is a non empty string,\n *   the library looks for a loader to support the file extension specified by pHint\n *   and passes the file to the first matching loader. If this loader is unable to\n *   completely the request, the library continues and tries to determine the file\n *   format on its own, a task that may or may not be successful.\n *   Check the return value, and you'll know ...\n * @return A pointer to the imported data, NULL if the import failed.\n *\n * @note This is a straightforward way to decode models from memory\n * buffers, but it doesn't handle model formats that spread their\n * data across multiple files or even directories. Examples include\n * OBJ or MD3, which outsource parts of their material info into\n * external scripts. If you need full functionality, provide\n * a custom IOSystem to make Assimp find these files and use\n * the regular aiImportFileEx()/aiImportFileExWithProperties() API.\n */\nASSIMP_API const C_STRUCT aiScene* aiImportFileFromMemory(\n    const char* pBuffer,\n    unsigned int pLength,\n    unsigned int pFlags,\n    const char* pHint);\n\n// --------------------------------------------------------------------------------\n/** Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.\n *\n * @param pBuffer Pointer to the file data\n * @param pLength Length of pBuffer, in bytes\n * @param pFlags Optional post processing steps to be executed after\n *   a successful import. Provide a bitwise combination of the\n *   #aiPostProcessSteps flags. If you wish to inspect the imported\n *   scene first in order to fine-tune your post-processing setup,\n *   consider to use #aiApplyPostProcessing().\n * @param pHint An additional hint to the library. If this is a non empty string,\n *   the library looks for a loader to support the file extension specified by pHint\n *   and passes the file to the first matching loader. If this loader is unable to\n *   completely the request, the library continues and tries to determine the file\n *   format on its own, a task that may or may not be successful.\n *   Check the return value, and you'll know ...\n * @param pProps #aiPropertyStore instance containing import settings.\n * @return A pointer to the imported data, NULL if the import failed.\n *\n * @note This is a straightforward way to decode models from memory\n * buffers, but it doesn't handle model formats that spread their\n * data across multiple files or even directories. Examples include\n * OBJ or MD3, which outsource parts of their material info into\n * external scripts. If you need full functionality, provide\n * a custom IOSystem to make Assimp find these files and use\n * the regular aiImportFileEx()/aiImportFileExWithProperties() API.\n * @see aiImportFileFromMemory\n */\nASSIMP_API const C_STRUCT aiScene* aiImportFileFromMemoryWithProperties(\n    const char* pBuffer,\n    unsigned int pLength,\n    unsigned int pFlags,\n    const char* pHint,\n    const C_STRUCT aiPropertyStore* pProps);\n\n// --------------------------------------------------------------------------------\n/** Apply post-processing to an already-imported scene.\n *\n * This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the\n * same flags. However, you can use this separate function to inspect the imported\n * scene first to fine-tune your post-processing setup.\n * @param pScene Scene to work on.\n * @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.\n * @return A pointer to the post-processed data. Post processing is done in-place,\n *   meaning this is still the same #aiScene which you passed for pScene. However,\n *   _if_ post-processing failed, the scene could now be NULL. That's quite a rare\n *   case, post processing steps are not really designed to 'fail'. To be exact,\n *   the #aiProcess_ValidateDataStructure flag is currently the only post processing step\n *   which can actually cause the scene to be reset to NULL.\n */\nASSIMP_API const C_STRUCT aiScene* aiApplyPostProcessing(\n    const C_STRUCT aiScene* pScene,\n    unsigned int pFlags);\n\n// --------------------------------------------------------------------------------\n/** Get one of the predefine log streams. This is the quick'n'easy solution to\n *  access Assimp's log system. Attaching a log stream can slightly reduce Assimp's\n *  overall import performance.\n *\n *  Usage is rather simple (this will stream the log to a file, named log.txt, and\n *  the stdout stream of the process:\n *  @code\n *    struct aiLogStream c;\n *    c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,\"log.txt\");\n *    aiAttachLogStream(&c);\n *    c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);\n *    aiAttachLogStream(&c);\n *  @endcode\n *\n *  @param pStreams One of the #aiDefaultLogStream enumerated values.\n *  @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.\n *    Pass NULL for all other flags.\n *  @return The log stream. callback is set to NULL if something went wrong.\n */\nASSIMP_API C_STRUCT aiLogStream aiGetPredefinedLogStream(\n    C_ENUM aiDefaultLogStream pStreams,\n    const char* file);\n\n// --------------------------------------------------------------------------------\n/** Attach a custom log stream to the libraries' logging system.\n *\n *  Attaching a log stream can slightly reduce Assimp's overall import\n *  performance. Multiple log-streams can be attached.\n *  @param stream Describes the new log stream.\n *  @note To ensure proper destruction of the logging system, you need to manually\n *    call aiDetachLogStream() on every single log stream you attach.\n *    Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.\n */\nASSIMP_API void aiAttachLogStream(\n    const C_STRUCT aiLogStream* stream);\n\n// --------------------------------------------------------------------------------\n/** Enable verbose logging. Verbose logging includes debug-related stuff and\n *  detailed import statistics. This can have severe impact on import performance\n *  and memory consumption. However, it might be useful to find out why a file\n *  didn't read correctly.\n *  @param d AI_TRUE or AI_FALSE, your decision.\n */\nASSIMP_API void aiEnableVerboseLogging(aiBool d);\n\n// --------------------------------------------------------------------------------\n/** Detach a custom log stream from the libraries' logging system.\n *\n *  This is the counterpart of #aiAttachLogStream. If you attached a stream,\n *  don't forget to detach it again.\n *  @param stream The log stream to be detached.\n *  @return AI_SUCCESS if the log stream has been detached successfully.\n *  @see aiDetachAllLogStreams\n */\nASSIMP_API C_ENUM aiReturn aiDetachLogStream(\n    const C_STRUCT aiLogStream* stream);\n\n// --------------------------------------------------------------------------------\n/** Detach all active log streams from the libraries' logging system.\n *  This ensures that the logging system is terminated properly and all\n *  resources allocated by it are actually freed. If you attached a stream,\n *  don't forget to detach it again.\n *  @see aiAttachLogStream\n *  @see aiDetachLogStream\n */\nASSIMP_API void aiDetachAllLogStreams(void);\n\n// --------------------------------------------------------------------------------\n/** Releases all resources associated with the given import process.\n *\n * Call this function after you're done with the imported data.\n * @param pScene The imported data to release. NULL is a valid value.\n */\nASSIMP_API void aiReleaseImport(\n    const C_STRUCT aiScene* pScene);\n\n// --------------------------------------------------------------------------------\n/** Returns the error text of the last failed import process.\n *\n * @return A textual description of the error that occurred at the last\n * import process. NULL if there was no error. There can't be an error if you\n * got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.\n */\nASSIMP_API const char* aiGetErrorString(void);\n\n// --------------------------------------------------------------------------------\n/** Returns whether a given file extension is supported by ASSIMP\n *\n * @param szExtension Extension for which the function queries support for.\n * Must include a leading dot '.'. Example: \".3ds\", \".md3\"\n * @return AI_TRUE if the file extension is supported.\n */\nASSIMP_API aiBool aiIsExtensionSupported(\n    const char* szExtension);\n\n// --------------------------------------------------------------------------------\n/** Get a list of all file extensions supported by ASSIMP.\n *\n * If a file extension is contained in the list this does, of course, not\n * mean that ASSIMP is able to load all files with this extension.\n * @param szOut String to receive the extension list.\n * Format of the list: \"*.3ds;*.obj;*.dae\". NULL is not a valid parameter.\n */\nASSIMP_API void aiGetExtensionList(\n    C_STRUCT aiString* szOut);\n\n// --------------------------------------------------------------------------------\n/** Get the approximated storage required by an imported asset\n * @param pIn Input asset.\n * @param in Data structure to be filled.\n */\nASSIMP_API void aiGetMemoryRequirements(\n    const C_STRUCT aiScene* pIn,\n    C_STRUCT aiMemoryInfo* in);\n\n\n\n// --------------------------------------------------------------------------------\n/** Create an empty property store. Property stores are used to collect import\n *  settings.\n * @return New property store. Property stores need to be manually destroyed using\n *   the #aiReleasePropertyStore API function.\n */\nASSIMP_API C_STRUCT aiPropertyStore* aiCreatePropertyStore(void);\n\n// --------------------------------------------------------------------------------\n/** Delete a property store.\n * @param p Property store to be deleted.\n */\nASSIMP_API void aiReleasePropertyStore(C_STRUCT aiPropertyStore* p);\n\n// --------------------------------------------------------------------------------\n/** Set an integer property.\n *\n *  This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C\n *  interface, properties are always shared by all imports. It is not possible to\n *  specify them per import.\n *\n * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n * @param szName Name of the configuration property to be set. All supported\n *   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n * @param value New value for the property\n */\nASSIMP_API void aiSetImportPropertyInteger(\n    C_STRUCT aiPropertyStore* store,\n    const char* szName,\n    int value);\n\n// --------------------------------------------------------------------------------\n/** Set a floating-point property.\n *\n *  This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C\n *  interface, properties are always shared by all imports. It is not possible to\n *  specify them per import.\n *\n * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n * @param szName Name of the configuration property to be set. All supported\n *   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n * @param value New value for the property\n */\nASSIMP_API void aiSetImportPropertyFloat(\n    C_STRUCT aiPropertyStore* store,\n    const char* szName,\n    ai_real value);\n\n// --------------------------------------------------------------------------------\n/** Set a string property.\n *\n *  This is the C-version of #Assimp::Importer::SetPropertyString(). In the C\n *  interface, properties are always shared by all imports. It is not possible to\n *  specify them per import.\n *\n * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n * @param szName Name of the configuration property to be set. All supported\n *   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n * @param st New value for the property\n */\nASSIMP_API void aiSetImportPropertyString(\n    C_STRUCT aiPropertyStore* store,\n    const char* szName,\n    const C_STRUCT aiString* st);\n\n// --------------------------------------------------------------------------------\n/** Set a matrix property.\n *\n *  This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C\n *  interface, properties are always shared by all imports. It is not possible to\n *  specify them per import.\n *\n * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n * @param szName Name of the configuration property to be set. All supported\n *   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n * @param mat New value for the property\n */\nASSIMP_API void aiSetImportPropertyMatrix(\n    C_STRUCT aiPropertyStore* store,\n    const char* szName,\n    const C_STRUCT aiMatrix4x4* mat);\n\n// --------------------------------------------------------------------------------\n/** Construct a quaternion from a 3x3 rotation matrix.\n *  @param quat Receives the output quaternion.\n *  @param mat Matrix to 'quaternionize'.\n *  @see aiQuaternion(const aiMatrix3x3& pRotMatrix)\n */\nASSIMP_API void aiCreateQuaternionFromMatrix(\n    C_STRUCT aiQuaternion* quat,\n    const C_STRUCT aiMatrix3x3* mat);\n\n// --------------------------------------------------------------------------------\n/** Decompose a transformation matrix into its rotational, translational and\n *  scaling components.\n *\n * @param mat Matrix to decompose\n * @param scaling Receives the scaling component\n * @param rotation Receives the rotational component\n * @param position Receives the translational component.\n * @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;\n */\nASSIMP_API void aiDecomposeMatrix(\n    const C_STRUCT aiMatrix4x4* mat,\n    C_STRUCT aiVector3D* scaling,\n    C_STRUCT aiQuaternion* rotation,\n    C_STRUCT aiVector3D* position);\n\n// --------------------------------------------------------------------------------\n/** Transpose a 4x4 matrix.\n *  @param mat Pointer to the matrix to be transposed\n */\nASSIMP_API void aiTransposeMatrix4(\n    C_STRUCT aiMatrix4x4* mat);\n\n// --------------------------------------------------------------------------------\n/** Transpose a 3x3 matrix.\n *  @param mat Pointer to the matrix to be transposed\n */\nASSIMP_API void aiTransposeMatrix3(\n    C_STRUCT aiMatrix3x3* mat);\n\n// --------------------------------------------------------------------------------\n/** Transform a vector by a 3x3 matrix\n *  @param vec Vector to be transformed.\n *  @param mat Matrix to transform the vector with.\n */\nASSIMP_API void aiTransformVecByMatrix3(\n    C_STRUCT aiVector3D* vec,\n    const C_STRUCT aiMatrix3x3* mat);\n\n// --------------------------------------------------------------------------------\n/** Transform a vector by a 4x4 matrix\n *  @param vec Vector to be transformed.\n *  @param mat Matrix to transform the vector with.\n */\nASSIMP_API void aiTransformVecByMatrix4(\n    C_STRUCT aiVector3D* vec,\n    const C_STRUCT aiMatrix4x4* mat);\n\n// --------------------------------------------------------------------------------\n/** Multiply two 4x4 matrices.\n *  @param dst First factor, receives result.\n *  @param src Matrix to be multiplied with 'dst'.\n */\nASSIMP_API void aiMultiplyMatrix4(\n    C_STRUCT aiMatrix4x4* dst,\n    const C_STRUCT aiMatrix4x4* src);\n\n// --------------------------------------------------------------------------------\n/** Multiply two 3x3 matrices.\n *  @param dst First factor, receives result.\n *  @param src Matrix to be multiplied with 'dst'.\n */\nASSIMP_API void aiMultiplyMatrix3(\n    C_STRUCT aiMatrix3x3* dst,\n    const C_STRUCT aiMatrix3x3* src);\n\n// --------------------------------------------------------------------------------\n/** Get a 3x3 identity matrix.\n *  @param mat Matrix to receive its personal identity\n */\nASSIMP_API void aiIdentityMatrix3(\n    C_STRUCT aiMatrix3x3* mat);\n\n// --------------------------------------------------------------------------------\n/** Get a 4x4 identity matrix.\n *  @param mat Matrix to receive its personal identity\n */\nASSIMP_API void aiIdentityMatrix4(\n    C_STRUCT aiMatrix4x4* mat);\n\n// --------------------------------------------------------------------------------\n/** Returns the number of import file formats available in the current Assimp build.\n * Use aiGetImportFormatDescription() to retrieve infos of a specific import format.\n */\nASSIMP_API size_t aiGetImportFormatCount(void);\n\n// --------------------------------------------------------------------------------\n/** Returns a description of the nth import file format. Use #aiGetImportFormatCount()\n * to learn how many import formats are supported.\n * @param pIndex Index of the import format to retrieve information for. Valid range is\n *    0 to #aiGetImportFormatCount()\n * @return A description of that specific import format. NULL if pIndex is out of range.\n */\nASSIMP_API const C_STRUCT aiImporterDesc* aiGetImportFormatDescription( size_t pIndex);\n#ifdef __cplusplus\n}\n#endif\n\n#endif // AI_ASSIMP_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/cimport.h b/include/assimp/cimport.h
--- a/include/assimp/cimport.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/cimport.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,8 +48,12 @@
 #ifndef AI_ASSIMP_H_INC
 #define AI_ASSIMP_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
-#include "importerdesc.h"
+#include <assimp/importerdesc.h>
 
 #ifdef __cplusplus
 extern "C" {
Index: include/assimp/ai_assert.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n#pragma once\n#ifndef AI_ASSERT_H_INC\n#define AI_ASSERT_H_INC\n\n#ifdef ASSIMP_BUILD_DEBUG\n#   include <assert.h>\n#   define ai_assert(expression) assert( expression )\n#   define ai_assert_entry()     assert( false )\n#else\n#   define  ai_assert(expression)\n#   define  ai_assert_entry() \n#endif // ASSIMP_BUILD_DEBUG\n\n#endif // AI_ASSERT_H_INC\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/ai_assert.h b/include/assimp/ai_assert.h
--- a/include/assimp/ai_assert.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/ai_assert.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -44,6 +44,10 @@
 #ifndef AI_ASSERT_H_INC
 #define AI_ASSERT_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef ASSIMP_BUILD_DEBUG
 #   include <assert.h>
 #   define ai_assert(expression) assert( expression )
Index: include/assimp/material.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file material.inl\n *  @brief Defines the C++ getters for the material system\n */\n\n#pragma once\n#ifndef AI_MATERIAL_INL_INC\n#define AI_MATERIAL_INL_INC\n\n// ---------------------------------------------------------------------------\ninline aiPropertyTypeInfo ai_real_to_property_type_info(float)\n{\n\treturn aiPTI_Float;\n}\n\ninline aiPropertyTypeInfo ai_real_to_property_type_info(double)\n{\n\treturn aiPTI_Double;\n}\n// ---------------------------------------------------------------------------\n\n//! @cond never\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::GetTexture( aiTextureType type,\n   unsigned int  index,\n   C_STRUCT aiString* path,\n   aiTextureMapping* mapping    /*= NULL*/,\n   unsigned int* uvindex        /*= NULL*/,\n   ai_real* blend               /*= NULL*/,\n   aiTextureOp* op              /*= NULL*/,\n   aiTextureMapMode* mapmode    /*= NULL*/) const\n{\n    return ::aiGetMaterialTexture(this,type,index,path,mapping,uvindex,blend,op,mapmode);\n}\n\n// ---------------------------------------------------------------------------\ninline unsigned int aiMaterial::GetTextureCount(aiTextureType type) const\n{\n    return ::aiGetMaterialTextureCount(this,type);\n}\n\n// ---------------------------------------------------------------------------\ntemplate <typename Type>\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx, Type* pOut,\n    unsigned int* pMax) const\n{\n    unsigned int iNum = pMax ? *pMax : 1;\n\n    const aiMaterialProperty* prop;\n    const aiReturn ret = ::aiGetMaterialProperty(this,pKey,type,idx,\n        (const aiMaterialProperty**)&prop);\n    if ( AI_SUCCESS == ret )    {\n\n        if (prop->mDataLength < sizeof(Type)*iNum) {\n            return AI_FAILURE;\n        }\n\n        if (prop->mType != aiPTI_Buffer) {\n            return AI_FAILURE;\n        }\n\n        iNum = std::min((size_t)iNum,prop->mDataLength / sizeof(Type));\n        ::memcpy(pOut,prop->mData,iNum * sizeof(Type));\n        if (pMax) {\n            *pMax = iNum;\n        }\n    }\n    return ret;\n}\n\n// ---------------------------------------------------------------------------\ntemplate <typename Type>\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,Type& pOut) const\n{\n    const aiMaterialProperty* prop;\n    const aiReturn ret = ::aiGetMaterialProperty(this,pKey,type,idx,\n        (const aiMaterialProperty**)&prop);\n    if ( AI_SUCCESS == ret ) {\n\n        if (prop->mDataLength < sizeof(Type)) {\n            return AI_FAILURE;\n        }\n\n        if (prop->mType != aiPTI_Buffer) {\n            return AI_FAILURE;\n        }\n\n        ::memcpy( &pOut, prop->mData, sizeof( Type ) );\n    }\n    return ret;\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,ai_real* pOut,\n    unsigned int* pMax) const\n{\n    return ::aiGetMaterialFloatArray(this,pKey,type,idx,pOut,pMax);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,int* pOut,\n    unsigned int* pMax) const\n{\n    return ::aiGetMaterialIntegerArray(this,pKey,type,idx,pOut,pMax);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,ai_real& pOut) const\n{\n    return aiGetMaterialFloat(this,pKey,type,idx,&pOut);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,int& pOut) const\n{\n    return aiGetMaterialInteger(this,pKey,type,idx,&pOut);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,aiColor4D& pOut) const\n{\n    return aiGetMaterialColor(this,pKey,type,idx,&pOut);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,aiColor3D& pOut) const\n{\n    aiColor4D c;\n    const aiReturn ret = aiGetMaterialColor(this,pKey,type,idx,&c);\n    pOut = aiColor3D(c.r,c.g,c.b);\n    return ret;\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,aiString& pOut) const\n{\n    return aiGetMaterialString(this,pKey,type,idx,&pOut);\n}\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,\n    unsigned int idx,aiUVTransform& pOut) const\n{\n    return aiGetMaterialUVTransform(this,pKey,type,idx,&pOut);\n}\n\n\n// ---------------------------------------------------------------------------\ntemplate<class TYPE>\naiReturn aiMaterial::AddProperty (const TYPE* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(TYPE),\n        pKey,type,index,aiPTI_Buffer);\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const float* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(float),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const double* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(double),\n        pKey,type,index,aiPTI_Double);\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const aiUVTransform* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiUVTransform),\n        pKey,type,index,ai_real_to_property_type_info(pInput->mRotation));\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const aiColor4D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiColor4D),\n        pKey,type,index,ai_real_to_property_type_info(pInput->a));\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const aiColor3D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiColor3D),\n        pKey,type,index,ai_real_to_property_type_info(pInput->b));\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const aiVector3D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiVector3D),\n        pKey,type,index,ai_real_to_property_type_info(pInput->x));\n}\n\n// ---------------------------------------------------------------------------\ninline aiReturn aiMaterial::AddProperty(const int* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(int),\n        pKey,type,index,aiPTI_Integer);\n}\n\n\n// ---------------------------------------------------------------------------\n// The template specializations below are for backwards compatibility.\n// The recommended way to add material properties is using the non-template\n// overloads.\n// ---------------------------------------------------------------------------\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<float>(const float* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(float),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<double>(const double* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(double),\n        pKey,type,index,aiPTI_Double);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<aiUVTransform>(const aiUVTransform* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiUVTransform),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<aiColor4D>(const aiColor4D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiColor4D),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<aiColor3D>(const aiColor3D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiColor3D),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<aiVector3D>(const aiVector3D* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(aiVector3D),\n        pKey,type,index,aiPTI_Float);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<>\ninline aiReturn aiMaterial::AddProperty<int>(const int* pInput,\n    const unsigned int pNumValues,\n    const char* pKey,\n    unsigned int type,\n    unsigned int index)\n{\n    return AddBinaryProperty((const void*)pInput,\n        pNumValues * sizeof(int),\n        pKey,type,index,aiPTI_Integer);\n}\n\n//! @endcond\n\n#endif //! AI_MATERIAL_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/material.inl b/include/assimp/material.inl
--- a/include/assimp/material.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/material.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -49,14 +49,18 @@
 #ifndef AI_MATERIAL_INL_INC
 #define AI_MATERIAL_INL_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 // ---------------------------------------------------------------------------
-inline aiPropertyTypeInfo ai_real_to_property_type_info(float)
-{
+AI_FORCE_INLINE
+aiPropertyTypeInfo ai_real_to_property_type_info(float) {
 	return aiPTI_Float;
 }
 
-inline aiPropertyTypeInfo ai_real_to_property_type_info(double)
-{
+AI_FORCE_INLINE
+aiPropertyTypeInfo ai_real_to_property_type_info(double) {
 	return aiPTI_Double;
 }
 // ---------------------------------------------------------------------------
@@ -64,30 +68,30 @@
 //! @cond never
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::GetTexture( aiTextureType type,
-   unsigned int  index,
-   C_STRUCT aiString* path,
-   aiTextureMapping* mapping    /*= NULL*/,
-   unsigned int* uvindex        /*= NULL*/,
-   ai_real* blend               /*= NULL*/,
-   aiTextureOp* op              /*= NULL*/,
-   aiTextureMapMode* mapmode    /*= NULL*/) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::GetTexture( aiTextureType type,
+       unsigned int  index,
+       C_STRUCT aiString* path,
+       aiTextureMapping* mapping    /*= NULL*/,
+       unsigned int* uvindex        /*= NULL*/,
+       ai_real* blend               /*= NULL*/,
+       aiTextureOp* op              /*= NULL*/,
+       aiTextureMapMode* mapmode    /*= NULL*/) const {
     return ::aiGetMaterialTexture(this,type,index,path,mapping,uvindex,blend,op,mapmode);
 }
 
 // ---------------------------------------------------------------------------
-inline unsigned int aiMaterial::GetTextureCount(aiTextureType type) const
-{
+AI_FORCE_INLINE
+unsigned int aiMaterial::GetTextureCount(aiTextureType type) const {
     return ::aiGetMaterialTextureCount(this,type);
 }
 
 // ---------------------------------------------------------------------------
 template <typename Type>
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx, Type* pOut,
-    unsigned int* pMax) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx, Type* pOut,
+        unsigned int* pMax) const {
     unsigned int iNum = pMax ? *pMax : 1;
 
     const aiMaterialProperty* prop;
@@ -114,9 +118,9 @@
 
 // ---------------------------------------------------------------------------
 template <typename Type>
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,Type& pOut) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,Type& pOut) const {
     const aiMaterialProperty* prop;
     const aiReturn ret = ::aiGetMaterialProperty(this,pKey,type,idx,
         (const aiMaterialProperty**)&prop);
@@ -136,60 +140,56 @@
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,ai_real* pOut,
-    unsigned int* pMax) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,ai_real* pOut,
+        unsigned int* pMax) const {
     return ::aiGetMaterialFloatArray(this,pKey,type,idx,pOut,pMax);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,int* pOut,
-    unsigned int* pMax) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,int* pOut,
+        unsigned int* pMax) const {
     return ::aiGetMaterialIntegerArray(this,pKey,type,idx,pOut,pMax);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,ai_real& pOut) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,ai_real& pOut) const {
     return aiGetMaterialFloat(this,pKey,type,idx,&pOut);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,int& pOut) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,int& pOut) const {
     return aiGetMaterialInteger(this,pKey,type,idx,&pOut);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,aiColor4D& pOut) const
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,aiColor4D& pOut) const {
     return aiGetMaterialColor(this,pKey,type,idx,&pOut);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,aiColor3D& pOut) const
-{
+AI_FORCE_INLINE aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,aiColor3D& pOut) const {
     aiColor4D c;
     const aiReturn ret = aiGetMaterialColor(this,pKey,type,idx,&c);
     pOut = aiColor3D(c.r,c.g,c.b);
     return ret;
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,aiString& pOut) const
-{
+AI_FORCE_INLINE aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,aiString& pOut) const {
     return aiGetMaterialString(this,pKey,type,idx,&pOut);
 }
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
-    unsigned int idx,aiUVTransform& pOut) const
-{
+AI_FORCE_INLINE aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
+        unsigned int idx,aiUVTransform& pOut) const {
     return aiGetMaterialUVTransform(this,pKey,type,idx,&pOut);
 }
 
-
 // ---------------------------------------------------------------------------
 template<class TYPE>
 aiReturn aiMaterial::AddProperty (const TYPE* pInput,
@@ -204,84 +204,83 @@
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const float* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE aiReturn aiMaterial::AddProperty(const float* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(float),
         pKey,type,index,aiPTI_Float);
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const double* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const double* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(double),
         pKey,type,index,aiPTI_Double);
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const aiUVTransform* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const aiUVTransform* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiUVTransform),
         pKey,type,index,ai_real_to_property_type_info(pInput->mRotation));
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const aiColor4D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const aiColor4D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiColor4D),
         pKey,type,index,ai_real_to_property_type_info(pInput->a));
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const aiColor3D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const aiColor3D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiColor3D),
         pKey,type,index,ai_real_to_property_type_info(pInput->b));
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const aiVector3D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const aiVector3D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiVector3D),
         pKey,type,index,ai_real_to_property_type_info(pInput->x));
 }
 
 // ---------------------------------------------------------------------------
-inline aiReturn aiMaterial::AddProperty(const int* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty(const int* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(int),
         pKey,type,index,aiPTI_Integer);
@@ -296,12 +295,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<float>(const float* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<float>(const float* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(float),
         pKey,type,index,aiPTI_Float);
@@ -309,12 +308,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<double>(const double* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<double>(const double* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(double),
         pKey,type,index,aiPTI_Double);
@@ -322,12 +321,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<aiUVTransform>(const aiUVTransform* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<aiUVTransform>(const aiUVTransform* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiUVTransform),
         pKey,type,index,aiPTI_Float);
@@ -335,12 +334,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<aiColor4D>(const aiColor4D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<aiColor4D>(const aiColor4D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiColor4D),
         pKey,type,index,aiPTI_Float);
@@ -348,12 +347,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<aiColor3D>(const aiColor3D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<aiColor3D>(const aiColor3D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiColor3D),
         pKey,type,index,aiPTI_Float);
@@ -361,12 +360,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<aiVector3D>(const aiVector3D* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<aiVector3D>(const aiVector3D* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(aiVector3D),
         pKey,type,index,aiPTI_Float);
@@ -374,12 +373,12 @@
 
 // ---------------------------------------------------------------------------
 template<>
-inline aiReturn aiMaterial::AddProperty<int>(const int* pInput,
-    const unsigned int pNumValues,
-    const char* pKey,
-    unsigned int type,
-    unsigned int index)
-{
+AI_FORCE_INLINE
+aiReturn aiMaterial::AddProperty<int>(const int* pInput,
+        const unsigned int pNumValues,
+        const char* pKey,
+        unsigned int type,
+        unsigned int index) {
     return AddBinaryProperty((const void*)pInput,
         pNumValues * sizeof(int),
         pKey,type,index,aiPTI_Integer);
Index: include/assimp/pbrmaterial.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file pbrmaterial.h\n *  @brief Defines the material system of the library\n */\n#ifndef AI_PBRMATERIAL_H_INC\n#define AI_PBRMATERIAL_H_INC\n\n#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_BASE_COLOR_FACTOR \"$mat.gltf.pbrMetallicRoughness.baseColorFactor\", 0, 0\n#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLIC_FACTOR \"$mat.gltf.pbrMetallicRoughness.metallicFactor\", 0, 0\n#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_ROUGHNESS_FACTOR \"$mat.gltf.pbrMetallicRoughness.roughnessFactor\", 0, 0\n#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_BASE_COLOR_TEXTURE aiTextureType_DIFFUSE, 1\n#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE aiTextureType_UNKNOWN, 0\n#define AI_MATKEY_GLTF_ALPHAMODE \"$mat.gltf.alphaMode\", 0, 0\n#define AI_MATKEY_GLTF_ALPHACUTOFF \"$mat.gltf.alphaCutoff\", 0, 0\n#define AI_MATKEY_GLTF_PBRSPECULARGLOSSINESS \"$mat.gltf.pbrSpecularGlossiness\", 0, 0\n#define AI_MATKEY_GLTF_PBRSPECULARGLOSSINESS_GLOSSINESS_FACTOR \"$mat.gltf.pbrMetallicRoughness.glossinessFactor\", 0, 0\n#define AI_MATKEY_GLTF_UNLIT \"$mat.gltf.unlit\", 0, 0\n\n#define _AI_MATKEY_GLTF_TEXTURE_TEXCOORD_BASE \"$tex.file.texCoord\"\n#define _AI_MATKEY_GLTF_MAPPINGNAME_BASE \"$tex.mappingname\"\n#define _AI_MATKEY_GLTF_MAPPINGID_BASE \"$tex.mappingid\"\n#define _AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE \"$tex.mappingfiltermag\"\n#define _AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE \"$tex.mappingfiltermin\"\n#define _AI_MATKEY_GLTF_SCALE_BASE \"$tex.scale\"\n#define _AI_MATKEY_GLTF_STRENGTH_BASE \"$tex.strength\"\n\n#define AI_MATKEY_GLTF_TEXTURE_TEXCOORD(type, N) _AI_MATKEY_GLTF_TEXTURE_TEXCOORD_BASE, type, N\n#define AI_MATKEY_GLTF_MAPPINGNAME(type, N) _AI_MATKEY_GLTF_MAPPINGNAME_BASE, type, N\n#define AI_MATKEY_GLTF_MAPPINGID(type, N) _AI_MATKEY_GLTF_MAPPINGID_BASE, type, N\n#define AI_MATKEY_GLTF_MAPPINGFILTER_MAG(type, N) _AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE, type, N\n#define AI_MATKEY_GLTF_MAPPINGFILTER_MIN(type, N) _AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE, type, N\n#define AI_MATKEY_GLTF_TEXTURE_SCALE(type, N) _AI_MATKEY_GLTF_SCALE_BASE, type, N\n#define AI_MATKEY_GLTF_TEXTURE_STRENGTH(type, N) _AI_MATKEY_GLTF_STRENGTH_BASE, type, N\n\n#endif //!!AI_PBRMATERIAL_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/pbrmaterial.h b/include/assimp/pbrmaterial.h
--- a/include/assimp/pbrmaterial.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/pbrmaterial.h	(date 1617519895000)
@@ -3,9 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -44,9 +42,14 @@
 /** @file pbrmaterial.h
  *  @brief Defines the material system of the library
  */
+#pragma once
 #ifndef AI_PBRMATERIAL_H_INC
 #define AI_PBRMATERIAL_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_BASE_COLOR_FACTOR "$mat.gltf.pbrMetallicRoughness.baseColorFactor", 0, 0
 #define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLIC_FACTOR "$mat.gltf.pbrMetallicRoughness.metallicFactor", 0, 0
 #define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_ROUGHNESS_FACTOR "$mat.gltf.pbrMetallicRoughness.roughnessFactor", 0, 0
Index: include/assimp/matrix3x3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file matrix3x3.h\n *  @brief Definition of a 3x3 matrix, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_MATRIX3X3_H_INC\n#define AI_MATRIX3X3_H_INC\n\n#include \"defs.h\"\n\n#ifdef __cplusplus\n\ntemplate <typename T> class aiMatrix4x4t;\ntemplate <typename T> class aiVector2t;\n\n// ---------------------------------------------------------------------------\n/** @brief Represents a row-major 3x3 matrix\n *\n *  There's much confusion about matrix layouts (column vs. row order).\n *  This is *always* a row-major matrix. Not even with the\n *  #aiProcess_ConvertToLeftHanded flag, which absolutely does not affect\n *  matrix order - it just affects the handedness of the coordinate system\n *  defined thereby.\n */\ntemplate <typename TReal>\nclass aiMatrix3x3t\n{\npublic:\n\n    aiMatrix3x3t() AI_NO_EXCEPT :\n        a1(static_cast<TReal>(1.0f)), a2(), a3(),\n        b1(), b2(static_cast<TReal>(1.0f)), b3(),\n        c1(), c2(), c3(static_cast<TReal>(1.0f)) {}\n\n    aiMatrix3x3t (  TReal _a1, TReal _a2, TReal _a3,\n                    TReal _b1, TReal _b2, TReal _b3,\n                    TReal _c1, TReal _c2, TReal _c3) :\n        a1(_a1), a2(_a2), a3(_a3),\n        b1(_b1), b2(_b2), b3(_b3),\n        c1(_c1), c2(_c2), c3(_c3)\n    {}\n\npublic:\n\n    // matrix multiplication.\n    aiMatrix3x3t& operator *= (const aiMatrix3x3t& m);\n    aiMatrix3x3t  operator  * (const aiMatrix3x3t& m) const;\n\n    // array access operators\n    TReal* operator[]       (unsigned int p_iIndex);\n    const TReal* operator[] (unsigned int p_iIndex) const;\n\n    // comparison operators\n    bool operator== (const aiMatrix4x4t<TReal>& m) const;\n    bool operator!= (const aiMatrix4x4t<TReal>& m) const;\n\n    bool Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon = 1e-6) const;\n\n    template <typename TOther>\n    operator aiMatrix3x3t<TOther> () const;\n\npublic:\n\n    // -------------------------------------------------------------------\n    /** @brief Construction from a 4x4 matrix. The remaining parts\n     *  of the matrix are ignored.\n     */\n    explicit aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix);\n\n    // -------------------------------------------------------------------\n    /** @brief Transpose the matrix\n     */\n    aiMatrix3x3t& Transpose();\n\n    // -------------------------------------------------------------------\n    /** @brief Invert the matrix.\n     *  If the matrix is not invertible all elements are set to qnan.\n     *  Beware, use (f != f) to check whether a TReal f is qnan.\n     */\n    aiMatrix3x3t& Inverse();\n    TReal Determinant() const;\n\npublic:\n    // -------------------------------------------------------------------\n    /** @brief Returns a rotation matrix for a rotation around z\n     *  @param a Rotation angle, in radians\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix3x3t& RotationZ(TReal a, aiMatrix3x3t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a rotation matrix for a rotation around\n     *    an arbitrary axis.\n     *\n     *  @param a Rotation angle, in radians\n     *  @param axis Axis to rotate around\n     *  @param out To be filled\n     */\n    static aiMatrix3x3t& Rotation( TReal a,\n        const aiVector3t<TReal>& axis, aiMatrix3x3t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a translation matrix\n     *  @param v Translation vector\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix3x3t& Translation( const aiVector2t<TReal>& v, aiMatrix3x3t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief A function for creating a rotation matrix that rotates a\n     *  vector called \"from\" into another vector called \"to\".\n     * Input : from[3], to[3] which both must be *normalized* non-zero vectors\n     * Output: mtx[3][3] -- a 3x3 matrix in column-major form\n     * Authors: Tomas Möller, John Hughes\n     *          \"Efficiently Building a Matrix to Rotate One Vector to Another\"\n     *          Journal of Graphics Tools, 4(4):1-4, 1999\n     */\n    static aiMatrix3x3t& FromToMatrix(const aiVector3t<TReal>& from,\n        const aiVector3t<TReal>& to, aiMatrix3x3t& out);\n\npublic:\n    TReal a1, a2, a3;\n    TReal b1, b2, b3;\n    TReal c1, c2, c3;\n};\n\ntypedef aiMatrix3x3t<ai_real> aiMatrix3x3;\n\n#else\n\nstruct aiMatrix3x3 {\n    ai_real a1, a2, a3;\n    ai_real b1, b2, b3;\n    ai_real c1, c2, c3;\n};\n\n#endif // __cplusplus\n\n#endif // AI_MATRIX3X3_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/matrix3x3.h b/include/assimp/matrix3x3.h
--- a/include/assimp/matrix3x3.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/matrix3x3.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,7 +48,11 @@
 #ifndef AI_MATRIX3X3_H_INC
 #define AI_MATRIX3X3_H_INC
 
-#include "defs.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/defs.h>
 
 #ifdef __cplusplus
 
@@ -65,10 +69,8 @@
  *  defined thereby.
  */
 template <typename TReal>
-class aiMatrix3x3t
-{
+class aiMatrix3x3t {
 public:
-
     aiMatrix3x3t() AI_NO_EXCEPT :
         a1(static_cast<TReal>(1.0f)), a2(), a3(),
         b1(), b2(static_cast<TReal>(1.0f)), b3(),
@@ -82,8 +84,6 @@
         c1(_c1), c2(_c2), c3(_c3)
     {}
 
-public:
-
     // matrix multiplication.
     aiMatrix3x3t& operator *= (const aiMatrix3x3t& m);
     aiMatrix3x3t  operator  * (const aiMatrix3x3t& m) const;
@@ -93,16 +93,14 @@
     const TReal* operator[] (unsigned int p_iIndex) const;
 
     // comparison operators
-    bool operator== (const aiMatrix4x4t<TReal>& m) const;
-    bool operator!= (const aiMatrix4x4t<TReal>& m) const;
+    bool operator== (const aiMatrix3x3t<TReal>& m) const;
+    bool operator!= (const aiMatrix3x3t<TReal>& m) const;
 
-    bool Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon = 1e-6) const;
+    bool Equal(const aiMatrix3x3t<TReal>& m, TReal epsilon = 1e-6) const;
 
     template <typename TOther>
     operator aiMatrix3x3t<TOther> () const;
 
-public:
-
     // -------------------------------------------------------------------
     /** @brief Construction from a 4x4 matrix. The remaining parts
      *  of the matrix are ignored.
@@ -122,7 +120,6 @@
     aiMatrix3x3t& Inverse();
     TReal Determinant() const;
 
-public:
     // -------------------------------------------------------------------
     /** @brief Returns a rotation matrix for a rotation around z
      *  @param a Rotation angle, in radians
Index: include/assimp/IOStream.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n/** @file IOStream.hpp\n *  @brief File I/O wrappers for C++.\n */\n\n#pragma once\n#ifndef AI_IOSTREAM_H_INC\n#define AI_IOSTREAM_H_INC\n\n#include \"types.h\"\n\n#ifndef __cplusplus\n#   error This header requires C++ to be used. aiFileIO.h is the \\\n    corresponding C interface.\n#endif\n\nnamespace Assimp    {\n\n// ----------------------------------------------------------------------------------\n/** @brief CPP-API: Class to handle file I/O for C++\n *\n *  Derive an own implementation from this interface to provide custom IO handling\n *  to the Importer. If you implement this interface, be sure to also provide an\n *  implementation for IOSystem that creates instances of your custom IO class.\n*/\nclass ASSIMP_API IOStream\n#ifndef SWIG\n    : public Intern::AllocateFromAssimpHeap\n#endif\n{\nprotected:\n    /** Constructor protected, use IOSystem::Open() to create an instance. */\n    IOStream() AI_NO_EXCEPT;\n\npublic:\n    // -------------------------------------------------------------------\n    /** @brief Destructor. Deleting the object closes the underlying file,\n     * alternatively you may use IOSystem::Close() to release the file.\n     */\n    virtual ~IOStream();\n\n    // -------------------------------------------------------------------\n    /** @brief Read from the file\n     *\n     * See fread() for more details\n     * This fails for write-only files */\n    virtual size_t Read(void* pvBuffer,\n        size_t pSize,\n        size_t pCount) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Write to the file\n    *\n    * See fwrite() for more details\n    * This fails for read-only files */\n    virtual size_t Write(const void* pvBuffer,\n        size_t pSize,\n        size_t pCount) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Set the read/write cursor of the file\n     *\n     * Note that the offset is _negative_ for aiOrigin_END.\n     * See fseek() for more details */\n    virtual aiReturn Seek(size_t pOffset,\n        aiOrigin pOrigin) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Get the current position of the read/write cursor\n     *\n     * See ftell() for more details */\n    virtual size_t Tell() const = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Returns filesize\n     *  Returns the filesize. */\n    virtual size_t FileSize() const = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Flush the contents of the file buffer (for writers)\n     *  See fflush() for more details.\n     */\n    virtual void Flush() = 0;\n}; //! class IOStream\n\n// ----------------------------------------------------------------------------------\ninline\nIOStream::IOStream() AI_NO_EXCEPT {\n    // empty\n}\n\n// ----------------------------------------------------------------------------------\ninline\nIOStream::~IOStream() {\n    // empty\n}\n// ----------------------------------------------------------------------------------\n\n} //!namespace Assimp\n\n#endif //!!AI_IOSTREAM_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/IOStream.hpp b/include/assimp/IOStream.hpp
--- a/include/assimp/IOStream.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/IOStream.hpp	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,14 +48,18 @@
 #ifndef AI_IOSTREAM_H_INC
 #define AI_IOSTREAM_H_INC
 
-#include "types.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
 
 #ifndef __cplusplus
 #   error This header requires C++ to be used. aiFileIO.h is the \
     corresponding C interface.
 #endif
 
-namespace Assimp    {
+namespace Assimp {
 
 // ----------------------------------------------------------------------------------
 /** @brief CPP-API: Class to handle file I/O for C++
@@ -125,13 +129,13 @@
 }; //! class IOStream
 
 // ----------------------------------------------------------------------------------
-inline
+AI_FORCE_INLINE
 IOStream::IOStream() AI_NO_EXCEPT {
     // empty
 }
 
 // ----------------------------------------------------------------------------------
-inline
+AI_FORCE_INLINE
 IOStream::~IOStream() {
     // empty
 }
Index: include/assimp/IOStreamBuffer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#include <assimp/types.h>\n#include <assimp/IOStream.hpp>\n\n#include \"ParsingUtils.h\"\n\n#include <vector>\n\nnamespace Assimp {\n\n// ---------------------------------------------------------------------------\n/**\n *  Implementation of a cached stream buffer.\n */\ntemplate<class T>\nclass IOStreamBuffer {\npublic:\n    /// @brief  The class constructor.\n    IOStreamBuffer( size_t cache = 4096 * 4096 );\n\n    /// @brief  The class destructor.\n    ~IOStreamBuffer();\n\n    /// @brief  Will open the cached access for a given stream.\n    /// @param  stream      The stream to cache.\n    /// @return true if successful.\n    bool open( IOStream *stream );\n\n    /// @brief  Will close the cached access.\n    /// @return true if successful.\n    bool close();\n\n    /// @brief  Returns the file-size.\n    /// @return The file-size.\n    size_t size() const;\n    \n    /// @brief  Returns the cache size.\n    /// @return The cache size.\n    size_t cacheSize() const;\n\n    /// @brief  Will read the next block.\n    /// @return true if successful.\n    bool readNextBlock();\n\n    /// @brief  Returns the number of blocks to read.\n    /// @return The number of blocks.\n    size_t getNumBlocks() const;\n\n    /// @brief  Returns the current block index.\n    /// @return The current block index.\n    size_t getCurrentBlockIndex() const;\n\n    /// @brief  Returns the current file pos.\n    /// @return The current file pos.\n    size_t getFilePos() const;\n\n    /// @brief  Will read the next line.\n    /// @param  buffer      The buffer for the next line.\n    /// @return true if successful.\n    bool getNextDataLine( std::vector<T> &buffer, T continuationToken );\n\n    /// @brief  Will read the next line ascii or binary end line char.\n    /// @param  buffer      The buffer for the next line.\n    /// @return true if successful.\n    bool getNextLine(std::vector<T> &buffer);\n\n    /// @brief  Will read the next block.\n    /// @param  buffer      The buffer for the next block.\n    /// @return true if successful.\n    bool getNextBlock( std::vector<T> &buffer );\n\nprivate:\n    IOStream *m_stream;\n    size_t m_filesize;\n    size_t m_cacheSize;\n    size_t m_numBlocks;\n    size_t m_blockIdx;\n    std::vector<T> m_cache;\n    size_t m_cachePos;\n    size_t m_filePos;\n};\n\ntemplate<class T>\ninline\nIOStreamBuffer<T>::IOStreamBuffer( size_t cache )\n: m_stream( nullptr )\n, m_filesize( 0 )\n, m_cacheSize( cache )\n, m_numBlocks( 0 )\n, m_blockIdx( 0 )\n, m_cachePos( 0 )\n, m_filePos( 0 ) {\n    m_cache.resize( cache );\n    std::fill( m_cache.begin(), m_cache.end(), '\\n' );\n}\n\ntemplate<class T>\ninline\nIOStreamBuffer<T>::~IOStreamBuffer() {\n    // empty\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::open( IOStream *stream ) {\n    //  file still opened!\n    if ( nullptr != m_stream ) {\n        return false;\n    }\n\n    //  Invalid stream pointer\n    if ( nullptr == stream ) {\n        return false;\n    }\n\n    m_stream = stream;\n    m_filesize = m_stream->FileSize();\n    if ( m_filesize == 0 ) {\n        return false;\n    }\n    if ( m_filesize < m_cacheSize ) {\n        m_cacheSize = m_filesize;\n    }\n\n    m_numBlocks = m_filesize / m_cacheSize;\n    if ( ( m_filesize % m_cacheSize ) > 0 ) {\n        m_numBlocks++;\n    }\n\n    return true;\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::close() {\n    if ( nullptr == m_stream ) {\n        return false;\n    }\n\n    // init counters and state vars\n    m_stream    = nullptr;\n    m_filesize  = 0;\n    m_numBlocks = 0;\n    m_blockIdx  = 0;\n    m_cachePos  = 0;\n    m_filePos   = 0;\n\n    return true;\n}\n\ntemplate<class T>\ninline\nsize_t IOStreamBuffer<T>::size() const {\n    return m_filesize;\n}\n\ntemplate<class T>\ninline\nsize_t IOStreamBuffer<T>::cacheSize() const {\n    return m_cacheSize;\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::readNextBlock() {\n    m_stream->Seek( m_filePos, aiOrigin_SET );\n    size_t readLen = m_stream->Read( &m_cache[ 0 ], sizeof( T ), m_cacheSize );\n    if ( readLen == 0 ) {\n        return false;\n    }\n    if ( readLen < m_cacheSize ) {\n        m_cacheSize = readLen;\n    }\n    m_filePos += m_cacheSize;\n    m_cachePos = 0;\n    m_blockIdx++;\n\n    return true;\n}\n\ntemplate<class T>\ninline\nsize_t IOStreamBuffer<T>::getNumBlocks() const {\n    return m_numBlocks;\n}\n\ntemplate<class T>\ninline\nsize_t IOStreamBuffer<T>::getCurrentBlockIndex() const {\n    return m_blockIdx;\n}\n\ntemplate<class T>\ninline\nsize_t IOStreamBuffer<T>::getFilePos() const {\n    return m_filePos;\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::getNextDataLine( std::vector<T> &buffer, T continuationToken ) {\n    buffer.resize( m_cacheSize );\n    if ( m_cachePos >= m_cacheSize || 0 == m_filePos ) {\n        if ( !readNextBlock() ) {\n            return false;\n        }\n    }\n\n    bool continuationFound( false );\n    size_t i = 0;\n    for( ;; ) {\n        if ( continuationToken == m_cache[ m_cachePos ] ) {\n            continuationFound = true;\n            ++m_cachePos;\n        }\n        if ( IsLineEnd( m_cache[ m_cachePos ] ) ) {\n            if ( !continuationFound ) {\n                // the end of the data line\n                break;\n            } else {\n                // skip line end\n                while ( m_cache[m_cachePos] != '\\n') {\n                    ++m_cachePos;\n                }\n                ++m_cachePos;\n                continuationFound = false;\n            }\n        }\n\n        buffer[ i ] = m_cache[ m_cachePos ];\n        ++m_cachePos;\n        ++i;\n        if (m_cachePos >= size()) {\n            break;\n        }\n        if ( m_cachePos >= m_cacheSize ) {\n            if ( !readNextBlock() ) {\n                return false;\n            }\n        }\n    }\n    \n    buffer[ i ] = '\\n';\n    ++m_cachePos;\n\n    return true;\n}\n\nstatic inline\nbool isEndOfCache( size_t pos, size_t cacheSize ) {\n    return ( pos == cacheSize );\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::getNextLine(std::vector<T> &buffer) {\n    buffer.resize(m_cacheSize);\n    if ( isEndOfCache( m_cachePos, m_cacheSize ) || 0 == m_filePos) {\n       if (!readNextBlock()) {\n          return false;\n       }\n      }\n\n    if (IsLineEnd(m_cache[m_cachePos])) {\n        // skip line end\n        while (m_cache[m_cachePos] != '\\n') {\n            ++m_cachePos;\n        }\n        ++m_cachePos;\n        if ( isEndOfCache( m_cachePos, m_cacheSize ) ) {\n            if ( !readNextBlock() ) {\n                return false;\n            }\n        }\n    }\n\n    size_t i( 0 );\n    while (!IsLineEnd(m_cache[ m_cachePos ])) {\n        buffer[i] = m_cache[ m_cachePos ];\n        ++m_cachePos;\n        ++i;\n        if (m_cachePos >= m_cacheSize) {\n            if (!readNextBlock()) {\n                return false;\n            }\n        }\n    }\n    buffer[i] = '\\n';\n    ++m_cachePos;\n\n    return true;\n}\n\ntemplate<class T>\ninline\nbool IOStreamBuffer<T>::getNextBlock( std::vector<T> &buffer) {\n    // Return the last block-value if getNextLine was used before\n    if ( 0 != m_cachePos ) {      \n        buffer = std::vector<T>( m_cache.begin() + m_cachePos, m_cache.end() );\n        m_cachePos = 0;\n    } else {\n        if ( !readNextBlock() ) {\n            return false;\n        }\n\n        buffer = std::vector<T>(m_cache.begin(), m_cache.end());\n    }\n\n    return true;\n}\n\n} // !ns Assimp\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/IOStreamBuffer.h b/include/assimp/IOStreamBuffer.h
--- a/include/assimp/IOStreamBuffer.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/IOStreamBuffer.h	(date 1617519895000)
@@ -1,10 +1,8 @@
-#pragma once
-
 /*
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -42,10 +40,17 @@
 ----------------------------------------------------------------------
 */
 
+#pragma once
+#ifndef AI_IOSTREAMBUFFER_H_INC
+#define AI_IOSTREAMBUFFER_H_INC
+
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
 #include <assimp/IOStream.hpp>
-
-#include "ParsingUtils.h"
+#include <assimp/ParsingUtils.h>
 
 #include <vector>
 
@@ -124,7 +129,7 @@
 };
 
 template<class T>
-inline
+AI_FORCE_INLINE
 IOStreamBuffer<T>::IOStreamBuffer( size_t cache )
 : m_stream( nullptr )
 , m_filesize( 0 )
@@ -138,13 +143,13 @@
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 IOStreamBuffer<T>::~IOStreamBuffer() {
     // empty
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::open( IOStream *stream ) {
     //  file still opened!
     if ( nullptr != m_stream ) {
@@ -174,7 +179,7 @@
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::close() {
     if ( nullptr == m_stream ) {
         return false;
@@ -192,19 +197,19 @@
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 size_t IOStreamBuffer<T>::size() const {
     return m_filesize;
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 size_t IOStreamBuffer<T>::cacheSize() const {
     return m_cacheSize;
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::readNextBlock() {
     m_stream->Seek( m_filePos, aiOrigin_SET );
     size_t readLen = m_stream->Read( &m_cache[ 0 ], sizeof( T ), m_cacheSize );
@@ -222,25 +227,25 @@
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 size_t IOStreamBuffer<T>::getNumBlocks() const {
     return m_numBlocks;
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 size_t IOStreamBuffer<T>::getCurrentBlockIndex() const {
     return m_blockIdx;
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 size_t IOStreamBuffer<T>::getFilePos() const {
     return m_filePos;
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextDataLine( std::vector<T> &buffer, T continuationToken ) {
     buffer.resize( m_cacheSize );
     if ( m_cachePos >= m_cacheSize || 0 == m_filePos ) {
@@ -289,13 +294,13 @@
     return true;
 }
 
-static inline
+static AI_FORCE_INLINE
 bool isEndOfCache( size_t pos, size_t cacheSize ) {
     return ( pos == cacheSize );
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextLine(std::vector<T> &buffer) {
     buffer.resize(m_cacheSize);
     if ( isEndOfCache( m_cachePos, m_cacheSize ) || 0 == m_filePos) {
@@ -335,7 +340,7 @@
 }
 
 template<class T>
-inline
+AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextBlock( std::vector<T> &buffer) {
     // Return the last block-value if getNextLine was used before
     if ( 0 != m_cachePos ) {      
@@ -353,3 +358,5 @@
 }
 
 } // !ns Assimp
+
+#endif // AI_IOSTREAMBUFFER_H_INC
Index: include/assimp/scene.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file scene.h\n *  @brief Defines the data structures in which the imported scene is returned.\n */\n#pragma once\n#ifndef AI_SCENE_H_INC\n#define AI_SCENE_H_INC\n\n#include \"types.h\"\n#include \"texture.h\"\n#include \"mesh.h\"\n#include \"light.h\"\n#include \"camera.h\"\n#include \"material.h\"\n#include \"anim.h\"\n#include \"metadata.h\"\n\n#ifdef __cplusplus\n#  include <cstdlib>\nextern \"C\" {\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wattributes\"\n#endif\n\n// -------------------------------------------------------------------------------\n/** \n * A node in the imported hierarchy.\n *\n * Each node has name, a parent node (except for the root node),\n * a transformation relative to its parent and possibly several child nodes.\n * Simple file formats don't support hierarchical structures - for these formats\n * the imported scene does consist of only a single root node without children.\n */\n// -------------------------------------------------------------------------------\nstruct ASSIMP_API aiNode\n{\n    /** The name of the node.\n     *\n     * The name might be empty (length of zero) but all nodes which\n     * need to be referenced by either bones or animations are named.\n     * Multiple nodes may have the same name, except for nodes which are referenced\n     * by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.\n     *\n     * Cameras and lights reference a specific node by name - if there\n     * are multiple nodes with this name, they are assigned to each of them.\n     * <br>\n     * There are no limitations with regard to the characters contained in\n     * the name string as it is usually taken directly from the source file.\n     *\n     * Implementations should be able to handle tokens such as whitespace, tabs,\n     * line feeds, quotation marks, ampersands etc.\n     *\n     * Sometimes assimp introduces new nodes not present in the source file\n     * into the hierarchy (usually out of necessity because sometimes the\n     * source hierarchy format is simply not compatible). Their names are\n     * surrounded by @verbatim <> @endverbatim e.g.\n     *  @verbatim<DummyRootNode> @endverbatim.\n     */\n    C_STRUCT aiString mName;\n\n    /** The transformation relative to the node's parent. */\n    C_STRUCT aiMatrix4x4 mTransformation;\n\n    /** Parent node. NULL if this node is the root node. */\n    C_STRUCT aiNode* mParent;\n\n    /** The number of child nodes of this node. */\n    unsigned int mNumChildren;\n\n    /** The child nodes of this node. NULL if mNumChildren is 0. */\n    C_STRUCT aiNode** mChildren;\n\n    /** The number of meshes of this node. */\n    unsigned int mNumMeshes;\n\n    /** The meshes of this node. Each entry is an index into the\n      * mesh list of the #aiScene.\n      */\n    unsigned int* mMeshes;\n\n    /** Metadata associated with this node or NULL if there is no metadata.\n      *  Whether any metadata is generated depends on the source file format. See the\n      * @link importer_notes @endlink page for more information on every source file\n      * format. Importers that don't document any metadata don't write any.\n      */\n    C_STRUCT aiMetadata* mMetaData;\n\n#ifdef __cplusplus\n    /** Constructor */\n    aiNode();\n\n    /** Construction from a specific name */\n    explicit aiNode(const std::string& name);\n\n    /** Destructor */\n    ~aiNode();\n\n    /** Searches for a node with a specific name, beginning at this\n     *  nodes. Normally you will call this method on the root node\n     *  of the scene.\n     *\n     *  @param name Name to search for\n     *  @return NULL or a valid Node if the search was successful.\n     */\n    inline \n    const aiNode* FindNode(const aiString& name) const {\n        return FindNode(name.data);\n    }\n\n    inline \n    aiNode* FindNode(const aiString& name) {\n        return FindNode(name.data);\n    }\n\n    const aiNode* FindNode(const char* name) const;\n\n    aiNode* FindNode(const char* name);\n\n    /**\n     * @brief   Will add new children.\n     * @param   numChildren  Number of children to add.\n     * @param   children     The array with pointers showing to the children.\n     */\n    void addChildren(unsigned int numChildren, aiNode **children);\n#endif // __cplusplus\n};\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\n// -------------------------------------------------------------------------------\n/**\n * Specifies that the scene data structure that was imported is not complete.\n * This flag bypasses some internal validations and allows the import\n * of animation skeletons, material libraries or camera animation paths\n * using Assimp. Most applications won't support such data.\n */\n#define AI_SCENE_FLAGS_INCOMPLETE   0x1\n\n/**\n * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)\n * if the validation is successful. In a validated scene you can be sure that\n * any cross references in the data structure (e.g. vertex indices) are valid.\n */\n#define AI_SCENE_FLAGS_VALIDATED    0x2\n\n/**\n * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)\n * if the validation is successful but some issues have been found.\n * This can for example mean that a texture that does not exist is referenced\n * by a material or that the bone weights for a vertex don't sum to 1.0 ... .\n * In most cases you should still be able to use the import. This flag could\n * be useful for applications which don't capture Assimp's log output.\n */\n#define AI_SCENE_FLAGS_VALIDATION_WARNING   0x4\n\n/**\n * This flag is currently only set by the aiProcess_JoinIdenticalVertices step.\n * It indicates that the vertices of the output meshes aren't in the internal\n * verbose format anymore. In the verbose format all vertices are unique,\n * no vertex is ever referenced by more than one face.\n */\n#define AI_SCENE_FLAGS_NON_VERBOSE_FORMAT   0x8\n\n /**\n * Denotes pure height-map terrain data. Pure terrains usually consist of quads,\n * sometimes triangles, in a regular grid. The x,y coordinates of all vertex\n * positions refer to the x,y coordinates on the terrain height map, the z-axis\n * stores the elevation at a specific point.\n *\n * TER (Terragen) and HMP (3D Game Studio) are height map formats.\n * @note Assimp is probably not the best choice for loading *huge* terrains -\n * fully triangulated data takes extremely much free store and should be avoided\n * as long as possible (typically you'll do the triangulation when you actually\n * need to render it).\n */\n#define AI_SCENE_FLAGS_TERRAIN 0x10\n\n /**\n * Specifies that the scene data can be shared between structures. For example:\n * one vertex in few faces. \\ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT can not be\n * used for this because \\ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT has internal\n * meaning about postprocessing steps.\n */\n#define AI_SCENE_FLAGS_ALLOW_SHARED\t\t\t0x20\n\n// -------------------------------------------------------------------------------\n/** The root structure of the imported data.\n *\n *  Everything that was imported from the given file can be accessed from here.\n *  Objects of this class are generally maintained and owned by Assimp, not\n *  by the caller. You shouldn't want to instance it, nor should you ever try to\n *  delete a given scene on your own.\n */\n// -------------------------------------------------------------------------------\nstruct aiScene\n{\n    /** Any combination of the AI_SCENE_FLAGS_XXX flags. By default\n    * this value is 0, no flags are set. Most applications will\n    * want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE\n    * bit set.\n    */\n    unsigned int mFlags;\n\n    /** The root node of the hierarchy.\n    *\n    * There will always be at least the root node if the import\n    * was successful (and no special flags have been set).\n    * Presence of further nodes depends on the format and content\n    * of the imported file.\n    */\n    C_STRUCT aiNode* mRootNode;\n\n    /** The number of meshes in the scene. */\n    unsigned int mNumMeshes;\n\n    /** The array of meshes.\n    *\n    * Use the indices given in the aiNode structure to access\n    * this array. The array is mNumMeshes in size. If the\n    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always\n    * be at least ONE material.\n    */\n    C_STRUCT aiMesh** mMeshes;\n\n    /** The number of materials in the scene. */\n    unsigned int mNumMaterials;\n\n    /** The array of materials.\n    *\n    * Use the index given in each aiMesh structure to access this\n    * array. The array is mNumMaterials in size. If the\n    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always\n    * be at least ONE material.\n    */\n    C_STRUCT aiMaterial** mMaterials;\n\n    /** The number of animations in the scene. */\n    unsigned int mNumAnimations;\n\n    /** The array of animations.\n    *\n    * All animations imported from the given file are listed here.\n    * The array is mNumAnimations in size.\n    */\n    C_STRUCT aiAnimation** mAnimations;\n\n    /** The number of textures embedded into the file */\n    unsigned int mNumTextures;\n\n    /** The array of embedded textures.\n    *\n    * Not many file formats embed their textures into the file.\n    * An example is Quake's MDL format (which is also used by\n    * some GameStudio versions)\n    */\n    C_STRUCT aiTexture** mTextures;\n\n    /** The number of light sources in the scene. Light sources\n    * are fully optional, in most cases this attribute will be 0\n        */\n    unsigned int mNumLights;\n\n    /** The array of light sources.\n    *\n    * All light sources imported from the given file are\n    * listed here. The array is mNumLights in size.\n    */\n    C_STRUCT aiLight** mLights;\n\n    /** The number of cameras in the scene. Cameras\n    * are fully optional, in most cases this attribute will be 0\n        */\n    unsigned int mNumCameras;\n\n    /** The array of cameras.\n    *\n    * All cameras imported from the given file are listed here.\n    * The array is mNumCameras in size. The first camera in the\n    * array (if existing) is the default camera view into\n    * the scene.\n    */\n    C_STRUCT aiCamera** mCameras;\n\n    /**\n     *  @brief  The global metadata assigned to the scene itself.\n     *\n     *  This data contains global metadata which belongs to the scene like \n     *  unit-conversions, versions, vendors or other model-specific data. This \n     *  can be used to store format-specific metadata as well.\n     */\n    C_STRUCT aiMetadata* mMetaData;\n\n\n#ifdef __cplusplus\n\n    //! Default constructor - set everything to 0/NULL\n    ASSIMP_API aiScene();\n\n    //! Destructor\n    ASSIMP_API ~aiScene();\n\n    //! Check whether the scene contains meshes\n    //! Unless no special scene flags are set this will always be true.\n    inline bool HasMeshes() const { \n        return mMeshes != NULL && mNumMeshes > 0; \n    }\n\n    //! Check whether the scene contains materials\n    //! Unless no special scene flags are set this will always be true.\n    inline bool HasMaterials() const { \n        return mMaterials != NULL && mNumMaterials > 0; \n    }\n\n    //! Check whether the scene contains lights\n    inline bool HasLights() const { \n        return mLights != NULL && mNumLights > 0; \n    }\n\n    //! Check whether the scene contains textures\n    inline bool HasTextures() const {\n        return mTextures != NULL && mNumTextures > 0; \n    }\n\n    //! Check whether the scene contains cameras\n    inline bool HasCameras() const {\n        return mCameras != NULL && mNumCameras > 0; \n    }\n\n    //! Check whether the scene contains animations\n    inline bool HasAnimations() const { \n        return mAnimations != NULL && mNumAnimations > 0; \n    }\n\n    //! Returns a short filename from a full path\n    static const char* GetShortFilename(const char* filename) {\n        const char* lastSlash = strrchr(filename, '/');\n        if (lastSlash == nullptr) {\n            lastSlash = strrchr(filename, '\\\\');\n        }\n        const char* shortFilename = lastSlash != nullptr ? lastSlash + 1 : filename;\n        return shortFilename;\n    }\n\n    //! Returns an embedded texture\n    const aiTexture* GetEmbeddedTexture(const char* filename) const {\n        // lookup using texture ID (if referenced like: \"*1\", \"*2\", etc.)\n        if ('*' == *filename) {\n            int index = std::atoi(filename + 1);\n            if (0 > index || mNumTextures <= static_cast<unsigned>(index))\n                return nullptr;\n            return mTextures[index];\n        }\n        // lookup using filename\n        const char* shortFilename = GetShortFilename(filename);\n        for (unsigned int i = 0; i < mNumTextures; i++) {\n            const char* shortTextureFilename = GetShortFilename(mTextures[i]->mFilename.C_Str());\n            if (strcmp(shortTextureFilename, shortFilename) == 0) {\n                return mTextures[i];\n            }\n        }\n        return nullptr;\n    }\n#endif // __cplusplus\n\n    /**  Internal data, do not touch */\n#ifdef __cplusplus\n    void* mPrivate;\n#else\n    char* mPrivate;\n#endif\n\n};\n\n#ifdef __cplusplus\n} //! namespace Assimp\n#endif\n\n#endif // AI_SCENE_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/scene.h b/include/assimp/scene.h
--- a/include/assimp/scene.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/scene.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,14 +48,18 @@
 #ifndef AI_SCENE_H_INC
 #define AI_SCENE_H_INC
 
-#include "types.h"
-#include "texture.h"
-#include "mesh.h"
-#include "light.h"
-#include "camera.h"
-#include "material.h"
-#include "anim.h"
-#include "metadata.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
+#include <assimp/texture.h>
+#include <assimp/mesh.h>
+#include <assimp/light.h>
+#include <assimp/camera.h>
+#include <assimp/material.h>
+#include <assimp/anim.h>
+#include <assimp/metadata.h>
 
 #ifdef __cplusplus
 #  include <cstdlib>
@@ -106,13 +110,13 @@
     /** The transformation relative to the node's parent. */
     C_STRUCT aiMatrix4x4 mTransformation;
 
-    /** Parent node. NULL if this node is the root node. */
+    /** Parent node. nullptr if this node is the root node. */
     C_STRUCT aiNode* mParent;
 
     /** The number of child nodes of this node. */
     unsigned int mNumChildren;
 
-    /** The child nodes of this node. NULL if mNumChildren is 0. */
+    /** The child nodes of this node. nullptr if mNumChildren is 0. */
     C_STRUCT aiNode** mChildren;
 
     /** The number of meshes of this node. */
@@ -123,7 +127,7 @@
       */
     unsigned int* mMeshes;
 
-    /** Metadata associated with this node or NULL if there is no metadata.
+    /** Metadata associated with this node or nullptr if there is no metadata.
       *  Whether any metadata is generated depends on the source file format. See the
       * @link importer_notes @endlink page for more information on every source file
       * format. Importers that don't document any metadata don't write any.
@@ -145,7 +149,7 @@
      *  of the scene.
      *
      *  @param name Name to search for
-     *  @return NULL or a valid Node if the search was successful.
+     *  @return nullptr or a valid Node if the search was successful.
      */
     inline 
     const aiNode* FindNode(const aiString& name) const {
@@ -340,7 +344,7 @@
 
 #ifdef __cplusplus
 
-    //! Default constructor - set everything to 0/NULL
+    //! Default constructor - set everything to 0/nullptr
     ASSIMP_API aiScene();
 
     //! Destructor
@@ -349,33 +353,33 @@
     //! Check whether the scene contains meshes
     //! Unless no special scene flags are set this will always be true.
     inline bool HasMeshes() const { 
-        return mMeshes != NULL && mNumMeshes > 0; 
+        return mMeshes != nullptr && mNumMeshes > 0; 
     }
 
     //! Check whether the scene contains materials
     //! Unless no special scene flags are set this will always be true.
     inline bool HasMaterials() const { 
-        return mMaterials != NULL && mNumMaterials > 0; 
+        return mMaterials != nullptr && mNumMaterials > 0; 
     }
 
     //! Check whether the scene contains lights
     inline bool HasLights() const { 
-        return mLights != NULL && mNumLights > 0; 
+        return mLights != nullptr && mNumLights > 0; 
     }
 
     //! Check whether the scene contains textures
     inline bool HasTextures() const {
-        return mTextures != NULL && mNumTextures > 0; 
+        return mTextures != nullptr && mNumTextures > 0; 
     }
 
     //! Check whether the scene contains cameras
     inline bool HasCameras() const {
-        return mCameras != NULL && mNumCameras > 0; 
+        return mCameras != nullptr && mNumCameras > 0; 
     }
 
     //! Check whether the scene contains animations
     inline bool HasAnimations() const { 
-        return mAnimations != NULL && mNumAnimations > 0; 
+        return mAnimations != nullptr && mNumAnimations > 0; 
     }
 
     //! Returns a short filename from a full path
Index: include/assimp/StringComparison.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Definition of platform independent string workers:\n\n   ASSIMP_itoa10\n   ASSIMP_stricmp\n   ASSIMP_strincmp\n\n   These functions are not consistently available on all platforms,\n   or the provided implementations behave too differently.\n*/\n#ifndef INCLUDED_AI_STRING_WORKERS_H\n#define INCLUDED_AI_STRING_WORKERS_H\n\n#include <assimp/ai_assert.h>\n#include <assimp/defs.h>\n#include \"StringComparison.h\"\n\n#include <string.h>\n#include <stdint.h>\n#include <string>\n\nnamespace Assimp    {\n\n// -------------------------------------------------------------------------------\n/** @brief itoa with a fixed base 10\n * 'itoa' is not consistently available on all platforms so it is quite useful\n * to have a small replacement function here. No need to use a full sprintf()\n * if we just want to print a number ...\n * @param out Output buffer\n * @param max Maximum number of characters to be written, including '\\0'.\n *   This parameter may not be 0.\n * @param number Number to be written\n * @return Length of the output string, excluding the '\\0'\n */\nAI_FORCE_INLINE\nunsigned int ASSIMP_itoa10( char* out, unsigned int max, int32_t number) {\n    ai_assert(NULL != out);\n\n    // write the unary minus to indicate we have a negative number\n    unsigned int written = 1u;\n    if (number < 0 && written < max)    {\n        *out++ = '-';\n        ++written;\n        number = -number;\n    }\n\n    // We begin with the largest number that is not zero.\n    int32_t cur = 1000000000; // 2147483648\n    bool mustPrint = false;\n    while (written < max)   {\n\n        const unsigned int digit = number / cur;\n        if (mustPrint || digit > 0 || 1 == cur) {\n            // print all future zeroe's from now\n            mustPrint = true;\n\n            *out++ = '0'+static_cast<char>(digit);\n\n            ++written;\n            number -= digit*cur;\n            if (1 == cur) {\n                break;\n            }\n        }\n        cur /= 10;\n    }\n\n    // append a terminal zero\n    *out++ = '\\0';\n    return written-1;\n}\n\n// -------------------------------------------------------------------------------\n/** @brief itoa with a fixed base 10 (Secure template overload)\n *  The compiler should choose this function if he or she is able to determine the\n *  size of the array automatically.\n */\ntemplate <size_t length>\nAI_FORCE_INLINE\nunsigned int ASSIMP_itoa10( char(& out)[length], int32_t number) {\n    return ASSIMP_itoa10(out,length,number);\n}\n\n// -------------------------------------------------------------------------------\n/** @brief Helper function to do platform independent string comparison.\n *\n *  This is required since stricmp() is not consistently available on\n *  all platforms. Some platforms use the '_' prefix, others don't even\n *  have such a function.\n *\n *  @param s1 First input string\n *  @param s2 Second input string\n *  @return 0 if the given strings are identical\n */\nAI_FORCE_INLINE\nint ASSIMP_stricmp(const char *s1, const char *s2) {\n    ai_assert( NULL != s1 );\n    ai_assert( NULL != s2 );\n\n#if (defined _MSC_VER)\n\n    return ::_stricmp(s1,s2);\n#elif defined( __GNUC__ )\n\n    return ::strcasecmp(s1,s2);\n#else\n\n    char c1, c2;\n    do  {\n        c1 = tolower(*s1++);\n        c2 = tolower(*s2++);\n    }\n    while ( c1 && (c1 == c2) );\n    return c1 - c2;\n#endif\n}\n\n// -------------------------------------------------------------------------------\n/** @brief Case independent comparison of two std::strings\n *\n *  @param a First  string\n *  @param b Second string\n *  @return 0 if a == b\n */\nAI_FORCE_INLINE\nint ASSIMP_stricmp(const std::string& a, const std::string& b) {\n    int i = (int)b.length()-(int)a.length();\n    return (i ? i : ASSIMP_stricmp(a.c_str(),b.c_str()));\n}\n\n// -------------------------------------------------------------------------------\n/** @brief Helper function to do platform independent string comparison.\n *\n *  This is required since strincmp() is not consistently available on\n *  all platforms. Some platforms use the '_' prefix, others don't even\n *  have such a function.\n *\n *  @param s1 First input string\n *  @param s2 Second input string\n *  @param n Macimum number of characters to compare\n *  @return 0 if the given strings are identical\n */\nAI_FORCE_INLINE\nint ASSIMP_strincmp(const char *s1, const char *s2, unsigned int n) {\n    ai_assert( NULL != s1 );\n    ai_assert( NULL != s2 );\n    if ( !n ) {\n        return 0;\n    }\n\n#if (defined _MSC_VER)\n\n    return ::_strnicmp(s1,s2,n);\n\n#elif defined( __GNUC__ )\n\n    return ::strncasecmp(s1,s2, n);\n\n#else\n    char c1, c2;\n    unsigned int p = 0;\n    do\n    {\n        if (p++ >= n)return 0;\n        c1 = tolower(*s1++);\n        c2 = tolower(*s2++);\n    }\n    while ( c1 && (c1 == c2) );\n\n    return c1 - c2;\n#endif\n}\n\n\n// -------------------------------------------------------------------------------\n/** @brief Evaluates an integer power\n *\n * todo: move somewhere where it fits better in than here\n */\nAI_FORCE_INLINE\nunsigned int integer_pow( unsigned int base, unsigned int power ) {\n    unsigned int res = 1;\n    for ( unsigned int i = 0; i < power; ++i ) {\n        res *= base;\n    }\n\n    return res;\n}\n\n} // end of namespace\n\n#endif // !  AI_STRINGCOMPARISON_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/StringComparison.h b/include/assimp/StringComparison.h
--- a/include/assimp/StringComparison.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/StringComparison.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -49,12 +49,17 @@
    These functions are not consistently available on all platforms,
    or the provided implementations behave too differently.
 */
+#pragma once
 #ifndef INCLUDED_AI_STRING_WORKERS_H
 #define INCLUDED_AI_STRING_WORKERS_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/ai_assert.h>
 #include <assimp/defs.h>
-#include "StringComparison.h"
+#include <assimp/StringComparison.h>
 
 #include <string.h>
 #include <stdint.h>
Index: include/assimp/matrix3x3.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file matrix3x3.inl\n *  @brief Inline implementation of the 3x3 matrix operators\n */\n#pragma once\n#ifndef AI_MATRIX3X3_INL_INC\n#define AI_MATRIX3X3_INL_INC\n\n#ifdef __cplusplus\n#include \"matrix3x3.h\"\n\n#include \"matrix4x4.h\"\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\n// ------------------------------------------------------------------------------------------------\n// Construction from a 4x4 matrix. The remaining parts of the matrix are ignored.\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>::aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix)\n{\n    a1 = pMatrix.a1; a2 = pMatrix.a2; a3 = pMatrix.a3;\n    b1 = pMatrix.b1; b2 = pMatrix.b2; b3 = pMatrix.b3;\n    c1 = pMatrix.c1; c2 = pMatrix.c2; c3 = pMatrix.c3;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& m)\n{\n    *this = aiMatrix3x3t<TReal>(m.a1 * a1 + m.b1 * a2 + m.c1 * a3,\n        m.a2 * a1 + m.b2 * a2 + m.c2 * a3,\n        m.a3 * a1 + m.b3 * a2 + m.c3 * a3,\n        m.a1 * b1 + m.b1 * b2 + m.c1 * b3,\n        m.a2 * b1 + m.b2 * b2 + m.c2 * b3,\n        m.a3 * b1 + m.b3 * b2 + m.c3 * b3,\n        m.a1 * c1 + m.b1 * c2 + m.c1 * c3,\n        m.a2 * c1 + m.b2 * c2 + m.c2 * c3,\n        m.a3 * c1 + m.b3 * c2 + m.c3 * c3);\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ntemplate <typename TOther>\naiMatrix3x3t<TReal>::operator aiMatrix3x3t<TOther> () const\n{\n    return aiMatrix3x3t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),\n        static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),\n        static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3));\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal> aiMatrix3x3t<TReal>::operator* (const aiMatrix3x3t<TReal>& m) const\n{\n    aiMatrix3x3t<TReal> temp( *this);\n    temp *= m;\n    return temp;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) {\n    switch ( p_iIndex ) {\n        case 0:\n            return &a1;\n        case 1:\n            return &b1;\n        case 2:\n            return &c1;\n        default:\n            break;\n    }\n    return &a1;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline const TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) const {\n    switch ( p_iIndex ) {\n        case 0:\n            return &a1;\n        case 1:\n            return &b1;\n        case 2:\n            return &c1;\n        default:\n            break;\n    }\n    return &a1;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiMatrix3x3t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const\n{\n    return a1 == m.a1 && a2 == m.a2 && a3 == m.a3 &&\n           b1 == m.b1 && b2 == m.b2 && b3 == m.b3 &&\n           c1 == m.c1 && c2 == m.c2 && c3 == m.c3;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline bool aiMatrix3x3t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const\n{\n    return !(*this == m);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline bool aiMatrix3x3t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {\n    return\n        std::abs(a1 - m.a1) <= epsilon &&\n        std::abs(a2 - m.a2) <= epsilon &&\n        std::abs(a3 - m.a3) <= epsilon &&\n        std::abs(b1 - m.b1) <= epsilon &&\n        std::abs(b2 - m.b2) <= epsilon &&\n        std::abs(b3 - m.b3) <= epsilon &&\n        std::abs(c1 - m.c1) <= epsilon &&\n        std::abs(c2 - m.c2) <= epsilon &&\n        std::abs(c3 - m.c3) <= epsilon;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Transpose()\n{\n    // (TReal&) don't remove, GCC complains cause of packed fields\n    std::swap( (TReal&)a2, (TReal&)b1);\n    std::swap( (TReal&)a3, (TReal&)c1);\n    std::swap( (TReal&)b3, (TReal&)c2);\n    return *this;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline TReal aiMatrix3x3t<TReal>::Determinant() const\n{\n    return a1*b2*c3 - a1*b3*c2 + a2*b3*c1 - a2*b1*c3 + a3*b1*c2 - a3*b2*c1;\n}\n\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Inverse()\n{\n    // Compute the reciprocal determinant\n    TReal det = Determinant();\n    if(det == static_cast<TReal>(0.0))\n    {\n        // Matrix not invertible. Setting all elements to nan is not really\n        // correct in a mathematical sense; but at least qnans are easy to\n        // spot. XXX we might throw an exception instead, which would\n        // be even much better to spot :/.\n        const TReal nan = std::numeric_limits<TReal>::quiet_NaN();\n        *this = aiMatrix3x3t<TReal>( nan,nan,nan,nan,nan,nan,nan,nan,nan);\n\n        return *this;\n    }\n\n    TReal invdet = static_cast<TReal>(1.0) / det;\n\n    aiMatrix3x3t<TReal> res;\n    res.a1 = invdet  * (b2 * c3 - b3 * c2);\n    res.a2 = -invdet * (a2 * c3 - a3 * c2);\n    res.a3 = invdet  * (a2 * b3 - a3 * b2);\n    res.b1 = -invdet * (b1 * c3 - b3 * c1);\n    res.b2 = invdet  * (a1 * c3 - a3 * c1);\n    res.b3 = -invdet * (a1 * b3 - a3 * b1);\n    res.c1 = invdet  * (b1 * c2 - b2 * c1);\n    res.c2 = -invdet * (a1 * c2 - a2 * c1);\n    res.c3 = invdet  * (a1 * b2 - a2 * b1);\n    *this = res;\n\n    return *this;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::RotationZ(TReal a, aiMatrix3x3t<TReal>& out)\n{\n    out.a1 = out.b2 = std::cos(a);\n    out.b1 = std::sin(a);\n    out.a2 = - out.b1;\n\n    out.a3 = out.b3 = out.c1 = out.c2 = 0.f;\n    out.c3 = 1.f;\n\n    return out;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Returns a rotation matrix for a rotation around an arbitrary axis.\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix3x3t<TReal>& out)\n{\n  TReal c = std::cos( a), s = std::sin( a), t = 1 - c;\n  TReal x = axis.x, y = axis.y, z = axis.z;\n\n  // Many thanks to MathWorld and Wikipedia\n  out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;\n  out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;\n  out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;\n\n  return out;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Translation( const aiVector2t<TReal>& v, aiMatrix3x3t<TReal>& out)\n{\n    out = aiMatrix3x3t<TReal>();\n    out.a3 = v.x;\n    out.b3 = v.y;\n    return out;\n}\n\n// ----------------------------------------------------------------------------------------\n/** A function for creating a rotation matrix that rotates a vector called\n * \"from\" into another vector called \"to\".\n * Input : from[3], to[3] which both must be *normalized* non-zero vectors\n * Output: mtx[3][3] -- a 3x3 matrix in colum-major form\n * Authors: Tomas Möller, John Hughes\n *          \"Efficiently Building a Matrix to Rotate One Vector to Another\"\n *          Journal of Graphics Tools, 4(4):1-4, 1999\n */\n// ----------------------------------------------------------------------------------------\ntemplate <typename TReal>\ninline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,\n    const aiVector3t<TReal>& to, aiMatrix3x3t<TReal>& mtx)\n{\n    const TReal e = from * to;\n    const TReal f = (e < 0)? -e:e;\n\n    if (f > static_cast<TReal>(1.0) - static_cast<TReal>(0.00001))     /* \"from\" and \"to\"-vector almost parallel */\n    {\n        aiVector3D u,v;     /* temporary storage vectors */\n        aiVector3D x;       /* vector most nearly orthogonal to \"from\" */\n\n        x.x = (from.x > 0.0)? from.x : -from.x;\n        x.y = (from.y > 0.0)? from.y : -from.y;\n        x.z = (from.z > 0.0)? from.z : -from.z;\n\n        if (x.x < x.y)\n        {\n            if (x.x < x.z)\n            {\n                x.x = static_cast<TReal>(1.0);\n                x.y = x.z = static_cast<TReal>(0.0);\n            }\n            else\n            {\n                x.z = static_cast<TReal>(1.0);\n                x.x = x.y = static_cast<TReal>(0.0);\n            }\n        }\n        else\n        {\n            if (x.y < x.z)\n            {\n                x.y = static_cast<TReal>(1.0);\n                x.x = x.z = static_cast<TReal>(0.0);\n            }\n            else\n            {\n                x.z = static_cast<TReal>(1.0);\n                x.x = x.y = static_cast<TReal>(0.0);\n            }\n        }\n\n        u.x = x.x - from.x; u.y = x.y - from.y; u.z = x.z - from.z;\n        v.x = x.x - to.x;   v.y = x.y - to.y;   v.z = x.z - to.z;\n\n        const TReal c1_ = static_cast<TReal>(2.0) / (u * u);\n        const TReal c2_ = static_cast<TReal>(2.0) / (v * v);\n        const TReal c3_ = c1_ * c2_  * (u * v);\n\n        for (unsigned int i = 0; i < 3; i++)\n        {\n            for (unsigned int j = 0; j < 3; j++)\n            {\n                mtx[i][j] =  - c1_ * u[i] * u[j] - c2_ * v[i] * v[j]\n                    + c3_ * v[i] * u[j];\n            }\n            mtx[i][i] += static_cast<TReal>(1.0);\n        }\n    }\n    else  /* the most common case, unless \"from\"=\"to\", or \"from\"=-\"to\" */\n    {\n        const aiVector3D v = from ^ to;\n        /* ... use this hand optimized version (9 mults less) */\n        const TReal h = static_cast<TReal>(1.0)/(static_cast<TReal>(1.0) + e);      /* optimization by Gottfried Chen */\n        const TReal hvx = h * v.x;\n        const TReal hvz = h * v.z;\n        const TReal hvxy = hvx * v.y;\n        const TReal hvxz = hvx * v.z;\n        const TReal hvyz = hvz * v.y;\n        mtx[0][0] = e + hvx * v.x;\n        mtx[0][1] = hvxy - v.z;\n        mtx[0][2] = hvxz + v.y;\n\n        mtx[1][0] = hvxy + v.z;\n        mtx[1][1] = e + h * v.y * v.y;\n        mtx[1][2] = hvyz - v.x;\n\n        mtx[2][0] = hvxz - v.y;\n        mtx[2][1] = hvyz + v.x;\n        mtx[2][2] = e + hvz * v.z;\n    }\n    return mtx;\n}\n\n\n#endif // __cplusplus\n#endif // AI_MATRIX3X3_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/matrix3x3.inl b/include/assimp/matrix3x3.inl
--- a/include/assimp/matrix3x3.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/matrix3x3.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,10 +48,14 @@
 #ifndef AI_MATRIX3X3_INL_INC
 #define AI_MATRIX3X3_INL_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
-#include "matrix3x3.h"
+#include <assimp/matrix3x3.h>
+#include <assimp/matrix4x4.h>
 
-#include "matrix4x4.h"
 #include <algorithm>
 #include <cmath>
 #include <limits>
@@ -59,8 +63,8 @@
 // ------------------------------------------------------------------------------------------------
 // Construction from a 4x4 matrix. The remaining parts of the matrix are ignored.
 template <typename TReal>
-inline aiMatrix3x3t<TReal>::aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix)
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>::aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix) {
     a1 = pMatrix.a1; a2 = pMatrix.a2; a3 = pMatrix.a3;
     b1 = pMatrix.b1; b2 = pMatrix.b2; b3 = pMatrix.b3;
     c1 = pMatrix.c1; c2 = pMatrix.c2; c3 = pMatrix.c3;
@@ -68,8 +72,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& m)
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& m) {
     *this = aiMatrix3x3t<TReal>(m.a1 * a1 + m.b1 * a2 + m.c1 * a3,
         m.a2 * a1 + m.b2 * a2 + m.c2 * a3,
         m.a3 * a1 + m.b3 * a2 + m.c3 * a3,
@@ -85,8 +89,7 @@
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
 template <typename TOther>
-aiMatrix3x3t<TReal>::operator aiMatrix3x3t<TOther> () const
-{
+aiMatrix3x3t<TReal>::operator aiMatrix3x3t<TOther> () const {
     return aiMatrix3x3t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),
         static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),
         static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3));
@@ -94,8 +97,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal> aiMatrix3x3t<TReal>::operator* (const aiMatrix3x3t<TReal>& m) const
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal> aiMatrix3x3t<TReal>::operator* (const aiMatrix3x3t<TReal>& m) const {
     aiMatrix3x3t<TReal> temp( *this);
     temp *= m;
     return temp;
@@ -103,7 +106,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) {
+AI_FORCE_INLINE
+TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) {
     switch ( p_iIndex ) {
         case 0:
             return &a1;
@@ -119,7 +123,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline const TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) const {
+AI_FORCE_INLINE
+const TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) const {
     switch ( p_iIndex ) {
         case 0:
             return &a1;
@@ -135,8 +140,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiMatrix3x3t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+bool aiMatrix3x3t<TReal>::operator== (const aiMatrix3x3t<TReal>& m) const {
     return a1 == m.a1 && a2 == m.a2 && a3 == m.a3 &&
            b1 == m.b1 && b2 == m.b2 && b3 == m.b3 &&
            c1 == m.c1 && c2 == m.c2 && c3 == m.c3;
@@ -144,14 +149,15 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline bool aiMatrix3x3t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const
-{
+AI_FORCE_INLINE
+bool aiMatrix3x3t<TReal>::operator!= (const aiMatrix3x3t<TReal>& m) const {
     return !(*this == m);
 }
 
 // ---------------------------------------------------------------------------
 template<typename TReal>
-inline bool aiMatrix3x3t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {
+AI_FORCE_INLINE
+bool aiMatrix3x3t<TReal>::Equal(const aiMatrix3x3t<TReal>& m, TReal epsilon) const {
     return
         std::abs(a1 - m.a1) <= epsilon &&
         std::abs(a2 - m.a2) <= epsilon &&
@@ -166,8 +172,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Transpose()
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Transpose() {
     // (TReal&) don't remove, GCC complains cause of packed fields
     std::swap( (TReal&)a2, (TReal&)b1);
     std::swap( (TReal&)a3, (TReal&)c1);
@@ -177,15 +183,15 @@
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline TReal aiMatrix3x3t<TReal>::Determinant() const
-{
+AI_FORCE_INLINE
+TReal aiMatrix3x3t<TReal>::Determinant() const {
     return a1*b2*c3 - a1*b3*c2 + a2*b3*c1 - a2*b1*c3 + a3*b1*c2 - a3*b2*c1;
 }
 
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Inverse()
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Inverse() {
     // Compute the reciprocal determinant
     TReal det = Determinant();
     if(det == static_cast<TReal>(0.0))
@@ -219,8 +225,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::RotationZ(TReal a, aiMatrix3x3t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::RotationZ(TReal a, aiMatrix3x3t<TReal>& out) {
     out.a1 = out.b2 = std::cos(a);
     out.b1 = std::sin(a);
     out.a2 = - out.b1;
@@ -234,8 +240,8 @@
 // ------------------------------------------------------------------------------------------------
 // Returns a rotation matrix for a rotation around an arbitrary axis.
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix3x3t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix3x3t<TReal>& out) {
   TReal c = std::cos( a), s = std::sin( a), t = 1 - c;
   TReal x = axis.x, y = axis.y, z = axis.z;
 
@@ -249,8 +255,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Translation( const aiVector2t<TReal>& v, aiMatrix3x3t<TReal>& out)
-{
+AI_FORCE_INLINE
+aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Translation( const aiVector2t<TReal>& v, aiMatrix3x3t<TReal>& out) {
     out = aiMatrix3x3t<TReal>();
     out.a3 = v.x;
     out.b3 = v.y;
@@ -268,9 +274,8 @@
  */
 // ----------------------------------------------------------------------------------------
 template <typename TReal>
-inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,
-    const aiVector3t<TReal>& to, aiMatrix3x3t<TReal>& mtx)
-{
+AI_FORCE_INLINE aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,
+        const aiVector3t<TReal>& to, aiMatrix3x3t<TReal>& mtx) {
     const TReal e = from * to;
     const TReal f = (e < 0)? -e:e;
 
@@ -352,6 +357,5 @@
     return mtx;
 }
 
-
 #endif // __cplusplus
 #endif // AI_MATRIX3X3_INL_INC
Index: include/assimp/matrix4x4.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n/** @file matrix4x4.h\n *  @brief 4x4 matrix structure, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_MATRIX4X4_H_INC\n#define AI_MATRIX4X4_H_INC\n\n#include \"vector3.h\"\n#include \"defs.h\"\n\n#ifdef __cplusplus\n\ntemplate<typename TReal> class aiMatrix3x3t;\ntemplate<typename TReal> class aiQuaterniont;\n\n// ---------------------------------------------------------------------------\n/** @brief Represents a row-major 4x4 matrix, use this for homogeneous\n *   coordinates.\n *\n *  There's much confusion about matrix layouts (column vs. row order).\n *  This is *always* a row-major matrix. Not even with the\n *  #aiProcess_ConvertToLeftHanded flag, which absolutely does not affect\n *  matrix order - it just affects the handedness of the coordinate system\n *  defined thereby.\n */\ntemplate<typename TReal>\nclass aiMatrix4x4t\n{\npublic:\n\n    /** set to identity */\n    aiMatrix4x4t() AI_NO_EXCEPT;\n\n    /** construction from single values */\n    aiMatrix4x4t (  TReal _a1, TReal _a2, TReal _a3, TReal _a4,\n                    TReal _b1, TReal _b2, TReal _b3, TReal _b4,\n                    TReal _c1, TReal _c2, TReal _c3, TReal _c4,\n                    TReal _d1, TReal _d2, TReal _d3, TReal _d4);\n\n\n    /** construction from 3x3 matrix, remaining elements are set to identity */\n    explicit aiMatrix4x4t( const aiMatrix3x3t<TReal>& m);\n\n    /** construction from position, rotation and scaling components\n     * @param scaling The scaling for the x,y,z axes\n     * @param rotation The rotation as a hamilton quaternion\n     * @param position The position for the x,y,z axes\n     */\n    aiMatrix4x4t(const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation,\n        const aiVector3t<TReal>& position);\n\npublic:\n\n    // array access operators\n\t/** @fn TReal* operator[] (unsigned int p_iIndex)\n\t *  @param [in] p_iIndex - index of the row.\n\t *  @return pointer to pointed row.\n\t */\n    TReal* operator[]       (unsigned int p_iIndex);\n\n\t/** @fn const TReal* operator[] (unsigned int p_iIndex) const\n\t *  @overload TReal* operator[] (unsigned int p_iIndex)\n\t */\n    const TReal* operator[] (unsigned int p_iIndex) const;\n\n    // comparison operators\n    bool operator== (const aiMatrix4x4t& m) const;\n    bool operator!= (const aiMatrix4x4t& m) const;\n\n    bool Equal(const aiMatrix4x4t& m, TReal epsilon = 1e-6) const;\n\n    // matrix multiplication.\n    aiMatrix4x4t& operator *= (const aiMatrix4x4t& m);\n    aiMatrix4x4t  operator *  (const aiMatrix4x4t& m) const;\n    aiMatrix4x4t operator * (const TReal& aFloat) const;\n    aiMatrix4x4t operator + (const aiMatrix4x4t& aMatrix) const;\n\n    template <typename TOther>\n    operator aiMatrix4x4t<TOther> () const;\n\npublic:\n\n    // -------------------------------------------------------------------\n    /** @brief Transpose the matrix */\n    aiMatrix4x4t& Transpose();\n\n    // -------------------------------------------------------------------\n    /** @brief Invert the matrix.\n     *  If the matrix is not invertible all elements are set to qnan.\n     *  Beware, use (f != f) to check whether a TReal f is qnan.\n     */\n    aiMatrix4x4t& Inverse();\n    TReal Determinant() const;\n\n\n    // -------------------------------------------------------------------\n    /** @brief Returns true of the matrix is the identity matrix.\n     *  The check is performed against a not so small epsilon.\n     */\n    inline bool IsIdentity() const;\n\n    // -------------------------------------------------------------------\n    /** @brief Decompose a trafo matrix into its original components\n     *  @param scaling Receives the output scaling for the x,y,z axes\n     *  @param rotation Receives the output rotation as a hamilton\n     *   quaternion\n     *  @param position Receives the output position for the x,y,z axes\n     */\n    void Decompose (aiVector3t<TReal>& scaling, aiQuaterniont<TReal>& rotation,\n        aiVector3t<TReal>& position) const;\n\n\t// -------------------------------------------------------------------\n\t/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const\n     *  @brief Decompose a trafo matrix into its original components.\n     * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat\n     *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.\n     *  @param [out] pRotation - Receives the output rotation as a Euler angles.\n     *  @param [out] pPosition - Receives the output position for the x,y,z axes.\n     */\n    void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const;\n\n\t// -------------------------------------------------------------------\n\t/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const\n     *  @brief Decompose a trafo matrix into its original components\n\t * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat\n     *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.\n     *  @param [out] pRotationAxis - Receives the output rotation axis.\n\t *  @param [out] pRotationAngle - Receives the output rotation angle for @ref pRotationAxis.\n     *  @param [out] pPosition - Receives the output position for the x,y,z axes.\n     */\n    void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Decompose a trafo matrix with no scaling into its\n     *    original components\n     *  @param rotation Receives the output rotation as a hamilton\n     *    quaternion\n     *  @param position Receives the output position for the x,y,z axes\n     */\n    void DecomposeNoScaling (aiQuaterniont<TReal>& rotation,\n        aiVector3t<TReal>& position) const;\n\n\n    // -------------------------------------------------------------------\n    /** @brief Creates a trafo matrix from a set of euler angles\n     *  @param x Rotation angle for the x-axis, in radians\n     *  @param y Rotation angle for the y-axis, in radians\n     *  @param z Rotation angle for the z-axis, in radians\n     */\n    aiMatrix4x4t& FromEulerAnglesXYZ(TReal x, TReal y, TReal z);\n    aiMatrix4x4t& FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb);\n\npublic:\n    // -------------------------------------------------------------------\n    /** @brief Returns a rotation matrix for a rotation around the x axis\n     *  @param a Rotation angle, in radians\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& RotationX(TReal a, aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a rotation matrix for a rotation around the y axis\n     *  @param a Rotation angle, in radians\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& RotationY(TReal a, aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a rotation matrix for a rotation around the z axis\n     *  @param a Rotation angle, in radians\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& RotationZ(TReal a, aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** Returns a rotation matrix for a rotation around an arbitrary axis.\n     *  @param a Rotation angle, in radians\n     *  @param axis Rotation axis, should be a normalized vector.\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& Rotation(TReal a, const aiVector3t<TReal>& axis,\n            aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a translation matrix\n     *  @param v Translation vector\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v, \n            aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief Returns a scaling matrix\n     *  @param v Scaling vector\n     *  @param out Receives the output matrix\n     *  @return Reference to the output matrix\n     */\n    static aiMatrix4x4t& Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t& out);\n\n    // -------------------------------------------------------------------\n    /** @brief A function for creating a rotation matrix that rotates a\n     *  vector called \"from\" into another vector called \"to\".\n     * Input : from[3], to[3] which both must be *normalized* non-zero vectors\n     * Output: mtx[3][3] -- a 3x3 matrix in column-major form\n     * Authors: Tomas Mueller, John Hughes\n     *          \"Efficiently Building a Matrix to Rotate One Vector to Another\"\n     *          Journal of Graphics Tools, 4(4):1-4, 1999\n     */\n    static aiMatrix4x4t& FromToMatrix(const aiVector3t<TReal>& from,\n            const aiVector3t<TReal>& to, aiMatrix4x4t& out);\n\npublic:\n    TReal a1, a2, a3, a4;\n    TReal b1, b2, b3, b4;\n    TReal c1, c2, c3, c4;\n    TReal d1, d2, d3, d4;\n};\n\ntypedef aiMatrix4x4t<ai_real> aiMatrix4x4;\n\n#else\n\nstruct aiMatrix4x4 {\n    ai_real a1, a2, a3, a4;\n    ai_real b1, b2, b3, b4;\n    ai_real c1, c2, c3, c4;\n    ai_real d1, d2, d3, d4;\n};\n\n\n#endif // __cplusplus\n\n#endif // AI_MATRIX4X4_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/matrix4x4.h b/include/assimp/matrix4x4.h
--- a/include/assimp/matrix4x4.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/matrix4x4.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -47,8 +47,12 @@
 #ifndef AI_MATRIX4X4_H_INC
 #define AI_MATRIX4X4_H_INC
 
-#include "vector3.h"
-#include "defs.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/vector3.h>
+#include <assimp/defs.h>
 
 #ifdef __cplusplus
 
@@ -66,8 +70,7 @@
  *  defined thereby.
  */
 template<typename TReal>
-class aiMatrix4x4t
-{
+class aiMatrix4x4t {
 public:
 
     /** set to identity */
@@ -91,8 +94,6 @@
     aiMatrix4x4t(const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation,
         const aiVector3t<TReal>& position);
 
-public:
-
     // array access operators
 	/** @fn TReal* operator[] (unsigned int p_iIndex)
 	 *  @param [in] p_iIndex - index of the row.
@@ -120,8 +121,6 @@
     template <typename TOther>
     operator aiMatrix4x4t<TOther> () const;
 
-public:
-
     // -------------------------------------------------------------------
     /** @brief Transpose the matrix */
     aiMatrix4x4t& Transpose();
@@ -182,7 +181,6 @@
     void DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
         aiVector3t<TReal>& position) const;
 
-
     // -------------------------------------------------------------------
     /** @brief Creates a trafo matrix from a set of euler angles
      *  @param x Rotation angle for the x-axis, in radians
@@ -192,7 +190,6 @@
     aiMatrix4x4t& FromEulerAnglesXYZ(TReal x, TReal y, TReal z);
     aiMatrix4x4t& FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb);
 
-public:
     // -------------------------------------------------------------------
     /** @brief Returns a rotation matrix for a rotation around the x axis
      *  @param a Rotation angle, in radians
@@ -256,7 +253,6 @@
     static aiMatrix4x4t& FromToMatrix(const aiVector3t<TReal>& from,
             const aiVector3t<TReal>& to, aiMatrix4x4t& out);
 
-public:
     TReal a1, a2, a3, a4;
     TReal b1, b2, b3, b4;
     TReal c1, c2, c3, c4;
Index: include/assimp/Profiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Profiler.h\n *  @brief Utility to measure the respective runtime of each import step\n */\n#ifndef INCLUDED_PROFILER_H\n#define INCLUDED_PROFILER_H\n\n#include <chrono>\n#include <assimp/DefaultLogger.hpp>\n#include \"TinyFormatter.h\"\n\n#include <map>\n\nnamespace Assimp {\nnamespace Profiling {\n\nusing namespace Formatter;\n\n// ------------------------------------------------------------------------------------------------\n/** Simple wrapper around boost::timer to simplify reporting. Timings are automatically\n *  dumped to the log file.\n */\nclass Profiler {\npublic:\n    Profiler() {\n        // empty\n    }\n\npublic:\n\n    /** Start a named timer */\n    void BeginRegion(const std::string& region) {\n        regions[region] = std::chrono::system_clock::now();\n        ASSIMP_LOG_DEBUG((format(\"START `\"),region,\"`\"));\n    }\n\n\n    /** End a specific named timer and write its end time to the log */\n    void EndRegion(const std::string& region) {\n        RegionMap::const_iterator it = regions.find(region);\n        if (it == regions.end()) {\n            return;\n        }\n\n        std::chrono::duration<double> elapsedSeconds = std::chrono::system_clock::now() - regions[region];\n        ASSIMP_LOG_DEBUG((format(\"END   `\"),region,\"`, dt= \", elapsedSeconds.count(),\" s\"));\n    }\n\nprivate:\n    typedef std::map<std::string,std::chrono::time_point<std::chrono::system_clock>> RegionMap;\n    RegionMap regions;\n};\n\n}\n}\n\n#endif\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Profiler.h b/include/assimp/Profiler.h
--- a/include/assimp/Profiler.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Profiler.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -43,12 +43,17 @@
 /** @file Profiler.h
  *  @brief Utility to measure the respective runtime of each import step
  */
-#ifndef INCLUDED_PROFILER_H
-#define INCLUDED_PROFILER_H
+#pragma once
+#ifndef AI_INCLUDED_PROFILER_H
+#define AI_INCLUDED_PROFILER_H
+
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
 
 #include <chrono>
 #include <assimp/DefaultLogger.hpp>
-#include "TinyFormatter.h"
+#include <assimp/TinyFormatter.h>
 
 #include <map>
 
@@ -67,7 +72,6 @@
         // empty
     }
 
-public:
 
     /** Start a named timer */
     void BeginRegion(const std::string& region) {
@@ -95,5 +99,5 @@
 }
 }
 
-#endif
+#endif // AI_INCLUDED_PROFILER_H
 
Index: include/assimp/fast_atof.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n// Copyright (C) 2002-2007 Nikolaus Gebhardt\n// This file is part of the \"Irrlicht Engine\" and the \"irrXML\" project.\n// For conditions of distribution and use, see copyright notice in irrlicht.h and irrXML.h\n\n// ------------------------------------------------------------------------------------\n// Original description: (Schrompf)\n// Adapted to the ASSIMP library because the builtin atof indeed takes AGES to parse a\n// float inside a large string. Before parsing, it does a strlen on the given point.\n// Changes:\n//  22nd October 08 (Aramis_acg): Added temporary cast to double, added strtoul10_64\n//     to ensure long numbers are handled correctly\n// ------------------------------------------------------------------------------------\n\n\n#ifndef FAST_A_TO_F_H_INCLUDED\n#define FAST_A_TO_F_H_INCLUDED\n\n#include <cmath>\n#include <limits>\n#include <stdint.h>\n#include <stdexcept>\n#include <assimp/defs.h>\n\n#include \"StringComparison.h\"\n#include <assimp/DefaultLogger.hpp>\n\n#ifdef _MSC_VER\n#  include <stdint.h>\n#else\n#  include <assimp/Compiler/pstdint.h>\n#endif\n\nnamespace Assimp {\n\nconst double fast_atof_table[16] =  {  // we write [16] here instead of [] to work around a swig bug\n    0.0,\n    0.1,\n    0.01,\n    0.001,\n    0.0001,\n    0.00001,\n    0.000001,\n    0.0000001,\n    0.00000001,\n    0.000000001,\n    0.0000000001,\n    0.00000000001,\n    0.000000000001,\n    0.0000000000001,\n    0.00000000000001,\n    0.000000000000001\n};\n\n\n// ------------------------------------------------------------------------------------\n// Convert a string in decimal format to a number\n// ------------------------------------------------------------------------------------\ninline\nunsigned int strtoul10( const char* in, const char** out=0) {\n    unsigned int value = 0;\n\n    for ( ;; ) {\n        if ( *in < '0' || *in > '9' ) {\n            break;\n        }\n\n        value = ( value * 10 ) + ( *in - '0' );\n        ++in;\n    }\n    if ( out ) {\n        *out = in;\n    }\n    return value;\n}\n\n// ------------------------------------------------------------------------------------\n// Convert a string in octal format to a number\n// ------------------------------------------------------------------------------------\ninline\nunsigned int strtoul8( const char* in, const char** out=0) {\n    unsigned int value( 0 );\n    for ( ;; ) {\n        if ( *in < '0' || *in > '7' ) {\n            break;\n        }\n\n        value = ( value << 3 ) + ( *in - '0' );\n        ++in;\n    }\n    if ( out ) {\n        *out = in;\n    }\n    return value;\n}\n\n// ------------------------------------------------------------------------------------\n// Convert a string in hex format to a number\n// ------------------------------------------------------------------------------------\ninline\nunsigned int strtoul16( const char* in, const char** out=0) {\n    unsigned int value( 0 );\n    for ( ;; ) {\n        if ( *in >= '0' && *in <= '9' ) {\n            value = ( value << 4u ) + ( *in - '0' );\n        } else if (*in >= 'A' && *in <= 'F') {\n            value = ( value << 4u ) + ( *in - 'A' ) + 10;\n        } else if (*in >= 'a' && *in <= 'f') {\n            value = ( value << 4u ) + ( *in - 'a' ) + 10;\n        } else {\n            break;\n        }\n        ++in;\n    }\n    if ( out ) {\n        *out = in;\n    }\n    return value;\n}\n\n// ------------------------------------------------------------------------------------\n// Convert just one hex digit\n// Return value is UINT_MAX if the input character is not a hex digit.\n// ------------------------------------------------------------------------------------\ninline\nunsigned int HexDigitToDecimal(char in) {\n    unsigned int out( UINT_MAX );\n    if ( in >= '0' && in <= '9' ) {\n        out = in - '0';\n    } else if ( in >= 'a' && in <= 'f' ) {\n        out = 10u + in - 'a';\n    } else if ( in >= 'A' && in <= 'F' ) {\n        out = 10u + in - 'A';\n    }\n\n    // return value is UINT_MAX if the input is not a hex digit\n    return out;\n}\n\n// ------------------------------------------------------------------------------------\n// Convert a hex-encoded octet (2 characters, i.e. df or 1a).\n// ------------------------------------------------------------------------------------\ninline\nuint8_t HexOctetToDecimal(const char* in) {\n    return ((uint8_t)HexDigitToDecimal(in[0])<<4)+(uint8_t)HexDigitToDecimal(in[1]);\n}\n\n// ------------------------------------------------------------------------------------\n// signed variant of strtoul10\n// ------------------------------------------------------------------------------------\ninline\nint strtol10( const char* in, const char** out=0) {\n    bool inv = (*in=='-');\n    if ( inv || *in == '+' ) {\n        ++in;\n    }\n\n    int value = strtoul10(in,out);\n    if (inv) {\n        value = -value;\n    }\n    return value;\n}\n\n// ------------------------------------------------------------------------------------\n// Parse a C++-like integer literal - hex and oct prefixes.\n// 0xNNNN - hex\n// 0NNN   - oct\n// NNN    - dec\n// ------------------------------------------------------------------------------------\ninline\nunsigned int strtoul_cppstyle( const char* in, const char** out=0) {\n    if ('0' == in[0]) {\n        return 'x' == in[1] ? strtoul16(in+2,out) : strtoul8(in+1,out);\n    }\n    return strtoul10(in, out);\n}\n\n// ------------------------------------------------------------------------------------\n// Special version of the function, providing higher accuracy and safety\n// It is mainly used by fast_atof to prevent ugly and unwanted integer overflows.\n// ------------------------------------------------------------------------------------\ninline\nuint64_t strtoul10_64( const char* in, const char** out=0, unsigned int* max_inout=0) {\n    unsigned int cur = 0;\n    uint64_t value = 0;\n\n    if ( *in < '0' || *in > '9' ) {\n        throw std::invalid_argument( std::string( \"The string \\\"\" ) + in + \"\\\" cannot be converted into a value.\" );\n    }\n\n    for ( ;; ) {\n        if ( *in < '0' || *in > '9' ) {\n            break;\n        }\n\n        const uint64_t new_value = ( value * (uint64_t) 10 ) + ( (uint64_t) ( *in - '0' ) );\n\n        // numeric overflow, we rely on you\n        if ( new_value < value ) {\n            ASSIMP_LOG_WARN_F( \"Converting the string \\\"\", in, \"\\\" into a value resulted in overflow.\" );\n            return 0;\n        }\n\n        value = new_value;\n\n        ++in;\n        ++cur;\n\n        if (max_inout && *max_inout == cur) {\n            if (out) { /* skip to end */\n                while ( *in >= '0' && *in <= '9' ) {\n                    ++in;\n                }\n                *out = in;\n            }\n\n            return value;\n        }\n    }\n    if ( out ) {\n        *out = in;\n    }\n\n    if ( max_inout ) {\n        *max_inout = cur;\n    }\n\n    return value;\n}\n\n// ------------------------------------------------------------------------------------\n// signed variant of strtoul10_64\n// ------------------------------------------------------------------------------------\ninline\nint64_t strtol10_64(const char* in, const char** out = 0, unsigned int* max_inout = 0) {\n    bool inv = (*in == '-');\n    if ( inv || *in == '+' ) {\n        ++in;\n    }\n\n    int64_t value = strtoul10_64(in, out, max_inout);\n    if (inv) {\n        value = -value;\n    }\n    return value;\n}\n\n// Number of relevant decimals for floating-point parsing.\n#define AI_FAST_ATOF_RELAVANT_DECIMALS 15\n\n// ------------------------------------------------------------------------------------\n//! Provides a fast function for converting a string into a float,\n//! about 6 times faster than atof in win32.\n// If you find any bugs, please send them to me, niko (at) irrlicht3d.org.\n// ------------------------------------------------------------------------------------\ntemplate<typename Real>\ninline\nconst char* fast_atoreal_move(const char* c, Real& out, bool check_comma = true) {\n    Real f = 0;\n\n    bool inv = (*c == '-');\n    if (inv || *c == '+') {\n        ++c;\n    }\n\n    if ((c[0] == 'N' || c[0] == 'n') && ASSIMP_strincmp(c, \"nan\", 3) == 0) {\n        out = std::numeric_limits<Real>::quiet_NaN();\n        c += 3;\n        return c;\n    }\n\n    if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, \"inf\", 3) == 0) {\n        out = std::numeric_limits<Real>::infinity();\n        if (inv) {\n            out = -out;\n        }\n        c += 3;\n        if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, \"inity\", 5) == 0) {\n            c += 5;\n        }\n        return c;\n     }\n\n    if (!(c[0] >= '0' && c[0] <= '9') &&\n            !((c[0] == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9')) {\n        throw std::invalid_argument(\"Cannot parse string \"\n                                    \"as real number: does not start with digit \"\n                                    \"or decimal point followed by digit.\");\n    }\n\n    if (*c != '.' && (! check_comma || c[0] != ',')) {\n        f = static_cast<Real>( strtoul10_64 ( c, &c) );\n    }\n\n    if ((*c == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9') {\n        ++c;\n\n        // NOTE: The original implementation is highly inaccurate here. The precision of a single\n        // IEEE 754 float is not high enough, everything behind the 6th digit tends to be more\n        // inaccurate than it would need to be. Casting to double seems to solve the problem.\n        // strtol_64 is used to prevent integer overflow.\n\n        // Another fix: this tends to become 0 for long numbers if we don't limit the maximum\n        // number of digits to be read. AI_FAST_ATOF_RELAVANT_DECIMALS can be a value between\n        // 1 and 15.\n        unsigned int diff = AI_FAST_ATOF_RELAVANT_DECIMALS;\n        double pl = static_cast<double>( strtoul10_64 ( c, &c, &diff ));\n\n        pl *= fast_atof_table[diff];\n        f += static_cast<Real>( pl );\n    }\n    // For backwards compatibility: eat trailing dots, but not trailing commas.\n    else if (*c == '.') {\n        ++c;\n    }\n\n    // A major 'E' must be allowed. Necessary for proper reading of some DXF files.\n    // Thanks to Zhao Lei to point out that this if() must be outside the if (*c == '.' ..)\n    if (*c == 'e' || *c == 'E') {\n        ++c;\n        const bool einv = (*c=='-');\n        if (einv || *c=='+') {\n            ++c;\n        }\n\n        // The reason float constants are used here is that we've seen cases where compilers\n        // would perform such casts on compile-time constants at runtime, which would be\n        // bad considering how frequently fast_atoreal_move<float> is called in Assimp.\n        Real exp = static_cast<Real>( strtoul10_64(c, &c) );\n        if (einv) {\n            exp = -exp;\n        }\n        f *= std::pow(static_cast<Real>(10.0), exp);\n    }\n\n    if (inv) {\n        f = -f;\n    }\n    out = f;\n    return c;\n}\n\n// ------------------------------------------------------------------------------------\n// The same but more human.\ninline\nai_real fast_atof(const char* c) {\n    ai_real ret(0.0);\n    fast_atoreal_move<ai_real>(c, ret);\n\n    return ret;\n}\n\ninline\nai_real fast_atof( const char* c, const char** cout) {\n    ai_real ret(0.0);\n    *cout = fast_atoreal_move<ai_real>(c, ret);\n\n    return ret;\n}\n\ninline\nai_real fast_atof( const char** inout) {\n    ai_real ret(0.0);\n    *inout = fast_atoreal_move<ai_real>(*inout, ret);\n\n    return ret;\n}\n\n} //! namespace Assimp\n\n#endif // FAST_A_TO_F_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/fast_atof.h b/include/assimp/fast_atof.h
--- a/include/assimp/fast_atof.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/fast_atof.h	(date 1617519895000)
@@ -13,10 +13,14 @@
 //     to ensure long numbers are handled correctly
 // ------------------------------------------------------------------------------------
 
-
+#pragma once
 #ifndef FAST_A_TO_F_H_INCLUDED
 #define FAST_A_TO_F_H_INCLUDED
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <cmath>
 #include <limits>
 #include <stdint.h>
Index: include/assimp/XMLTools.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#ifndef INCLUDED_ASSIMP_XML_TOOLS_H\n#define INCLUDED_ASSIMP_XML_TOOLS_H\n\n#include <string>\n\nnamespace Assimp {\n    // XML escape the 5 XML special characters (\",',<,> and &) in |data|\n    // Based on http://stackoverflow.com/questions/5665231\n    std::string XMLEscape(const std::string& data) {\n        std::string buffer;\n\n        const size_t size = data.size();\n        buffer.reserve(size + size / 8);\n        for(size_t i = 0; i < size; ++i) {\n            const char c = data[i];\n            switch(c) {\n                case '&' :\n                    buffer.append(\"&amp;\");\n                    break;\n                case '\\\"':\n                    buffer.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    buffer.append(\"&apos;\");\n                    break;\n                case '<' :\n                    buffer.append(\"&lt;\");\n                    break;\n                case '>' :\n                    buffer.append(\"&gt;\");\n                    break;\n                default:\n                    buffer.append(&c, 1);\n                    break;\n            }\n        }\n        return buffer;\n    }\n}\n\n#endif // INCLUDED_ASSIMP_XML_TOOLS_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/XMLTools.h b/include/assimp/XMLTools.h
--- a/include/assimp/XMLTools.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/XMLTools.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -40,9 +40,14 @@
 ----------------------------------------------------------------------
 */
 
+#pragma once
 #ifndef INCLUDED_ASSIMP_XML_TOOLS_H
 #define INCLUDED_ASSIMP_XML_TOOLS_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <string>
 
 namespace Assimp {
Index: include/assimp/light.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file light.h\n *  @brief Defines the aiLight data structure\n */\n\n#pragma once\n#ifndef AI_LIGHT_H_INC\n#define AI_LIGHT_H_INC\n\n#include \"types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n/** Enumerates all supported types of light sources.\n */\nenum aiLightSourceType\n{\n    aiLightSource_UNDEFINED     = 0x0,\n\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    aiLightSource_DIRECTIONAL   = 0x1,\n\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    aiLightSource_POINT         = 0x2,\n\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    aiLightSource_SPOT          = 0x3,\n\n    //! The generic light level of the world, including the bounces\n    //! of all other light sources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    aiLightSource_AMBIENT       = 0x4,\n\n    //! An area light is a rectangle with predefined size that uniformly\n    //! emits light from one of its sides. The position is center of the\n    //! rectangle and direction is its normal vector.\n    aiLightSource_AREA          = 0x5,\n\n    /** This value is not used. It is just there to force the\n     *  compiler to map this enum to a 32 Bit integer.\n     */\n#ifndef SWIG\n    _aiLightSource_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Helper structure to describe a light source.\n *\n *  Assimp supports multiple sorts of light sources, including\n *  directional, point and spot lights. All of them are defined with just\n *  a single structure and distinguished by their parameters.\n *  Note - some file formats (such as 3DS, ASE) export a \"target point\" -\n *  the point a spot light is looking at (it can even be animated). Assimp\n *  writes the target point as a subnode of a spotlights's main node,\n *  called \"<spotName>.Target\". However, this is just additional information\n *  then, the transformation tracks of the main node make the\n *  spot light already point in the right direction.\n*/\nstruct aiLight\n{\n    /** The name of the light source.\n     *\n     *  There must be a node in the scenegraph with the same name.\n     *  This node specifies the position of the light in the scene\n     *  hierarchy and can be animated.\n     */\n    C_STRUCT aiString mName;\n\n    /** The type of the light source.\n     *\n     * aiLightSource_UNDEFINED is not a valid value for this member.\n     */\n    C_ENUM aiLightSourceType mType;\n\n    /** Position of the light source in space. Relative to the\n     *  transformation of the node corresponding to the light.\n     *\n     *  The position is undefined for directional lights.\n     */\n    C_STRUCT aiVector3D mPosition;\n\n    /** Direction of the light source in space. Relative to the\n     *  transformation of the node corresponding to the light.\n     *\n     *  The direction is undefined for point lights. The vector\n     *  may be normalized, but it needn't.\n     */\n    C_STRUCT aiVector3D mDirection;\n\n    /** Up direction of the light source in space. Relative to the\n     *  transformation of the node corresponding to the light.\n     *\n     *  The direction is undefined for point lights. The vector\n     *  may be normalized, but it needn't.\n     */\n    C_STRUCT aiVector3D mUp;\n\n    /** Constant light attenuation factor.\n     *\n     *  The intensity of the light source at a given distance 'd' from\n     *  the light's position is\n     *  @code\n     *  Atten = 1/( att0 + att1 * d + att2 * d*d)\n     *  @endcode\n     *  This member corresponds to the att0 variable in the equation.\n     *  Naturally undefined for directional lights.\n     */\n    float mAttenuationConstant;\n\n    /** Linear light attenuation factor.\n     *\n     *  The intensity of the light source at a given distance 'd' from\n     *  the light's position is\n     *  @code\n     *  Atten = 1/( att0 + att1 * d + att2 * d*d)\n     *  @endcode\n     *  This member corresponds to the att1 variable in the equation.\n     *  Naturally undefined for directional lights.\n     */\n    float mAttenuationLinear;\n\n    /** Quadratic light attenuation factor.\n     *\n     *  The intensity of the light source at a given distance 'd' from\n     *  the light's position is\n     *  @code\n     *  Atten = 1/( att0 + att1 * d + att2 * d*d)\n     *  @endcode\n     *  This member corresponds to the att2 variable in the equation.\n     *  Naturally undefined for directional lights.\n     */\n    float mAttenuationQuadratic;\n\n    /** Diffuse color of the light source\n     *\n     *  The diffuse light color is multiplied with the diffuse\n     *  material color to obtain the final color that contributes\n     *  to the diffuse shading term.\n     */\n    C_STRUCT aiColor3D mColorDiffuse;\n\n    /** Specular color of the light source\n     *\n     *  The specular light color is multiplied with the specular\n     *  material color to obtain the final color that contributes\n     *  to the specular shading term.\n     */\n    C_STRUCT aiColor3D mColorSpecular;\n\n    /** Ambient color of the light source\n     *\n     *  The ambient light color is multiplied with the ambient\n     *  material color to obtain the final color that contributes\n     *  to the ambient shading term. Most renderers will ignore\n     *  this value it, is just a remaining of the fixed-function pipeline\n     *  that is still supported by quite many file formats.\n     */\n    C_STRUCT aiColor3D mColorAmbient;\n\n    /** Inner angle of a spot light's light cone.\n     *\n     *  The spot light has maximum influence on objects inside this\n     *  angle. The angle is given in radians. It is 2PI for point\n     *  lights and undefined for directional lights.\n     */\n    float mAngleInnerCone;\n\n    /** Outer angle of a spot light's light cone.\n     *\n     *  The spot light does not affect objects outside this angle.\n     *  The angle is given in radians. It is 2PI for point lights and\n     *  undefined for directional lights. The outer angle must be\n     *  greater than or equal to the inner angle.\n     *  It is assumed that the application uses a smooth\n     *  interpolation between the inner and the outer cone of the\n     *  spot light.\n     */\n    float mAngleOuterCone;\n\n    /** Size of area light source. */\n    C_STRUCT aiVector2D mSize;\n\n#ifdef __cplusplus\n\n    aiLight() AI_NO_EXCEPT\n        :   mType                 (aiLightSource_UNDEFINED)\n        ,   mAttenuationConstant  (0.f)\n        ,   mAttenuationLinear    (1.f)\n        ,   mAttenuationQuadratic (0.f)\n        ,   mAngleInnerCone       ((float)AI_MATH_TWO_PI)\n        ,   mAngleOuterCone       ((float)AI_MATH_TWO_PI)\n        ,   mSize                 (0.f, 0.f)\n    {\n    }\n\n#endif\n};\n\n#ifdef __cplusplus\n}\n#endif \n\n\n#endif // !! AI_LIGHT_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/light.h b/include/assimp/light.h
--- a/include/assimp/light.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/light.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -49,7 +49,11 @@
 #ifndef AI_LIGHT_H_INC
 #define AI_LIGHT_H_INC
 
-#include "types.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
 
 #ifdef __cplusplus
 extern "C" {
Index: include/assimp/ProgressHandler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file ProgressHandler.hpp\n *  @brief Abstract base class 'ProgressHandler'.\n */\n#pragma once\n#ifndef AI_PROGRESSHANDLER_H_INC\n#define AI_PROGRESSHANDLER_H_INC\n\n#include \"types.h\"\n\nnamespace Assimp    {\n\n// ------------------------------------------------------------------------------------\n/** @brief CPP-API: Abstract interface for custom progress report receivers.\n *\n *  Each #Importer instance maintains its own #ProgressHandler. The default\n *  implementation provided by Assimp doesn't do anything at all. */\nclass ASSIMP_API ProgressHandler\n#ifndef SWIG\n    : public Intern::AllocateFromAssimpHeap\n#endif\n{\nprotected:\n    /// @brief  Default constructor\n    ProgressHandler () AI_NO_EXCEPT {\n        // empty\n    }\n\npublic:\n    /// @brief  Virtual destructor.\n    virtual ~ProgressHandler () {\n    }\n\n    // -------------------------------------------------------------------\n    /** @brief Progress callback.\n     *  @param percentage An estimate of the current loading progress,\n     *    in percent. Or -1.f if such an estimate is not available.\n     *\n     *  There are restriction on what you may do from within your\n     *  implementation of this method: no exceptions may be thrown and no\n     *  non-const #Importer methods may be called. It is\n     *  not generally possible to predict the number of callbacks\n     *  fired during a single import.\n     *\n     *  @return Return false to abort loading at the next possible\n     *   occasion (loaders and Assimp are generally allowed to perform\n     *   all needed cleanup tasks prior to returning control to the\n     *   caller). If the loading is aborted, #Importer::ReadFile()\n     *   returns always NULL.\n     *   */\n    virtual bool Update(float percentage = -1.f) = 0;\n\n    // -------------------------------------------------------------------\n    /** @brief Progress callback for file loading steps\n     *  @param numberOfSteps The number of total post-processing\n     *   steps\n     *  @param currentStep The index of the current post-processing\n     *   step that will run, or equal to numberOfSteps if all of\n     *   them has finished. This number is always strictly monotone\n     *   increasing, although not necessarily linearly.\n     *\n     *  @note This is currently only used at the start and the end\n     *   of the file parsing.\n     *   */\n    virtual void UpdateFileRead(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {\n        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;\n        Update( f * 0.5f );\n    }\n\n    // -------------------------------------------------------------------\n    /** @brief Progress callback for post-processing steps\n     *  @param numberOfSteps The number of total post-processing\n     *   steps\n     *  @param currentStep The index of the current post-processing\n     *   step that will run, or equal to numberOfSteps if all of\n     *   them has finished. This number is always strictly monotone\n     *   increasing, although not necessarily linearly.\n     *   */\n    virtual void UpdatePostProcess(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {\n        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;\n        Update( f * 0.5f + 0.5f );\n    }\n\n\n    // -------------------------------------------------------------------\n    /** @brief Progress callback for export steps.\n     *  @param numberOfSteps The number of total processing\n     *   steps\n     *  @param currentStep The index of the current post-processing\n     *   step that will run, or equal to numberOfSteps if all of\n     *   them has finished. This number is always strictly monotone\n     *   increasing, although not necessarily linearly.\n     *   */\n    virtual void UpdateFileWrite(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {\n        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;\n        Update(f * 0.5f);\n    }\n}; // !class ProgressHandler\n\n// ------------------------------------------------------------------------------------\n\n} // Namespace Assimp\n\n#endif // AI_PROGRESSHANDLER_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/ProgressHandler.hpp b/include/assimp/ProgressHandler.hpp
--- a/include/assimp/ProgressHandler.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/ProgressHandler.hpp	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -47,9 +47,13 @@
 #ifndef AI_PROGRESSHANDLER_H_INC
 #define AI_PROGRESSHANDLER_H_INC
 
-#include "types.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
 
-namespace Assimp    {
+namespace Assimp {
 
 // ------------------------------------------------------------------------------------
 /** @brief CPP-API: Abstract interface for custom progress report receivers.
Index: include/assimp/defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file defs.h\n *  @brief Assimp build configuration setup. See the notes in the comment\n *  blocks to find out how to customize _your_ Assimp build.\n */\n\n#pragma once\n#ifndef AI_DEFINES_H_INC\n#define AI_DEFINES_H_INC\n\n#include <assimp/config.h>\n\n//////////////////////////////////////////////////////////////////////////\n/* Define ASSIMP_BUILD_NO_XX_IMPORTER to disable a specific\n * file format loader. The loader is be excluded from the\n * build in this case. 'XX' stands for the most common file\n * extension of the file format. E.g.:\n * ASSIMP_BUILD_NO_X_IMPORTER disables the X loader.\n *\n * If you're unsure about that, take a look at the implementation of the\n * import plugin you wish to disable. You'll find the right define in the\n * first lines of the corresponding unit.\n *\n * Other (mixed) configuration switches are listed here:\n *    ASSIMP_BUILD_NO_COMPRESSED_X\n *      - Disable support for compressed X files (zip)\n *    ASSIMP_BUILD_NO_COMPRESSED_BLEND\n *      - Disable support for compressed Blender files (zip)\n *    ASSIMP_BUILD_NO_COMPRESSED_IFC\n *      - Disable support for IFCZIP files (unzip)\n */\n//////////////////////////////////////////////////////////////////////////\n\n#ifndef ASSIMP_BUILD_NO_COMPRESSED_X\n#   define ASSIMP_BUILD_NEED_Z_INFLATE\n#endif\n\n#ifndef ASSIMP_BUILD_NO_COMPRESSED_BLEND\n#   define ASSIMP_BUILD_NEED_Z_INFLATE\n#endif\n\n#ifndef ASSIMP_BUILD_NO_COMPRESSED_IFC\n#   define ASSIMP_BUILD_NEED_Z_INFLATE\n#   define ASSIMP_BUILD_NEED_UNZIP\n#endif\n\n#ifndef ASSIMP_BUILD_NO_Q3BSP_IMPORTER\n#   define ASSIMP_BUILD_NEED_Z_INFLATE\n#   define ASSIMP_BUILD_NEED_UNZIP\n#endif\n\n//////////////////////////////////////////////////////////////////////////\n/* Define ASSIMP_BUILD_NO_XX_PROCESS to disable a specific\n * post processing step. This is the current list of process names ('XX'):\n * CALCTANGENTS\n * JOINVERTICES\n * TRIANGULATE\n * DROPFACENORMALS\n * GENFACENORMALS\n * GENVERTEXNORMALS\n * REMOVEVC\n * SPLITLARGEMESHES\n * PRETRANSFORMVERTICES\n * LIMITBONEWEIGHTS\n * VALIDATEDS\n * IMPROVECACHELOCALITY\n * FIXINFACINGNORMALS\n * REMOVE_REDUNDANTMATERIALS\n * OPTIMIZEGRAPH\n * SORTBYPTYPE\n * FINDINVALIDDATA\n * TRANSFORMTEXCOORDS\n * GENUVCOORDS\n * ENTITYMESHBUILDER\n * EMBEDTEXTURES\n * MAKELEFTHANDED\n * FLIPUVS\n * FLIPWINDINGORDER\n * OPTIMIZEMESHES\n * OPTIMIZEANIMS\n * OPTIMIZEGRAPH\n * GENENTITYMESHES\n * FIXTEXTUREPATHS\n * GENBOUNDINGBOXES */\n//////////////////////////////////////////////////////////////////////////\n\n#ifdef _MSC_VER\n#   undef ASSIMP_API\n\n    //////////////////////////////////////////////////////////////////////////\n    /* Define 'ASSIMP_BUILD_DLL_EXPORT' to build a DLL of the library */\n    //////////////////////////////////////////////////////////////////////////\n#   ifdef ASSIMP_BUILD_DLL_EXPORT\n#       define ASSIMP_API __declspec(dllexport)\n#       define ASSIMP_API_WINONLY __declspec(dllexport)\n#       pragma warning (disable : 4251)\n\n    //////////////////////////////////////////////////////////////////////////\n    /* Define 'ASSIMP_DLL' before including Assimp to link to ASSIMP in\n     * an external DLL under Windows. Default is static linkage. */\n    //////////////////////////////////////////////////////////////////////////\n#   elif (defined ASSIMP_DLL)\n#       define ASSIMP_API __declspec(dllimport)\n#       define ASSIMP_API_WINONLY __declspec(dllimport)\n#   else\n#       define ASSIMP_API\n#       define ASSIMP_API_WINONLY\n#   endif\n\n    /* Force the compiler to inline a function, if possible\n     */\n#   define AI_FORCE_INLINE __forceinline\n\n    /* Tells the compiler that a function never returns. Used in code analysis\n     * to skip dead paths (e.g. after an assertion evaluated to false). */\n#   define AI_WONT_RETURN __declspec(noreturn)\n\n#elif defined(SWIG)\n\n    /* Do nothing, the relevant defines are all in AssimpSwigPort.i */\n\n#else\n\n#   define AI_WONT_RETURN\n\n#   define ASSIMP_API __attribute__ ((visibility(\"default\")))\n#   define ASSIMP_API_WINONLY\n#   define AI_FORCE_INLINE inline\n#endif // (defined _MSC_VER)\n\n#ifdef __GNUC__\n#   define AI_WONT_RETURN_SUFFIX  __attribute__((noreturn))\n#else\n#   define AI_WONT_RETURN_SUFFIX\n#endif // (defined __clang__)\n\n#ifdef __cplusplus\n    /* No explicit 'struct' and 'enum' tags for C++, this keeps showing up\n     * in doxydocs.\n     */\n#   define C_STRUCT\n#   define C_ENUM\n#else\n    //////////////////////////////////////////////////////////////////////////\n    /* To build the documentation, make sure ASSIMP_DOXYGEN_BUILD\n     * is defined by Doxygen's preprocessor. The corresponding\n     * entries in the DOXYFILE are: */\n    //////////////////////////////////////////////////////////////////////////\n#if 0\n    ENABLE_PREPROCESSING   = YES\n    MACRO_EXPANSION        = YES\n    EXPAND_ONLY_PREDEF     = YES\n    SEARCH_INCLUDES        = YES\n    INCLUDE_PATH           =\n    INCLUDE_FILE_PATTERNS  =\n    PREDEFINED             = ASSIMP_DOXYGEN_BUILD=1\n    EXPAND_AS_DEFINED      = C_STRUCT C_ENUM\n    SKIP_FUNCTION_MACROS   = YES\n#endif\n    //////////////////////////////////////////////////////////////////////////\n    /* Doxygen gets confused if we use c-struct typedefs to avoid\n     * the explicit 'struct' notation. This trick here has the same\n     * effect as the TYPEDEF_HIDES_STRUCT option, but we don't need\n     * to typedef all structs/enums. */\n     //////////////////////////////////////////////////////////////////////////\n#   if (defined ASSIMP_DOXYGEN_BUILD)\n#       define C_STRUCT\n#       define C_ENUM\n#   else\n#       define C_STRUCT struct\n#       define C_ENUM   enum\n#   endif\n#endif\n\n#if (defined(__BORLANDC__) || defined (__BCPLUSPLUS__))\n#   error Currently, Borland is unsupported. Feel free to port Assimp.\n#endif\n\n\n    //////////////////////////////////////////////////////////////////////////\n    /* Define ASSIMP_BUILD_SINGLETHREADED to compile assimp\n     * without threading support. The library doesn't utilize\n     * threads then and is itself not threadsafe. */\n    //////////////////////////////////////////////////////////////////////////\n#ifndef ASSIMP_BUILD_SINGLETHREADED\n#   define ASSIMP_BUILD_SINGLETHREADED\n#endif\n\n#if defined(_DEBUG) || ! defined(NDEBUG)\n#   define ASSIMP_BUILD_DEBUG\n#endif\n\n    //////////////////////////////////////////////////////////////////////////\n    /* Define ASSIMP_DOUBLE_PRECISION to compile assimp\n     * with double precision support (64-bit). */\n    //////////////////////////////////////////////////////////////////////////\n\n#ifdef ASSIMP_DOUBLE_PRECISION\n    typedef double ai_real;\n    typedef signed long long int ai_int;\n    typedef unsigned long long int ai_uint;\n#ifndef ASSIMP_AI_REAL_TEXT_PRECISION\n#define ASSIMP_AI_REAL_TEXT_PRECISION 16\n#endif // ASSIMP_AI_REAL_TEXT_PRECISION\n#else // ASSIMP_DOUBLE_PRECISION\n    typedef float ai_real;\n    typedef signed int ai_int;\n    typedef unsigned int ai_uint;\n#ifndef ASSIMP_AI_REAL_TEXT_PRECISION\n#define ASSIMP_AI_REAL_TEXT_PRECISION 8\n#endif // ASSIMP_AI_REAL_TEXT_PRECISION\n#endif // ASSIMP_DOUBLE_PRECISION\n\n    //////////////////////////////////////////////////////////////////////////\n    /* Useful constants */\n    //////////////////////////////////////////////////////////////////////////\n\n/* This is PI. Hi PI. */\n#define AI_MATH_PI          (3.141592653589793238462643383279 )\n#define AI_MATH_TWO_PI      (AI_MATH_PI * 2.0)\n#define AI_MATH_HALF_PI     (AI_MATH_PI * 0.5)\n\n/* And this is to avoid endless casts to float */\n#define AI_MATH_PI_F        (3.1415926538f)\n#define AI_MATH_TWO_PI_F    (AI_MATH_PI_F * 2.0f)\n#define AI_MATH_HALF_PI_F   (AI_MATH_PI_F * 0.5f)\n\n/* Tiny macro to convert from radians to degrees and back */\n#define AI_DEG_TO_RAD(x) ((x)*(ai_real)0.0174532925)\n#define AI_RAD_TO_DEG(x) ((x)*(ai_real)57.2957795)\n\n/* Numerical limits */\nstatic const ai_real ai_epsilon = (ai_real) 0.00001;\n\n/* Support for big-endian builds */\n#if defined(__BYTE_ORDER__)\n#   if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n#       if !defined(__BIG_ENDIAN__)\n#           define __BIG_ENDIAN__\n#       endif\n#   else /* little endian */\n#       if defined (__BIG_ENDIAN__)\n#           undef __BIG_ENDIAN__\n#       endif\n#   endif\n#endif\n#if defined(__BIG_ENDIAN__)\n#   define AI_BUILD_BIG_ENDIAN\n#endif\n\n\n/* To avoid running out of memory\n * This can be adjusted for specific use cases\n * It's NOT a total limit, just a limit for individual allocations\n */\n#define AI_MAX_ALLOC(type) ((256U * 1024 * 1024) / sizeof(type))\n\n#ifndef _MSC_VER\n#  define AI_NO_EXCEPT noexcept\n#else\n#  if (_MSC_VER >= 1915 )\n#    define AI_NO_EXCEPT noexcept\n#  else\n#    define AI_NO_EXCEPT\n#  endif\n#endif // _MSC_VER\n\n#endif // !! AI_DEFINES_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/defs.h b/include/assimp/defs.h
--- a/include/assimp/defs.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/defs.h	(date 1617519895000)
@@ -3,9 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -50,6 +48,10 @@
 #ifndef AI_DEFINES_H_INC
 #define AI_DEFINES_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/config.h>
 
 //////////////////////////////////////////////////////////////////////////
@@ -126,16 +128,14 @@
  * GENBOUNDINGBOXES */
 //////////////////////////////////////////////////////////////////////////
 
-#ifdef _MSC_VER
+#ifdef _WIN32
 #   undef ASSIMP_API
-
     //////////////////////////////////////////////////////////////////////////
     /* Define 'ASSIMP_BUILD_DLL_EXPORT' to build a DLL of the library */
     //////////////////////////////////////////////////////////////////////////
 #   ifdef ASSIMP_BUILD_DLL_EXPORT
 #       define ASSIMP_API __declspec(dllexport)
 #       define ASSIMP_API_WINONLY __declspec(dllexport)
-#       pragma warning (disable : 4251)
 
     //////////////////////////////////////////////////////////////////////////
     /* Define 'ASSIMP_DLL' before including Assimp to link to ASSIMP in
@@ -148,7 +148,19 @@
 #       define ASSIMP_API
 #       define ASSIMP_API_WINONLY
 #   endif
+#elif defined(SWIG)
+
+    /* Do nothing, the relevant defines are all in AssimpSwigPort.i */
 
+#else
+#   define ASSIMP_API __attribute__ ((visibility("default")))
+#   define ASSIMP_API_WINONLY
+#endif
+
+#ifdef _MSC_VER
+#   ifdef ASSIMP_BUILD_DLL_EXPORT
+#       pragma warning (disable : 4251)
+#   endif
     /* Force the compiler to inline a function, if possible
      */
 #   define AI_FORCE_INLINE __forceinline
@@ -156,17 +168,12 @@
     /* Tells the compiler that a function never returns. Used in code analysis
      * to skip dead paths (e.g. after an assertion evaluated to false). */
 #   define AI_WONT_RETURN __declspec(noreturn)
-
 #elif defined(SWIG)
 
     /* Do nothing, the relevant defines are all in AssimpSwigPort.i */
 
 #else
-
 #   define AI_WONT_RETURN
-
-#   define ASSIMP_API __attribute__ ((visibility("default")))
-#   define ASSIMP_API_WINONLY
 #   define AI_FORCE_INLINE inline
 #endif // (defined _MSC_VER)
 
@@ -291,14 +298,19 @@
 #endif
 
 
-/* To avoid running out of memory
- * This can be adjusted for specific use cases
- * It's NOT a total limit, just a limit for individual allocations
+/**
+ *  To avoid running out of memory
+ *  This can be adjusted for specific use cases
+ *  It's NOT a total limit, just a limit for individual allocations
  */
 #define AI_MAX_ALLOC(type) ((256U * 1024 * 1024) / sizeof(type))
 
 #ifndef _MSC_VER
-#  define AI_NO_EXCEPT noexcept
+#  if __cplusplus >= 201103L // C++11
+#    define AI_NO_EXCEPT noexcept
+#  else
+#    define AI_NO_EXCEPT
+#  endif
 #else
 #  if (_MSC_VER >= 1915 )
 #    define AI_NO_EXCEPT noexcept
@@ -307,4 +319,13 @@
 #  endif
 #endif // _MSC_VER
 
+/**
+ *  Helper macro to set a pointer to NULL in debug builds
+ */
+#if (defined ASSIMP_BUILD_DEBUG)
+#   define AI_DEBUG_INVALIDATE_PTR(x) x = NULL;
+#else
+#   define AI_DEBUG_INVALIDATE_PTR(x)
+#endif
+
 #endif // !! AI_DEFINES_H_INC
Index: include/assimp/DefaultIOStream.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Default file I/O using fXXX()-family of functions */\n#ifndef AI_DEFAULTIOSTREAM_H_INC\n#define AI_DEFAULTIOSTREAM_H_INC\n\n#include <stdio.h>\n#include <assimp/IOStream.hpp>\n#include <assimp/importerdesc.h>\n#include <assimp/Defines.h>\n\nnamespace Assimp    {\n\n// ----------------------------------------------------------------------------------\n//! @class  DefaultIOStream\n//! @brief  Default IO implementation, use standard IO operations\n//! @note   An instance of this class can exist without a valid file handle\n//!         attached to it. All calls fail, but the instance can nevertheless be\n//!         used with no restrictions.\nclass ASSIMP_API DefaultIOStream : public IOStream\n{\n    friend class DefaultIOSystem;\n#if __ANDROID__\n# if __ANDROID_API__ > 9\n#  if defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)\n    friend class AndroidJNIIOSystem;\n#  endif // defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)\n# endif // __ANDROID_API__ > 9\n#endif // __ANDROID__\n\nprotected:\n    DefaultIOStream() AI_NO_EXCEPT;\n    DefaultIOStream(FILE* pFile, const std::string &strFilename);\n\npublic:\n    /** Destructor public to allow simple deletion to close the file. */\n    ~DefaultIOStream ();\n\n    // -------------------------------------------------------------------\n    /// Read from stream\n    size_t Read(void* pvBuffer,\n        size_t pSize,\n        size_t pCount);\n\n\n    // -------------------------------------------------------------------\n    /// Write to stream\n    size_t Write(const void* pvBuffer,\n        size_t pSize,\n        size_t pCount);\n\n    // -------------------------------------------------------------------\n    /// Seek specific position\n    aiReturn Seek(size_t pOffset,\n        aiOrigin pOrigin);\n\n    // -------------------------------------------------------------------\n    /// Get current seek position\n    size_t Tell() const;\n\n    // -------------------------------------------------------------------\n    /// Get size of file\n    size_t FileSize() const;\n\n    // -------------------------------------------------------------------\n    /// Flush file contents\n    void Flush();\n\nprivate:\n    //  File data-structure, using clib\n    FILE* mFile;\n    //  Filename\n    std::string mFilename;\n    // Cached file size\n    mutable size_t mCachedSize;\n};\n\n// ----------------------------------------------------------------------------------\ninline\nDefaultIOStream::DefaultIOStream() AI_NO_EXCEPT\n: mFile(nullptr)\n, mFilename(\"\")\n, mCachedSize(SIZE_MAX) {\n    // empty\n}\n\n// ----------------------------------------------------------------------------------\ninline\nDefaultIOStream::DefaultIOStream (FILE* pFile, const std::string &strFilename)\n: mFile(pFile)\n, mFilename(strFilename)\n, mCachedSize(SIZE_MAX) {\n    // empty\n}\n// ----------------------------------------------------------------------------------\n\n} // ns assimp\n\n#endif //!!AI_DEFAULTIOSTREAM_H_INC\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/DefaultIOStream.h b/include/assimp/DefaultIOStream.h
--- a/include/assimp/DefaultIOStream.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/DefaultIOStream.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -41,15 +41,20 @@
 */
 
 /** @file Default file I/O using fXXX()-family of functions */
+#pragma once
 #ifndef AI_DEFAULTIOSTREAM_H_INC
 #define AI_DEFAULTIOSTREAM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <stdio.h>
 #include <assimp/IOStream.hpp>
 #include <assimp/importerdesc.h>
 #include <assimp/Defines.h>
 
-namespace Assimp    {
+namespace Assimp {
 
 // ----------------------------------------------------------------------------------
 //! @class  DefaultIOStream
@@ -57,8 +62,7 @@
 //! @note   An instance of this class can exist without a valid file handle
 //!         attached to it. All calls fail, but the instance can nevertheless be
 //!         used with no restrictions.
-class ASSIMP_API DefaultIOStream : public IOStream
-{
+class ASSIMP_API DefaultIOStream : public IOStream {
     friend class DefaultIOSystem;
 #if __ANDROID__
 # if __ANDROID_API__ > 9
@@ -82,7 +86,6 @@
         size_t pSize,
         size_t pCount);
 
-
     // -------------------------------------------------------------------
     /// Write to stream
     size_t Write(const void* pvBuffer,
@@ -107,16 +110,13 @@
     void Flush();
 
 private:
-    //  File data-structure, using clib
     FILE* mFile;
-    //  Filename
     std::string mFilename;
-    // Cached file size
     mutable size_t mCachedSize;
 };
 
 // ----------------------------------------------------------------------------------
-inline
+AI_FORCE_INLINE
 DefaultIOStream::DefaultIOStream() AI_NO_EXCEPT
 : mFile(nullptr)
 , mFilename("")
@@ -125,7 +125,7 @@
 }
 
 // ----------------------------------------------------------------------------------
-inline
+AI_FORCE_INLINE
 DefaultIOStream::DefaultIOStream (FILE* pFile, const std::string &strFilename)
 : mFile(pFile)
 , mFilename(strFilename)
@@ -137,4 +137,3 @@
 } // ns assimp
 
 #endif //!!AI_DEFAULTIOSTREAM_H_INC
-
Index: include/assimp/color4.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n/** @file color4.h\n *  @brief RGBA color structure, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_COLOR4D_H_INC\n#define AI_COLOR4D_H_INC\n\n#include \"defs.h\"\n\n#ifdef __cplusplus\n\n// ----------------------------------------------------------------------------------\n/** Represents a color in Red-Green-Blue space including an\n*   alpha component. Color values range from 0 to 1. */\n// ----------------------------------------------------------------------------------\ntemplate <typename TReal>\nclass aiColor4t\n{\npublic:\n    aiColor4t() AI_NO_EXCEPT : r(), g(), b(), a() {}\n    aiColor4t (TReal _r, TReal _g, TReal _b, TReal _a)\n        : r(_r), g(_g), b(_b), a(_a) {}\n    explicit aiColor4t (TReal _r) : r(_r), g(_r), b(_r), a(_r) {}\n    aiColor4t (const aiColor4t& o) = default;\n\npublic:\n    // combined operators\n    const aiColor4t& operator += (const aiColor4t& o);\n    const aiColor4t& operator -= (const aiColor4t& o);\n    const aiColor4t& operator *= (TReal f);\n    const aiColor4t& operator /= (TReal f);\n\npublic:\n    // comparison\n    bool operator == (const aiColor4t& other) const;\n    bool operator != (const aiColor4t& other) const;\n    bool operator <  (const aiColor4t& other) const;\n\n    // color tuple access, rgba order\n    inline TReal operator[](unsigned int i) const;\n    inline TReal& operator[](unsigned int i);\n\n    /** check whether a color is (close to) black */\n    inline bool IsBlack() const;\n\npublic:\n\n    // Red, green, blue and alpha color values\n    TReal r, g, b, a;\n};  // !struct aiColor4D\n\ntypedef aiColor4t<ai_real> aiColor4D;\n\n#else\n\nstruct aiColor4D {\n    ai_real r, g, b, a;\n};\n\n#endif // __cplusplus\n\n#endif // AI_COLOR4D_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/color4.h b/include/assimp/color4.h
--- a/include/assimp/color4.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/color4.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -47,7 +47,11 @@
 #ifndef AI_COLOR4D_H_INC
 #define AI_COLOR4D_H_INC
 
-#include "defs.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/defs.h>
 
 #ifdef __cplusplus
 
@@ -56,8 +60,7 @@
 *   alpha component. Color values range from 0 to 1. */
 // ----------------------------------------------------------------------------------
 template <typename TReal>
-class aiColor4t
-{
+class aiColor4t {
 public:
     aiColor4t() AI_NO_EXCEPT : r(), g(), b(), a() {}
     aiColor4t (TReal _r, TReal _g, TReal _b, TReal _a)
@@ -65,14 +68,12 @@
     explicit aiColor4t (TReal _r) : r(_r), g(_r), b(_r), a(_r) {}
     aiColor4t (const aiColor4t& o) = default;
 
-public:
     // combined operators
     const aiColor4t& operator += (const aiColor4t& o);
     const aiColor4t& operator -= (const aiColor4t& o);
     const aiColor4t& operator *= (TReal f);
     const aiColor4t& operator /= (TReal f);
 
-public:
     // comparison
     bool operator == (const aiColor4t& other) const;
     bool operator != (const aiColor4t& other) const;
@@ -85,8 +86,6 @@
     /** check whether a color is (close to) black */
     inline bool IsBlack() const;
 
-public:
-
     // Red, green, blue and alpha color values
     TReal r, g, b, a;
 };  // !struct aiColor4D
Index: include/assimp/anim.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** \n  * @file   anim.h\n  * @brief  Defines the data structures in which the imported animations\n  *         are returned.\n  */\n#pragma once\n#ifndef AI_ANIM_H_INC\n#define AI_ANIM_H_INC\n\n#include <assimp/types.h>\n#include <assimp/quaternion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n/** A time-value pair specifying a certain 3D vector for the given time. */\nstruct aiVectorKey\n{\n    /** The time of this key */\n    double mTime;\n\n    /** The value of this key */\n    C_STRUCT aiVector3D mValue;\n\n#ifdef __cplusplus\n\n    /// @brief  The default constructor.\n    aiVectorKey() AI_NO_EXCEPT\n    : mTime( 0.0 )\n    , mValue() {\n        // empty\n    }\n\n    /// @brief  Construction from a given time and key value.\n\n    aiVectorKey(double time, const aiVector3D& value)\n    : mTime( time )\n    , mValue( value ) {\n        // empty\n    }\n\n    typedef aiVector3D elem_type;\n\n    // Comparison operators. For use with std::find();\n    bool operator == (const aiVectorKey& rhs) const {\n        return rhs.mValue == this->mValue;\n    }\n    bool operator != (const aiVectorKey& rhs ) const {\n        return rhs.mValue != this->mValue;\n    }\n\n    // Relational operators. For use with std::sort();\n    bool operator < (const aiVectorKey& rhs ) const {\n        return mTime < rhs.mTime;\n    }\n    bool operator > (const aiVectorKey& rhs ) const {\n        return mTime > rhs.mTime;\n    }\n#endif // __cplusplus\n};\n\n// ---------------------------------------------------------------------------\n/** A time-value pair specifying a rotation for the given time.\n *  Rotations are expressed with quaternions. */\nstruct aiQuatKey\n{\n    /** The time of this key */\n    double mTime;\n\n    /** The value of this key */\n    C_STRUCT aiQuaternion mValue;\n\n#ifdef __cplusplus\n    aiQuatKey() AI_NO_EXCEPT\n    : mTime( 0.0 )\n    , mValue() {\n        // empty\n    }\n\n    /** Construction from a given time and key value */\n    aiQuatKey(double time, const aiQuaternion& value)\n        :   mTime   (time)\n        ,   mValue  (value)\n    {}\n\n    typedef aiQuaternion elem_type;\n\n    // Comparison operators. For use with std::find();\n    bool operator == (const aiQuatKey& rhs ) const {\n        return rhs.mValue == this->mValue;\n    }\n    bool operator != (const aiQuatKey& rhs ) const {\n        return rhs.mValue != this->mValue;\n    }\n\n    // Relational operators. For use with std::sort();\n    bool operator < (const aiQuatKey& rhs ) const {\n        return mTime < rhs.mTime;\n    }\n    bool operator > (const aiQuatKey& rhs ) const {\n        return mTime > rhs.mTime;\n    }\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Binds a anim-mesh to a specific point in time. */\nstruct aiMeshKey\n{\n    /** The time of this key */\n    double mTime;\n\n    /** Index into the aiMesh::mAnimMeshes array of the\n     *  mesh corresponding to the #aiMeshAnim hosting this\n     *  key frame. The referenced anim mesh is evaluated\n     *  according to the rules defined in the docs for #aiAnimMesh.*/\n    unsigned int mValue;\n\n#ifdef __cplusplus\n\n    aiMeshKey() AI_NO_EXCEPT\n    : mTime(0.0)\n    , mValue(0)\n    {\n    }\n\n    /** Construction from a given time and key value */\n    aiMeshKey(double time, const unsigned int value)\n        :   mTime   (time)\n        ,   mValue  (value)\n    {}\n\n    typedef unsigned int elem_type;\n\n    // Comparison operators. For use with std::find();\n    bool operator == (const aiMeshKey& o) const {\n        return o.mValue == this->mValue;\n    }\n    bool operator != (const aiMeshKey& o) const {\n        return o.mValue != this->mValue;\n    }\n\n    // Relational operators. For use with std::sort();\n    bool operator < (const aiMeshKey& o) const {\n        return mTime < o.mTime;\n    }\n    bool operator > (const aiMeshKey& o) const {\n        return mTime > o.mTime;\n    }\n\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Binds a morph anim mesh to a specific point in time. */\nstruct aiMeshMorphKey\n{\n    /** The time of this key */\n    double mTime;\n\n    /** The values and weights at the time of this key */\n    unsigned int *mValues;\n    double *mWeights;\n\n    /** The number of values and weights */\n    unsigned int mNumValuesAndWeights;\n#ifdef __cplusplus\n\taiMeshMorphKey() AI_NO_EXCEPT\n\t\t: mTime(0.0)\n\t\t, mValues(nullptr)\n\t\t, mWeights(nullptr)\n\t\t, mNumValuesAndWeights(0)\n\t{\n\n\t}\n\n    ~aiMeshMorphKey()\n    {\n        if (mNumValuesAndWeights && mValues && mWeights) {\n            delete [] mValues;\n            delete [] mWeights;\n        }\n    }\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Defines how an animation channel behaves outside the defined time\n *  range. This corresponds to aiNodeAnim::mPreState and\n *  aiNodeAnim::mPostState.*/\nenum aiAnimBehaviour\n{\n    /** The value from the default node transformation is taken*/\n    aiAnimBehaviour_DEFAULT  = 0x0,\n\n    /** The nearest key value is used without interpolation */\n    aiAnimBehaviour_CONSTANT = 0x1,\n\n    /** The value of the nearest two keys is linearly\n     *  extrapolated for the current time value.*/\n    aiAnimBehaviour_LINEAR   = 0x2,\n\n    /** The animation is repeated.\n     *\n     *  If the animation key go from n to m and the current\n     *  time is t, use the value at (t-n) % (|m-n|).*/\n    aiAnimBehaviour_REPEAT   = 0x3,\n\n    /** This value is not used, it is just here to force the\n     *  the compiler to map this enum to a 32 Bit integer  */\n#ifndef SWIG\n    _aiAnimBehaviour_Force32Bit = INT_MAX\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Describes the animation of a single node. The name specifies the\n *  bone/node which is affected by this animation channel. The keyframes\n *  are given in three separate series of values, one each for position,\n *  rotation and scaling. The transformation matrix computed from these\n *  values replaces the node's original transformation matrix at a\n *  specific time.\n *  This means all keys are absolute and not relative to the bone default pose.\n *  The order in which the transformations are applied is\n *  - as usual - scaling, rotation, translation.\n *\n *  @note All keys are returned in their correct, chronological order.\n *  Duplicate keys don't pass the validation step. Most likely there\n *  will be no negative time values, but they are not forbidden also ( so\n *  implementations need to cope with them! ) */\nstruct aiNodeAnim {\n    /** The name of the node affected by this animation. The node\n     *  must exist and it must be unique.*/\n    C_STRUCT aiString mNodeName;\n\n    /** The number of position keys */\n    unsigned int mNumPositionKeys;\n\n    /** The position keys of this animation channel. Positions are\n     * specified as 3D vector. The array is mNumPositionKeys in size.\n     *\n     * If there are position keys, there will also be at least one\n     * scaling and one rotation key.*/\n    C_STRUCT aiVectorKey* mPositionKeys;\n\n    /** The number of rotation keys */\n    unsigned int mNumRotationKeys;\n\n    /** The rotation keys of this animation channel. Rotations are\n     *  given as quaternions,  which are 4D vectors. The array is\n     *  mNumRotationKeys in size.\n     *\n     * If there are rotation keys, there will also be at least one\n     * scaling and one position key. */\n    C_STRUCT aiQuatKey* mRotationKeys;\n\n    /** The number of scaling keys */\n    unsigned int mNumScalingKeys;\n\n    /** The scaling keys of this animation channel. Scalings are\n     *  specified as 3D vector. The array is mNumScalingKeys in size.\n     *\n     * If there are scaling keys, there will also be at least one\n     * position and one rotation key.*/\n    C_STRUCT aiVectorKey* mScalingKeys;\n\n    /** Defines how the animation behaves before the first\n     *  key is encountered.\n     *\n     *  The default value is aiAnimBehaviour_DEFAULT (the original\n     *  transformation matrix of the affected node is used).*/\n    C_ENUM aiAnimBehaviour mPreState;\n\n    /** Defines how the animation behaves after the last\n     *  key was processed.\n     *\n     *  The default value is aiAnimBehaviour_DEFAULT (the original\n     *  transformation matrix of the affected node is taken).*/\n    C_ENUM aiAnimBehaviour mPostState;\n\n#ifdef __cplusplus\n    aiNodeAnim() AI_NO_EXCEPT\n    : mNumPositionKeys( 0 )\n    , mPositionKeys( nullptr )\n    , mNumRotationKeys( 0 )\n    , mRotationKeys( nullptr )\n    , mNumScalingKeys( 0 )\n    , mScalingKeys( nullptr )\n    , mPreState( aiAnimBehaviour_DEFAULT )\n    , mPostState( aiAnimBehaviour_DEFAULT ) {\n         // empty\n    }\n\n    ~aiNodeAnim() {\n        delete [] mPositionKeys;\n        delete [] mRotationKeys;\n        delete [] mScalingKeys;\n    }\n#endif // __cplusplus\n};\n\n// ---------------------------------------------------------------------------\n/** Describes vertex-based animations for a single mesh or a group of\n *  meshes. Meshes carry the animation data for each frame in their\n *  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to\n *  define keyframes linking each mesh attachment to a particular\n *  point in time. */\nstruct aiMeshAnim\n{\n    /** Name of the mesh to be animated. An empty string is not allowed,\n     *  animated meshes need to be named (not necessarily uniquely,\n     *  the name can basically serve as wild-card to select a group\n     *  of meshes with similar animation setup)*/\n    C_STRUCT aiString mName;\n\n    /** Size of the #mKeys array. Must be 1, at least. */\n    unsigned int mNumKeys;\n\n    /** Key frames of the animation. May not be NULL. */\n    C_STRUCT aiMeshKey* mKeys;\n\n#ifdef __cplusplus\n\n    aiMeshAnim() AI_NO_EXCEPT\n        : mNumKeys()\n        , mKeys()\n    {}\n\n    ~aiMeshAnim()\n    {\n        delete[] mKeys;\n    }\n\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** Describes a morphing animation of a given mesh. */\nstruct aiMeshMorphAnim\n{\n    /** Name of the mesh to be animated. An empty string is not allowed,\n     *  animated meshes need to be named (not necessarily uniquely,\n     *  the name can basically serve as wildcard to select a group\n     *  of meshes with similar animation setup)*/\n    C_STRUCT aiString mName;\n\n    /** Size of the #mKeys array. Must be 1, at least. */\n    unsigned int mNumKeys;\n\n    /** Key frames of the animation. May not be NULL. */\n    C_STRUCT aiMeshMorphKey* mKeys;\n\n#ifdef __cplusplus\n\n    aiMeshMorphAnim() AI_NO_EXCEPT\n        : mNumKeys()\n        , mKeys()\n    {}\n\n    ~aiMeshMorphAnim()\n    {\n        delete[] mKeys;\n    }\n\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** An animation consists of key-frame data for a number of nodes. For\n *  each node affected by the animation a separate series of data is given.*/\nstruct aiAnimation {\n    /** The name of the animation. If the modeling package this data was\n     *  exported from does support only a single animation channel, this\n     *  name is usually empty (length is zero). */\n    C_STRUCT aiString mName;\n\n    /** Duration of the animation in ticks.  */\n    double mDuration;\n\n    /** Ticks per second. 0 if not specified in the imported file */\n    double mTicksPerSecond;\n\n    /** The number of bone animation channels. Each channel affects\n     *  a single node. */\n    unsigned int mNumChannels;\n\n    /** The node animation channels. Each channel affects a single node.\n     *  The array is mNumChannels in size. */\n    C_STRUCT aiNodeAnim** mChannels;\n\n\n    /** The number of mesh animation channels. Each channel affects\n     *  a single mesh and defines vertex-based animation. */\n    unsigned int mNumMeshChannels;\n\n    /** The mesh animation channels. Each channel affects a single mesh.\n     *  The array is mNumMeshChannels in size. */\n    C_STRUCT aiMeshAnim** mMeshChannels;\n\n    /** The number of mesh animation channels. Each channel affects\n     *  a single mesh and defines morphing animation. */\n    unsigned int mNumMorphMeshChannels;\n\n    /** The morph mesh animation channels. Each channel affects a single mesh.\n     *  The array is mNumMorphMeshChannels in size. */\n    C_STRUCT aiMeshMorphAnim **mMorphMeshChannels;\n\n#ifdef __cplusplus\n    aiAnimation() AI_NO_EXCEPT\n    : mDuration(-1.)\n    , mTicksPerSecond(0.)\n    , mNumChannels(0)\n    , mChannels(nullptr)\n    , mNumMeshChannels(0)\n    , mMeshChannels(nullptr)\n    , mNumMorphMeshChannels(0)\n    , mMorphMeshChannels(nullptr) {\n        // empty\n    }\n\n    ~aiAnimation() {\n        // DO NOT REMOVE THIS ADDITIONAL CHECK\n        if ( mNumChannels && mChannels )  {\n            for( unsigned int a = 0; a < mNumChannels; a++) {\n                delete mChannels[ a ];\n            }\n\n            delete [] mChannels;\n        }\n        if (mNumMeshChannels && mMeshChannels)  {\n            for( unsigned int a = 0; a < mNumMeshChannels; a++) {\n                delete mMeshChannels[a];\n            }\n\n            delete [] mMeshChannels;\n        }\n        if (mNumMorphMeshChannels && mMorphMeshChannels) {\n                for( unsigned int a = 0; a < mNumMorphMeshChannels; a++) {\n                        delete mMorphMeshChannels[a];\n                }\n            \n            delete [] mMorphMeshChannels;\n        }\n    }\n#endif // __cplusplus\n};\n\n#ifdef __cplusplus\n\n}\n\n/// @brief  Some C++ utilities for inter- and extrapolation\nnamespace Assimp {\n\n// ---------------------------------------------------------------------------\n/** \n  * @brief CPP-API: Utility class to simplify interpolations of various data types.\n  *\n  *  The type of interpolation is chosen automatically depending on the\n  *  types of the arguments. \n  */\ntemplate <typename T>\nstruct Interpolator\n{\n    // ------------------------------------------------------------------\n    /** @brief Get the result of the interpolation between a,b.\n     *\n     *  The interpolation algorithm depends on the type of the operands.\n     *  aiQuaternion's and aiQuatKey's SLERP, the rest does a simple\n     *  linear interpolation. */\n    void operator () (T& out,const T& a, const T& b, ai_real d) const {\n        out = a + (b-a)*d;\n    }\n}; // ! Interpolator <T>\n\n//! @cond Never\n\ntemplate <>\nstruct Interpolator <aiQuaternion>  {\n    void operator () (aiQuaternion& out,const aiQuaternion& a,\n        const aiQuaternion& b, ai_real d) const\n    {\n        aiQuaternion::Interpolate(out,a,b,d);\n    }\n}; // ! Interpolator <aiQuaternion>\n\ntemplate <>\nstruct Interpolator <unsigned int>  {\n    void operator () (unsigned int& out,unsigned int a,\n        unsigned int b, ai_real d) const\n    {\n        out = d>0.5f ? b : a;\n    }\n}; // ! Interpolator <aiQuaternion>\n\ntemplate <>\nstruct Interpolator<aiVectorKey>  {\n    void operator () (aiVector3D& out,const aiVectorKey& a,\n        const aiVectorKey& b, ai_real d) const\n    {\n        Interpolator<aiVector3D> ipl;\n        ipl(out,a.mValue,b.mValue,d);\n    }\n}; // ! Interpolator <aiVectorKey>\n\ntemplate <>\nstruct Interpolator<aiQuatKey>  {\n    void operator () (aiQuaternion& out, const aiQuatKey& a,\n        const aiQuatKey& b, ai_real d) const\n    {\n        Interpolator<aiQuaternion> ipl;\n        ipl(out,a.mValue,b.mValue,d);\n    }\n}; // ! Interpolator <aiQuatKey>\n\ntemplate <>\nstruct Interpolator<aiMeshKey>     {\n    void operator () (unsigned int& out, const aiMeshKey& a,\n        const aiMeshKey& b, ai_real d) const\n    {\n        Interpolator<unsigned int> ipl;\n        ipl(out,a.mValue,b.mValue,d);\n    }\n}; // ! Interpolator <aiQuatKey>\n\n//! @endcond\n\n} //  ! end namespace Assimp\n\n#endif // __cplusplus\n\n#endif // AI_ANIM_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/anim.h b/include/assimp/anim.h
--- a/include/assimp/anim.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/anim.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -50,6 +50,10 @@
 #ifndef AI_ANIM_H_INC
 #define AI_ANIM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
 #include <assimp/quaternion.h>
 
Index: include/assimp/Importer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  Importer.hpp\n *  @brief Defines the C++-API to the Open Asset Import Library.\n */\n#pragma once\n#ifndef AI_ASSIMP_HPP_INC\n#define AI_ASSIMP_HPP_INC\n\n#ifndef __cplusplus\n#   error This header requires C++ to be used. Use assimp.h for plain C.\n#endif // __cplusplus\n\n// Public ASSIMP data structures\n#include <assimp/types.h>\n\nnamespace Assimp    {\n    // =======================================================================\n    // Public interface to Assimp\n    class Importer;\n    class IOStream;\n    class IOSystem;\n    class ProgressHandler;\n\n    // =======================================================================\n    // Plugin development\n    //\n    // Include the following headers for the declarations:\n    // BaseImporter.h\n    // BaseProcess.h\n    class BaseImporter;\n    class BaseProcess;\n    class SharedPostProcessInfo;\n    class BatchLoader;\n\n    // =======================================================================\n    // Holy stuff, only for members of the high council of the Jedi.\n    class ImporterPimpl;\n} //! namespace Assimp\n\n#define AI_PROPERTY_WAS_NOT_EXISTING 0xffffffff\n\nstruct aiScene;\n\n// importerdesc.h\nstruct aiImporterDesc;\n\n/** @namespace Assimp Assimp's CPP-API and all internal APIs */\nnamespace Assimp    {\n\n// ----------------------------------------------------------------------------------\n/** CPP-API: The Importer class forms an C++ interface to the functionality of the\n*   Open Asset Import Library.\n*\n* Create an object of this class and call ReadFile() to import a file.\n* If the import succeeds, the function returns a pointer to the imported data.\n* The data remains property of the object, it is intended to be accessed\n* read-only. The imported data will be destroyed along with the Importer\n* object. If the import fails, ReadFile() returns a NULL pointer. In this\n* case you can retrieve a human-readable error description be calling\n* GetErrorString(). You can call ReadFile() multiple times with a single Importer\n* instance. Actually, constructing Importer objects involves quite many\n* allocations and may take some time, so it's better to reuse them as often as\n* possible.\n*\n* If you need the Importer to do custom file handling to access the files,\n* implement IOSystem and IOStream and supply an instance of your custom\n* IOSystem implementation by calling SetIOHandler() before calling ReadFile().\n* If you do not assign a custion IO handler, a default handler using the\n* standard C++ IO logic will be used.\n*\n* @note One Importer instance is not thread-safe. If you use multiple\n* threads for loading, each thread should maintain its own Importer instance.\n*/\nclass ASSIMP_API Importer   {\npublic:\n    /**\n     *  @brief The upper limit for hints.\n     */\n    static const unsigned int MaxLenHint = 200;\n\npublic:\n\n    // -------------------------------------------------------------------\n    /** Constructor. Creates an empty importer object.\n     *\n     * Call ReadFile() to start the import process. The configuration\n     * property table is initially empty.\n     */\n    Importer();\n\n    // -------------------------------------------------------------------\n    /** Copy constructor.\n     *\n     * This copies the configuration properties of another Importer.\n     * If this Importer owns a scene it won't be copied.\n     * Call ReadFile() to start the import process.\n     */\n    Importer(const Importer& other)=delete;\n\n    // -------------------------------------------------------------------\n    /** Assignment operator has been deleted\n     */\n    Importer &operator=(const Importer &) = delete;\n\n    // -------------------------------------------------------------------\n    /** Destructor. The object kept ownership of the imported data,\n     * which now will be destroyed along with the object.\n     */\n    ~Importer();\n\n\n    // -------------------------------------------------------------------\n    /** Registers a new loader.\n     *\n     * @param pImp Importer to be added. The Importer instance takes\n     *   ownership of the pointer, so it will be automatically deleted\n     *   with the Importer instance.\n     * @return AI_SUCCESS if the loader has been added. The registration\n     *   fails if there is already a loader for a specific file extension.\n     */\n    aiReturn RegisterLoader(BaseImporter* pImp);\n\n    // -------------------------------------------------------------------\n    /** Unregisters a loader.\n     *\n     * @param pImp Importer to be unregistered.\n     * @return AI_SUCCESS if the loader has been removed. The function\n     *   fails if the loader is currently in use (this could happen\n     *   if the #Importer instance is used by more than one thread) or\n     *   if it has not yet been registered.\n     */\n    aiReturn UnregisterLoader(BaseImporter* pImp);\n\n    // -------------------------------------------------------------------\n    /** Registers a new post-process step.\n     *\n     * At the moment, there's a small limitation: new post processing\n     * steps are added to end of the list, or in other words, executed\n     * last, after all built-in steps.\n     * @param pImp Post-process step to be added. The Importer instance\n     *   takes ownership of the pointer, so it will be automatically\n     *   deleted with the Importer instance.\n     * @return AI_SUCCESS if the step has been added correctly.\n     */\n    aiReturn RegisterPPStep(BaseProcess* pImp);\n\n    // -------------------------------------------------------------------\n    /** Unregisters a post-process step.\n     *\n     * @param pImp Step to be unregistered.\n     * @return AI_SUCCESS if the step has been removed. The function\n     *   fails if the step is currently in use (this could happen\n     *   if the #Importer instance is used by more than one thread) or\n     *   if it has not yet been registered.\n     */\n    aiReturn UnregisterPPStep(BaseProcess* pImp);\n\n    // -------------------------------------------------------------------\n    /** Set an integer configuration property.\n     * @param szName Name of the property. All supported properties\n     *   are defined in the aiConfig.g header (all constants share the\n     *   prefix AI_CONFIG_XXX and are simple strings).\n     * @param iValue New value of the property\n     * @return true if the property was set before. The new value replaces\n     *   the previous value in this case.\n     * @note Property of different types (float, int, string ..) are kept\n     *   on different stacks, so calling SetPropertyInteger() for a\n     *   floating-point property has no effect - the loader will call\n     *   GetPropertyFloat() to read the property, but it won't be there.\n     */\n    bool SetPropertyInteger(const char* szName, int iValue);\n\n    // -------------------------------------------------------------------\n    /** Set a boolean configuration property. Boolean properties\n     *  are stored on the integer stack internally so it's possible\n     *  to set them via #SetPropertyBool and query them with\n     *  #GetPropertyBool and vice versa.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyBool(const char* szName, bool value)    {\n        return SetPropertyInteger(szName,value);\n    }\n\n    // -------------------------------------------------------------------\n    /** Set a floating-point configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyFloat(const char* szName, ai_real fValue);\n\n    // -------------------------------------------------------------------\n    /** Set a string configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyString(const char* szName, const std::string& sValue);\n\n    // -------------------------------------------------------------------\n    /** Set a matrix configuration property.\n     * @see SetPropertyInteger()\n     */\n    bool SetPropertyMatrix(const char* szName, const aiMatrix4x4& sValue);\n\n    // -------------------------------------------------------------------\n    /** Get a configuration property.\n     * @param szName Name of the property. All supported properties\n     *   are defined in the aiConfig.g header (all constants share the\n     *   prefix AI_CONFIG_XXX).\n     * @param iErrorReturn Value that is returned if the property\n     *   is not found.\n     * @return Current value of the property\n     * @note Property of different types (float, int, string ..) are kept\n     *   on different lists, so calling SetPropertyInteger() for a\n     *   floating-point property has no effect - the loader will call\n     *   GetPropertyFloat() to read the property, but it won't be there.\n     */\n    int GetPropertyInteger(const char* szName,\n        int iErrorReturn = 0xffffffff) const;\n\n    // -------------------------------------------------------------------\n    /** Get a boolean configuration property. Boolean properties\n     *  are stored on the integer stack internally so it's possible\n     *  to set them via #SetPropertyBool and query them with\n     *  #GetPropertyBool and vice versa.\n     * @see GetPropertyInteger()\n     */\n    bool GetPropertyBool(const char* szName, bool bErrorReturn = false) const {\n        return GetPropertyInteger(szName,bErrorReturn)!=0;\n    }\n\n    // -------------------------------------------------------------------\n    /** Get a floating-point configuration property\n     * @see GetPropertyInteger()\n     */\n    ai_real GetPropertyFloat(const char* szName,\n        ai_real fErrorReturn = 10e10) const;\n\n    // -------------------------------------------------------------------\n    /** Get a string configuration property\n     *\n     *  The return value remains valid until the property is modified.\n     * @see GetPropertyInteger()\n     */\n    const std::string GetPropertyString(const char* szName,\n        const std::string& sErrorReturn = \"\") const;\n\n    // -------------------------------------------------------------------\n    /** Get a matrix configuration property\n     *\n     *  The return value remains valid until the property is modified.\n     * @see GetPropertyInteger()\n     */\n    const aiMatrix4x4 GetPropertyMatrix(const char* szName,\n        const aiMatrix4x4& sErrorReturn = aiMatrix4x4()) const;\n\n    // -------------------------------------------------------------------\n    /** Supplies a custom IO handler to the importer to use to open and\n     * access files. If you need the importer to use custom IO logic to\n     * access the files, you need to provide a custom implementation of\n     * IOSystem and IOFile to the importer. Then create an instance of\n     * your custom IOSystem implementation and supply it by this function.\n     *\n     * The Importer takes ownership of the object and will destroy it\n     * afterwards. The previously assigned handler will be deleted.\n     * Pass NULL to take again ownership of your IOSystem and reset Assimp\n     * to use its default implementation.\n     *\n     * @param pIOHandler The IO handler to be used in all file accesses\n     *   of the Importer.\n     */\n    void SetIOHandler( IOSystem* pIOHandler);\n\n    // -------------------------------------------------------------------\n    /** Retrieves the IO handler that is currently set.\n     * You can use #IsDefaultIOHandler() to check whether the returned\n     * interface is the default IO handler provided by ASSIMP. The default\n     * handler is active as long the application doesn't supply its own\n     * custom IO handler via #SetIOHandler().\n     * @return A valid IOSystem interface, never NULL.\n     */\n    IOSystem* GetIOHandler() const;\n\n    // -------------------------------------------------------------------\n    /** Checks whether a default IO handler is active\n     * A default handler is active as long the application doesn't\n     * supply its own custom IO handler via #SetIOHandler().\n     * @return true by default\n     */\n    bool IsDefaultIOHandler() const;\n\n    // -------------------------------------------------------------------\n    /** Supplies a custom progress handler to the importer. This\n     *  interface exposes an #Update() callback, which is called\n     *  more or less periodically (please don't sue us if it\n     *  isn't as periodically as you'd like it to have ...).\n     *  This can be used to implement progress bars and loading\n     *  timeouts.\n     *  @param pHandler Progress callback interface. Pass NULL to\n     *    disable progress reporting.\n     *  @note Progress handlers can be used to abort the loading\n     *    at almost any time.*/\n    void SetProgressHandler ( ProgressHandler* pHandler );\n\n    // -------------------------------------------------------------------\n    /** Retrieves the progress handler that is currently set.\n     * You can use #IsDefaultProgressHandler() to check whether the returned\n     * interface is the default handler provided by ASSIMP. The default\n     * handler is active as long the application doesn't supply its own\n     * custom handler via #SetProgressHandler().\n     * @return A valid ProgressHandler interface, never NULL.\n     */\n    ProgressHandler* GetProgressHandler() const;\n\n    // -------------------------------------------------------------------\n    /** Checks whether a default progress handler is active\n     * A default handler is active as long the application doesn't\n     * supply its own custom progress handler via #SetProgressHandler().\n     * @return true by default\n     */\n    bool IsDefaultProgressHandler() const;\n\n    // -------------------------------------------------------------------\n    /** @brief Check whether a given set of post-processing flags\n     *  is supported.\n     *\n     *  Some flags are mutually exclusive, others are probably\n     *  not available because your excluded them from your\n     *  Assimp builds. Calling this function is recommended if\n     *  you're unsure.\n     *\n     *  @param pFlags Bitwise combination of the aiPostProcess flags.\n     *  @return true if this flag combination is fine.\n     */\n    bool ValidateFlags(unsigned int pFlags) const;\n\n    // -------------------------------------------------------------------\n    /** Reads the given file and returns its contents if successful.\n     *\n     * If the call succeeds, the contents of the file are returned as a\n     * pointer to an aiScene object. The returned data is intended to be\n     * read-only, the importer object keeps ownership of the data and will\n     * destroy it upon destruction. If the import fails, NULL is returned.\n     * A human-readable error description can be retrieved by calling\n     * GetErrorString(). The previous scene will be deleted during this call.\n     * @param pFile Path and filename to the file to be imported.\n     * @param pFlags Optional post processing steps to be executed after\n     *   a successful import. Provide a bitwise combination of the\n     *   #aiPostProcessSteps flags. If you wish to inspect the imported\n     *   scene first in order to fine-tune your post-processing setup,\n     *   consider to use #ApplyPostProcessing().\n     * @return A pointer to the imported data, NULL if the import failed.\n     *   The pointer to the scene remains in possession of the Importer\n     *   instance. Use GetOrphanedScene() to take ownership of it.\n     *\n     * @note Assimp is able to determine the file format of a file\n     * automatically.\n     */\n    const aiScene* ReadFile(\n        const char* pFile,\n        unsigned int pFlags);\n\n    // -------------------------------------------------------------------\n    /** Reads the given file from a memory buffer and returns its\n     *  contents if successful.\n     *\n     * If the call succeeds, the contents of the file are returned as a\n     * pointer to an aiScene object. The returned data is intended to be\n     * read-only, the importer object keeps ownership of the data and will\n     * destroy it upon destruction. If the import fails, NULL is returned.\n     * A human-readable error description can be retrieved by calling\n     * GetErrorString(). The previous scene will be deleted during this call.\n     * Calling this method doesn't affect the active IOSystem.\n     * @param pBuffer Pointer to the file data\n     * @param pLength Length of pBuffer, in bytes\n     * @param pFlags Optional post processing steps to be executed after\n     *   a successful import. Provide a bitwise combination of the\n     *   #aiPostProcessSteps flags. If you wish to inspect the imported\n     *   scene first in order to fine-tune your post-processing setup,\n     *   consider to use #ApplyPostProcessing().\n     * @param pHint An additional hint to the library. If this is a non\n     *   empty string, the library looks for a loader to support\n     *   the file extension specified by pHint and passes the file to\n     *   the first matching loader. If this loader is unable to completely\n     *   the request, the library continues and tries to determine the\n     *   file format on its own, a task that may or may not be successful.\n     *   Check the return value, and you'll know ...\n     * @return A pointer to the imported data, NULL if the import failed.\n     *   The pointer to the scene remains in possession of the Importer\n     *   instance. Use GetOrphanedScene() to take ownership of it.\n     *\n     * @note This is a straightforward way to decode models from memory\n     * buffers, but it doesn't handle model formats that spread their\n     * data across multiple files or even directories. Examples include\n     * OBJ or MD3, which outsource parts of their material info into\n     * external scripts. If you need full functionality, provide\n     * a custom IOSystem to make Assimp find these files and use\n     * the regular ReadFile() API.\n     */\n    const aiScene* ReadFileFromMemory(\n        const void* pBuffer,\n        size_t pLength,\n        unsigned int pFlags,\n        const char* pHint = \"\");\n\n    // -------------------------------------------------------------------\n    /** Apply post-processing to an already-imported scene.\n     *\n     *  This is strictly equivalent to calling #ReadFile() with the same\n     *  flags. However, you can use this separate function to inspect\n     *  the imported scene first to fine-tune your post-processing setup.\n     *  @param pFlags Provide a bitwise combination of the\n     *   #aiPostProcessSteps flags.\n     *  @return A pointer to the post-processed data. This is still the\n     *   same as the pointer returned by #ReadFile(). However, if\n     *   post-processing fails, the scene could now be NULL.\n     *   That's quite a rare case, post processing steps are not really\n     *   designed to 'fail'. To be exact, the #aiProcess_ValidateDS\n     *   flag is currently the only post processing step which can actually\n     *   cause the scene to be reset to NULL.\n     *\n     *  @note The method does nothing if no scene is currently bound\n     *    to the #Importer instance.  */\n    const aiScene* ApplyPostProcessing(unsigned int pFlags);\n\n    const aiScene* ApplyCustomizedPostProcessing( BaseProcess *rootProcess, bool requestValidation );\n\n    // -------------------------------------------------------------------\n    /** @brief Reads the given file and returns its contents if successful.\n     *\n     * This function is provided for backward compatibility.\n     * See the const char* version for detailed docs.\n     * @see ReadFile(const char*, pFlags)  */\n    const aiScene* ReadFile(\n        const std::string& pFile,\n        unsigned int pFlags);\n\n    // -------------------------------------------------------------------\n    /** Frees the current scene.\n     *\n     *  The function does nothing if no scene has previously been\n     *  read via ReadFile(). FreeScene() is called automatically by the\n     *  destructor and ReadFile() itself.  */\n    void FreeScene( );\n\n    // -------------------------------------------------------------------\n    /** Returns an error description of an error that occurred in ReadFile().\n     *\n     * Returns an empty string if no error occurred.\n     * @return A description of the last error, an empty string if no\n     *   error occurred. The string is never NULL.\n     *\n     * @note The returned function remains valid until one of the\n     * following methods is called: #ReadFile(), #FreeScene(). */\n    const char* GetErrorString() const;\n\n    // -------------------------------------------------------------------\n    /** Returns the scene loaded by the last successful call to ReadFile()\n     *\n     * @return Current scene or NULL if there is currently no scene loaded */\n    const aiScene* GetScene() const;\n\n    // -------------------------------------------------------------------\n    /** Returns the scene loaded by the last successful call to ReadFile()\n     *  and releases the scene from the ownership of the Importer\n     *  instance. The application is now responsible for deleting the\n     *  scene. Any further calls to GetScene() or GetOrphanedScene()\n     *  will return NULL - until a new scene has been loaded via ReadFile().\n     *\n     * @return Current scene or NULL if there is currently no scene loaded\n     * @note Use this method with maximal caution, and only if you have to.\n     *   By design, aiScene's are exclusively maintained, allocated and\n     *   deallocated by Assimp and no one else. The reasoning behind this\n     *   is the golden rule that deallocations should always be done\n     *   by the module that did the original allocation because heaps\n     *   are not necessarily shared. GetOrphanedScene() enforces you\n     *   to delete the returned scene by yourself, but this will only\n     *   be fine if and only if you're using the same heap as assimp.\n     *   On Windows, it's typically fine provided everything is linked\n     *   against the multithreaded-dll version of the runtime library.\n     *   It will work as well for static linkage with Assimp.*/\n    aiScene* GetOrphanedScene();\n\n    // -------------------------------------------------------------------\n    /** Returns whether a given file extension is supported by ASSIMP.\n     *\n     * @param szExtension Extension to be checked.\n     *   Must include a trailing dot '.'. Example: \".3ds\", \".md3\".\n     *   Cases-insensitive.\n     * @return true if the extension is supported, false otherwise */\n    bool IsExtensionSupported(const char* szExtension) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Returns whether a given file extension is supported by ASSIMP.\n     *\n     * This function is provided for backward compatibility.\n     * See the const char* version for detailed and up-to-date docs.\n     * @see IsExtensionSupported(const char*) */\n    inline bool IsExtensionSupported(const std::string& szExtension) const;\n\n    // -------------------------------------------------------------------\n    /** Get a full list of all file extensions supported by ASSIMP.\n     *\n     * If a file extension is contained in the list this does of course not\n     * mean that ASSIMP is able to load all files with this extension ---\n     * it simply means there is an importer loaded which claims to handle\n     * files with this file extension.\n     * @param szOut String to receive the extension list.\n     *   Format of the list: \"*.3ds;*.obj;*.dae\". This is useful for\n     *   use with the WinAPI call GetOpenFileName(Ex). */\n    void GetExtensionList(aiString& szOut) const;\n\n    // -------------------------------------------------------------------\n    /** @brief Get a full list of all file extensions supported by ASSIMP.\n     *\n     * This function is provided for backward compatibility.\n     * See the aiString version for detailed and up-to-date docs.\n     * @see GetExtensionList(aiString&)*/\n    inline void GetExtensionList(std::string& szOut) const;\n\n    // -------------------------------------------------------------------\n    /** Get the number of importers currently registered with Assimp. */\n    size_t GetImporterCount() const;\n\n    // -------------------------------------------------------------------\n    /** Get meta data for the importer corresponding to a specific index..\n    *\n    *  For the declaration of #aiImporterDesc, include <assimp/importerdesc.h>.\n    *  @param index Index to query, must be within [0,GetImporterCount())\n    *  @return Importer meta data structure, NULL if the index does not\n    *     exist or if the importer doesn't offer meta information (\n    *     importers may do this at the cost of being hated by their peers).*/\n    const aiImporterDesc* GetImporterInfo(size_t index) const;\n\n    // -------------------------------------------------------------------\n    /** Find the importer corresponding to a specific index.\n    *\n    *  @param index Index to query, must be within [0,GetImporterCount())\n    *  @return Importer instance. NULL if the index does not\n    *     exist. */\n    BaseImporter* GetImporter(size_t index) const;\n\n    // -------------------------------------------------------------------\n    /** Find the importer corresponding to a specific file extension.\n    *\n    *  This is quite similar to #IsExtensionSupported except a\n    *  BaseImporter instance is returned.\n    *  @param szExtension Extension to check for. The following formats\n    *    are recognized (BAH being the file extension): \"BAH\" (comparison\n    *    is case-insensitive), \".bah\", \"*.bah\" (wild card and dot\n    *    characters at the beginning of the extension are skipped).\n    *  @return NULL if no importer is found*/\n    BaseImporter* GetImporter (const char* szExtension) const;\n\n    // -------------------------------------------------------------------\n    /** Find the importer index corresponding to a specific file extension.\n    *\n    *  @param szExtension Extension to check for. The following formats\n    *    are recognized (BAH being the file extension): \"BAH\" (comparison\n    *    is case-insensitive), \".bah\", \"*.bah\" (wild card and dot\n    *    characters at the beginning of the extension are skipped).\n    *  @return (size_t)-1 if no importer is found */\n    size_t GetImporterIndex (const char* szExtension) const;\n\n    // -------------------------------------------------------------------\n    /** Returns the storage allocated by ASSIMP to hold the scene data\n     * in memory.\n     *\n     * This refers to the currently loaded file, see #ReadFile().\n     * @param in Data structure to be filled.\n     * @note The returned memory statistics refer to the actual\n     *   size of the use data of the aiScene. Heap-related overhead\n     *   is (naturally) not included.*/\n    void GetMemoryRequirements(aiMemoryInfo& in) const;\n\n    // -------------------------------------------------------------------\n    /** Enables \"extra verbose\" mode.\n     *\n     * 'Extra verbose' means the data structure is validated after *every*\n     * single post processing step to make sure everyone modifies the data\n     * structure in a well-defined manner. This is a debug feature and not\n     * intended for use in production environments. */\n    void SetExtraVerbose(bool bDo);\n\n    // -------------------------------------------------------------------\n    /** Private, do not use. */\n    ImporterPimpl* Pimpl() { return pimpl; }\n    const ImporterPimpl* Pimpl() const { return pimpl; }\n\nprotected:\n\n    // Just because we don't want you to know how we're hacking around.\n    ImporterPimpl* pimpl;\n}; //! class Importer\n\n\n// ----------------------------------------------------------------------------\n// For compatibility, the interface of some functions taking a std::string was\n// changed to const char* to avoid crashes between binary incompatible STL\n// versions. This code her is inlined,  so it shouldn't cause any problems.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE const aiScene* Importer::ReadFile( const std::string& pFile,unsigned int pFlags){\n    return ReadFile(pFile.c_str(),pFlags);\n}\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE void Importer::GetExtensionList(std::string& szOut) const   {\n    aiString s;\n    GetExtensionList(s);\n    szOut = s.data;\n}\n// ----------------------------------------------------------------------------\nAI_FORCE_INLINE bool Importer::IsExtensionSupported(const std::string& szExtension) const   {\n    return IsExtensionSupported(szExtension.c_str());\n}\n\n} // !namespace Assimp\n\n#endif // AI_ASSIMP_HPP_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Importer.hpp b/include/assimp/Importer.hpp
--- a/include/assimp/Importer.hpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Importer.hpp	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,6 +48,10 @@
 #ifndef AI_ASSIMP_HPP_INC
 #define AI_ASSIMP_HPP_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifndef __cplusplus
 #   error This header requires C++ to be used. Use assimp.h for plain C.
 #endif // __cplusplus
@@ -281,7 +285,7 @@
      *  The return value remains valid until the property is modified.
      * @see GetPropertyInteger()
      */
-    const std::string GetPropertyString(const char* szName,
+    std::string GetPropertyString(const char* szName,
         const std::string& sErrorReturn = "") const;
 
     // -------------------------------------------------------------------
@@ -290,7 +294,7 @@
      *  The return value remains valid until the property is modified.
      * @see GetPropertyInteger()
      */
-    const aiMatrix4x4 GetPropertyMatrix(const char* szName,
+    aiMatrix4x4 GetPropertyMatrix(const char* szName,
         const aiMatrix4x4& sErrorReturn = aiMatrix4x4()) const;
 
     // -------------------------------------------------------------------
Index: include/assimp/qnan.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/**  @file  qnan.h\n *   @brief Some utilities for our dealings with qnans.\n *\n *   @note Some loaders use qnans to mark invalid values tempoarily, also\n *     Assimp explicitly enforces undefined normals to be set to qnan.\n *     qnan utilities are available in standard libraries (C99 for example)\n *     but last time I checked compiler coverage was so bad that I decided\n *     to reinvent the wheel.\n */\n\n#ifndef AI_QNAN_H_INCLUDED\n#define AI_QNAN_H_INCLUDED\n\n#include <assimp/defs.h>\n#include <limits>\n#include <stdint.h>\n\n// ---------------------------------------------------------------------------\n/** Data structure to represent the bit pattern of a 32 Bit\n *         IEEE 754 floating-point number. */\nunion _IEEESingle\n{\n    float Float;\n    struct\n    {\n        uint32_t Frac : 23;\n        uint32_t Exp  : 8;\n        uint32_t Sign : 1;\n    } IEEE;\n};\n\n// ---------------------------------------------------------------------------\n/** Data structure to represent the bit pattern of a 64 Bit\n *         IEEE 754 floating-point number. */\nunion _IEEEDouble\n{\n    double Double;\n    struct\n    {\n        uint64_t Frac : 52;\n        uint64_t Exp  : 11;\n        uint64_t Sign : 1;\n    } IEEE;\n};\n\n// ---------------------------------------------------------------------------\n/** Check whether a given float is qNaN.\n *  @param in Input value */\nAI_FORCE_INLINE bool is_qnan(float in)\n{\n    // the straightforward solution does not work:\n    //   return (in != in);\n    // compiler generates code like this\n    //   load <in> to <register-with-different-width>\n    //   compare <register-with-different-width> against <in>\n\n    // FIXME: Use <float> stuff instead? I think fpclassify needs C99\n    _IEEESingle temp;\n    memcpy(&temp, &in, sizeof(float));\n    return (temp.IEEE.Exp == (1u << 8)-1 &&\n        temp.IEEE.Frac);\n}\n\n// ---------------------------------------------------------------------------\n/** Check whether a given double is qNaN.\n *  @param in Input value */\nAI_FORCE_INLINE bool is_qnan(double in)\n{\n    // the straightforward solution does not work:\n    //   return (in != in);\n    // compiler generates code like this\n    //   load <in> to <register-with-different-width>\n    //   compare <register-with-different-width> against <in>\n\n    // FIXME: Use <float> stuff instead? I think fpclassify needs C99\n    _IEEEDouble temp;\n    memcpy(&temp, &in, sizeof(in));\n    return (temp.IEEE.Exp == (1u << 11)-1 &&\n        temp.IEEE.Frac);\n}\n\n// ---------------------------------------------------------------------------\n/** @brief check whether a float is either NaN or (+/-) INF.\n *\n *  Denorms return false, they're treated like normal values.\n *  @param in Input value */\nAI_FORCE_INLINE bool is_special_float(float in)\n{\n    _IEEESingle temp;\n    memcpy(&temp, &in, sizeof(float));\n    return (temp.IEEE.Exp == (1u << 8)-1);\n}\n\n// ---------------------------------------------------------------------------\n/** @brief check whether a double is either NaN or (+/-) INF.\n *\n *  Denorms return false, they're treated like normal values.\n *  @param in Input value */\nAI_FORCE_INLINE bool is_special_float(double in)\n{\n   _IEEESingle temp;\n    memcpy(&temp, &in, sizeof(float));\n    return (temp.IEEE.Exp == (1u << 11)-1);\n}\n\n// ---------------------------------------------------------------------------\n/** Check whether a float is NOT qNaN.\n *  @param in Input value */\ntemplate<class TReal>\nAI_FORCE_INLINE bool is_not_qnan(TReal in)\n{\n    return !is_qnan(in);\n}\n\n// ---------------------------------------------------------------------------\n/** @brief Get a fresh qnan.  */\nAI_FORCE_INLINE ai_real get_qnan()\n{\n    return std::numeric_limits<ai_real>::quiet_NaN();\n}\n\n#endif // !! AI_QNAN_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/qnan.h b/include/assimp/qnan.h
--- a/include/assimp/qnan.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/qnan.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -50,19 +50,23 @@
  *     but last time I checked compiler coverage was so bad that I decided
  *     to reinvent the wheel.
  */
-
+#pragma once
 #ifndef AI_QNAN_H_INCLUDED
 #define AI_QNAN_H_INCLUDED
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/defs.h>
+
 #include <limits>
 #include <stdint.h>
 
 // ---------------------------------------------------------------------------
 /** Data structure to represent the bit pattern of a 32 Bit
  *         IEEE 754 floating-point number. */
-union _IEEESingle
-{
+union _IEEESingle {
     float Float;
     struct
     {
@@ -75,8 +79,7 @@
 // ---------------------------------------------------------------------------
 /** Data structure to represent the bit pattern of a 64 Bit
  *         IEEE 754 floating-point number. */
-union _IEEEDouble
-{
+union _IEEEDouble {
     double Double;
     struct
     {
@@ -89,8 +92,7 @@
 // ---------------------------------------------------------------------------
 /** Check whether a given float is qNaN.
  *  @param in Input value */
-AI_FORCE_INLINE bool is_qnan(float in)
-{
+AI_FORCE_INLINE bool is_qnan(float in) {
     // the straightforward solution does not work:
     //   return (in != in);
     // compiler generates code like this
@@ -107,8 +109,7 @@
 // ---------------------------------------------------------------------------
 /** Check whether a given double is qNaN.
  *  @param in Input value */
-AI_FORCE_INLINE bool is_qnan(double in)
-{
+AI_FORCE_INLINE bool is_qnan(double in) {
     // the straightforward solution does not work:
     //   return (in != in);
     // compiler generates code like this
@@ -127,8 +128,7 @@
  *
  *  Denorms return false, they're treated like normal values.
  *  @param in Input value */
-AI_FORCE_INLINE bool is_special_float(float in)
-{
+AI_FORCE_INLINE bool is_special_float(float in) {
     _IEEESingle temp;
     memcpy(&temp, &in, sizeof(float));
     return (temp.IEEE.Exp == (1u << 8)-1);
@@ -139,8 +139,7 @@
  *
  *  Denorms return false, they're treated like normal values.
  *  @param in Input value */
-AI_FORCE_INLINE bool is_special_float(double in)
-{
+AI_FORCE_INLINE bool is_special_float(double in) {
    _IEEESingle temp;
     memcpy(&temp, &in, sizeof(float));
     return (temp.IEEE.Exp == (1u << 11)-1);
@@ -150,15 +149,13 @@
 /** Check whether a float is NOT qNaN.
  *  @param in Input value */
 template<class TReal>
-AI_FORCE_INLINE bool is_not_qnan(TReal in)
-{
+AI_FORCE_INLINE bool is_not_qnan(TReal in) {
     return !is_qnan(in);
 }
 
 // ---------------------------------------------------------------------------
 /** @brief Get a fresh qnan.  */
-AI_FORCE_INLINE ai_real get_qnan()
-{
+AI_FORCE_INLINE ai_real get_qnan() {
     return std::numeric_limits<ai_real>::quiet_NaN();
 }
 
Index: include/assimp/StreamWriter.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Defines the StreamWriter class which writes data to\n *  a binary stream with a well-defined endianness. */\n\n#ifndef AI_STREAMWRITER_H_INCLUDED\n#define AI_STREAMWRITER_H_INCLUDED\n\n#include \"ByteSwapper.h\"\n#include <assimp/IOStream.hpp>\n\n#include <memory>\n#include <vector>\n\nnamespace Assimp {\n\n// --------------------------------------------------------------------------------------------\n/** Wrapper class around IOStream to allow for consistent writing of binary data in both\n *  little and big endian format. Don't attempt to instance the template directly. Use\n *  StreamWriterLE to write to a little-endian stream and StreamWriterBE to write to a\n *  BE stream. Alternatively, there is StreamWriterAny if the endianness of the output\n *  stream is to be determined at runtime.\n */\n// --------------------------------------------------------------------------------------------\ntemplate <bool SwapEndianess = false, bool RuntimeSwitch = false>\nclass StreamWriter\n{\n    enum {\n        INITIAL_CAPACITY = 1024\n    };\n\npublic:\n\n    // ---------------------------------------------------------------------\n    /** Construction from a given stream with a well-defined endianness.\n     *\n     *  The StreamReader holds a permanent strong reference to the\n     *  stream, which is released upon destruction.\n     *  @param stream Input stream. The stream is not re-seeked and writing\n          continues at the current position of the stream cursor.\n     *  @param le If @c RuntimeSwitch is true: specifies whether the\n     *    stream is in little endian byte order. Otherwise the\n     *    endianness information is defined by the @c SwapEndianess\n     *    template parameter and this parameter is meaningless.  */\n    StreamWriter(std::shared_ptr<IOStream> stream, bool le = false)\n        : stream(stream)\n        , le(le)\n        , cursor()\n    {\n        ai_assert(stream);\n        buffer.reserve(INITIAL_CAPACITY);\n    }\n\n    // ---------------------------------------------------------------------\n    StreamWriter(IOStream* stream, bool le = false)\n        : stream(std::shared_ptr<IOStream>(stream))\n        , le(le)\n        , cursor()\n    {\n        ai_assert(stream);\n        buffer.reserve(INITIAL_CAPACITY);\n    }\n\n    // ---------------------------------------------------------------------\n    ~StreamWriter() {\n        stream->Write(buffer.data(), 1, buffer.size());\n        stream->Flush();\n    }\n\npublic:\n\n    // ---------------------------------------------------------------------\n    /** Flush the contents of the internal buffer, and the output IOStream */\n    void Flush()\n    {\n        stream->Write(buffer.data(), 1, buffer.size());\n        stream->Flush();\n        buffer.clear();\n        cursor = 0;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Seek to the given offset / origin in the output IOStream.\n     *\n     *  Flushes the internal buffer and the output IOStream prior to seeking. */\n    aiReturn Seek(size_t pOffset, aiOrigin pOrigin=aiOrigin_SET)\n    {\n        Flush();\n        return stream->Seek(pOffset, pOrigin);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Tell the current position in the output IOStream.\n     *\n     *  First flushes the internal buffer and the output IOStream. */\n    size_t Tell()\n    {\n        Flush();\n        return stream->Tell();\n    }\n\npublic:\n\n    // ---------------------------------------------------------------------\n    /** Write a float to the stream  */\n    void PutF4(float f)\n    {\n        Put(f);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a double to the stream  */\n    void PutF8(double d)    {\n        Put(d);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a signed 16 bit integer to the stream */\n    void PutI2(int16_t n)   {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a signed 8 bit integer to the stream */\n    void PutI1(int8_t n)    {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write an signed 32 bit integer to the stream */\n    void PutI4(int32_t n)   {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a signed 64 bit integer to the stream */\n    void PutI8(int64_t n)   {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a unsigned 16 bit integer to the stream */\n    void PutU2(uint16_t n)  {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a unsigned 8 bit integer to the stream */\n    void PutU1(uint8_t n)   {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write an unsigned 32 bit integer to the stream */\n    void PutU4(uint32_t n)  {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a unsigned 64 bit integer to the stream */\n    void PutU8(uint64_t n)  {\n        Put(n);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a single character to the stream */\n    void PutChar(char c)    {\n        Put(c);\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write an aiString to the stream */\n    void PutString(const aiString& s)\n    {\n        // as Put(T f) below\n        if (cursor + s.length >= buffer.size()) {\n            buffer.resize(cursor + s.length);\n        }\n        void* dest = &buffer[cursor];\n        ::memcpy(dest, s.C_Str(), s.length);\n        cursor += s.length;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Write a std::string to the stream */\n    void PutString(const std::string& s)\n    {\n        // as Put(T f) below\n        if (cursor + s.size() >= buffer.size()) {\n            buffer.resize(cursor + s.size());\n        }\n        void* dest = &buffer[cursor];\n        ::memcpy(dest, s.c_str(), s.size());\n        cursor += s.size();\n    }\n\npublic:\n\n    // ---------------------------------------------------------------------\n    /** overload operator<< and allow chaining of MM ops. */\n    template <typename T>\n    StreamWriter& operator << (T f) {\n        Put(f);\n        return *this;\n    }\n\n    // ---------------------------------------------------------------------\n    std::size_t GetCurrentPos() const {\n        return cursor;\n    }\n\n    // ---------------------------------------------------------------------\n    void SetCurrentPos(std::size_t new_cursor) {\n        cursor = new_cursor;\n    }\n\n    // ---------------------------------------------------------------------\n    /** Generic write method. ByteSwap::Swap(T*) *must* be defined */\n    template <typename T>\n    void Put(T f)   {\n        Intern :: Getter<SwapEndianess,T,RuntimeSwitch>() (&f, le);\n\n        if (cursor + sizeof(T) >= buffer.size()) {\n            buffer.resize(cursor + sizeof(T));\n        }\n\n        void* dest = &buffer[cursor];\n\n        // reinterpret_cast + assignment breaks strict aliasing rules\n        // and generally causes trouble on platforms such as ARM that\n        // do not silently ignore alignment faults.\n        ::memcpy(dest, &f, sizeof(T));\n        cursor += sizeof(T);\n    }\n\nprivate:\n\n    std::shared_ptr<IOStream> stream;\n    bool le;\n\n    std::vector<uint8_t> buffer;\n    std::size_t cursor;\n};\n\n\n// --------------------------------------------------------------------------------------------\n// `static` StreamWriter. Their byte order is fixed and they might be a little bit faster.\n#ifdef AI_BUILD_BIG_ENDIAN\n    typedef StreamWriter<true>  StreamWriterLE;\n    typedef StreamWriter<false> StreamWriterBE;\n#else\n    typedef StreamWriter<true>  StreamWriterBE;\n    typedef StreamWriter<false> StreamWriterLE;\n#endif\n\n// `dynamic` StreamWriter. The byte order of the input data is specified in the\n// c'tor. This involves runtime branching and might be a little bit slower.\ntypedef StreamWriter<true,true> StreamWriterAny;\n\n} // end namespace Assimp\n\n#endif // !! AI_STREAMWriter_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/StreamWriter.h b/include/assimp/StreamWriter.h
--- a/include/assimp/StreamWriter.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/StreamWriter.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -43,11 +43,15 @@
 
 /** @file Defines the StreamWriter class which writes data to
  *  a binary stream with a well-defined endianness. */
-
+#pragma once
 #ifndef AI_STREAMWRITER_H_INCLUDED
 #define AI_STREAMWRITER_H_INCLUDED
 
-#include "ByteSwapper.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/ByteSwapper.h>
 #include <assimp/IOStream.hpp>
 
 #include <memory>
Index: include/assimp/vector2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n/** @file vector2.h\n *  @brief 2D vector structure, including operators when compiling in C++\n */\n#pragma once\n#ifndef AI_VECTOR2D_H_INC\n#define AI_VECTOR2D_H_INC\n\n#ifdef __cplusplus\n#   include <cmath>\n#else\n#   include <math.h>\n#endif\n\n#include \"defs.h\"\n\n// ----------------------------------------------------------------------------------\n/** Represents a two-dimensional vector.\n */\n\n#ifdef __cplusplus\ntemplate <typename TReal>\nclass aiVector2t {\npublic:\n    aiVector2t () : x(), y() {}\n    aiVector2t (TReal _x, TReal _y) : x(_x), y(_y) {}\n    explicit aiVector2t (TReal _xyz) : x(_xyz), y(_xyz) {}\n    aiVector2t (const aiVector2t& o) = default;\n\n    void Set( TReal pX, TReal pY);\n    TReal SquareLength() const ;\n    TReal Length() const ;\n    aiVector2t& Normalize();\n\n    const aiVector2t& operator += (const aiVector2t& o);\n    const aiVector2t& operator -= (const aiVector2t& o);\n    const aiVector2t& operator *= (TReal f);\n    const aiVector2t& operator /= (TReal f);\n\n    TReal operator[](unsigned int i) const;\n\n    bool operator== (const aiVector2t& other) const;\n    bool operator!= (const aiVector2t& other) const;\n\n    bool Equal(const aiVector2t& other, TReal epsilon = 1e-6) const;\n\n    aiVector2t& operator= (TReal f);\n    const aiVector2t SymMul(const aiVector2t& o);\n\n    template <typename TOther>\n    operator aiVector2t<TOther> () const;\n\n    TReal x, y;\n};\n\ntypedef aiVector2t<ai_real> aiVector2D;\n\n#else\n\nstruct aiVector2D {\n    ai_real x, y;\n};\n\n#endif // __cplusplus\n\n#endif // AI_VECTOR2D_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/vector2.h b/include/assimp/vector2.h
--- a/include/assimp/vector2.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/vector2.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -47,6 +47,10 @@
 #ifndef AI_VECTOR2D_H_INC
 #define AI_VECTOR2D_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
 #   include <cmath>
 #else
Index: include/assimp/MemoryIOWrapper.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file MemoryIOWrapper.h\n *  Handy IOStream/IOSystem implemetation to read directly from a memory buffer */\n#ifndef AI_MEMORYIOSTREAM_H_INC\n#define AI_MEMORYIOSTREAM_H_INC\n\n#include <assimp/IOStream.hpp>\n#include <assimp/IOSystem.hpp>\n#include <assimp/ai_assert.h>\n#include <stdint.h>\n\nnamespace Assimp    {\n    \n#define AI_MEMORYIO_MAGIC_FILENAME \"$$$___magic___$$$\"\n#define AI_MEMORYIO_MAGIC_FILENAME_LENGTH 17\n\n// ----------------------------------------------------------------------------------\n/** Implementation of IOStream to read directly from a memory buffer */\n// ----------------------------------------------------------------------------------\nclass MemoryIOStream : public IOStream {\npublic:\n    MemoryIOStream (const uint8_t* buff, size_t len, bool own = false)\n    : buffer (buff)\n    , length(len)\n    , pos((size_t)0)\n    , own(own) {\n        // empty\n    }\n\n    ~MemoryIOStream ()  {\n        if(own) {\n            delete[] buffer;\n        }\n    }\n\n    // -------------------------------------------------------------------\n    // Read from stream\n    size_t Read(void* pvBuffer, size_t pSize, size_t pCount)    {\n        ai_assert(nullptr != pvBuffer);\n        ai_assert(0 != pSize);\n        \n        const size_t cnt = std::min( pCount, (length-pos) / pSize);\n        const size_t ofs = pSize * cnt;\n\n        ::memcpy(pvBuffer,buffer+pos,ofs);\n        pos += ofs;\n\n        return cnt;\n    }\n\n    // -------------------------------------------------------------------\n    // Write to stream\n    size_t Write(const void* /*pvBuffer*/, size_t /*pSize*/,size_t /*pCount*/)  {\n        ai_assert(false); // won't be needed\n        return 0;\n    }\n\n    // -------------------------------------------------------------------\n    // Seek specific position\n    aiReturn Seek(size_t pOffset, aiOrigin pOrigin) {\n        if (aiOrigin_SET == pOrigin) {\n            if (pOffset > length) {\n                return AI_FAILURE;\n            }\n            pos = pOffset;\n        } else if (aiOrigin_END == pOrigin) {\n            if (pOffset > length) {\n                return AI_FAILURE;\n            }\n            pos = length-pOffset;\n        } else {\n            if (pOffset+pos > length) {\n                return AI_FAILURE;\n            }\n            pos += pOffset;\n        }\n        return AI_SUCCESS;\n    }\n\n    // -------------------------------------------------------------------\n    // Get current seek position\n    size_t Tell() const {\n        return pos;\n    }\n\n    // -------------------------------------------------------------------\n    // Get size of file\n    size_t FileSize() const {\n        return length;\n    }\n\n    // -------------------------------------------------------------------\n    // Flush file contents\n    void Flush() {\n        ai_assert(false); // won't be needed\n    }\n\nprivate:\n    const uint8_t* buffer;\n    size_t length,pos;\n    bool own;\n};\n\n// ---------------------------------------------------------------------------\n/** Dummy IO system to read from a memory buffer */\nclass MemoryIOSystem : public IOSystem {\npublic:\n    /** Constructor. */\n    MemoryIOSystem(const uint8_t* buff, size_t len, IOSystem* io)\n    : buffer(buff)\n    , length(len)\n    , existing_io(io)\n    , created_streams() {\n        // empty\n    }\n\n    /** Destructor. */\n    ~MemoryIOSystem() {\n    }\n\n    // -------------------------------------------------------------------\n    /** Tests for the existence of a file at the given path. */\n    bool Exists(const char* pFile) const override {\n        if (0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {\n            return true;\n        }\n        return existing_io ? existing_io->Exists(pFile) : false;\n    }\n\n    // -------------------------------------------------------------------\n    /** Returns the directory separator. */\n    char getOsSeparator() const override {\n        return existing_io ? existing_io->getOsSeparator()\n                           : '/';  // why not? it doesn't care\n    }\n\n    // -------------------------------------------------------------------\n    /** Open a new file with a given path. */\n    IOStream* Open(const char* pFile, const char* pMode = \"rb\") override {\n        if ( 0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {\n            created_streams.emplace_back(new MemoryIOStream(buffer, length));\n            return created_streams.back();\n        }\n        return existing_io ? existing_io->Open(pFile, pMode) : NULL;\n    }\n\n    // -------------------------------------------------------------------\n    /** Closes the given file and releases all resources associated with it. */\n    void Close( IOStream* pFile) override {\n        auto it = std::find(created_streams.begin(), created_streams.end(), pFile);\n        if (it != created_streams.end()) {\n            delete pFile;\n            created_streams.erase(it);\n        } else if (existing_io) {\n            existing_io->Close(pFile);\n        }\n    }\n\n    // -------------------------------------------------------------------\n    /** Compare two paths */\n    bool ComparePaths(const char* one, const char* second) const override {\n        return existing_io ? existing_io->ComparePaths(one, second) : false;\n    }\n\n    bool PushDirectory( const std::string &path ) override { \n        return existing_io ? existing_io->PushDirectory(path) : false;\n    }\n\n    const std::string &CurrentDirectory() const override {\n        static std::string empty;\n        return existing_io ? existing_io->CurrentDirectory() : empty;\n    }\n\n    size_t StackSize() const override {\n        return existing_io ? existing_io->StackSize() : 0;\n    }\n\n    bool PopDirectory() override {\n        return existing_io ? existing_io->PopDirectory() : false;\n    }\n\n    bool CreateDirectory( const std::string &path ) override {\n        return existing_io ? existing_io->CreateDirectory(path) : false;\n    }\n\n    bool ChangeDirectory( const std::string &path ) override {\n        return existing_io ? existing_io->ChangeDirectory(path) : false;\n    }\n\n    bool DeleteFile( const std::string &file ) override {\n        return existing_io ? existing_io->DeleteFile(file) : false;\n    }\n\nprivate:\n    const uint8_t* buffer;\n    size_t length;\n    IOSystem* existing_io;\n    std::vector<IOStream*> created_streams;\n};\n\n} // end namespace Assimp\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/MemoryIOWrapper.h b/include/assimp/MemoryIOWrapper.h
--- a/include/assimp/MemoryIOWrapper.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/MemoryIOWrapper.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -42,12 +42,18 @@
 
 /** @file MemoryIOWrapper.h
  *  Handy IOStream/IOSystem implemetation to read directly from a memory buffer */
+#pragma once
 #ifndef AI_MEMORYIOSTREAM_H_INC
 #define AI_MEMORYIOSTREAM_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/IOStream.hpp>
 #include <assimp/IOSystem.hpp>
 #include <assimp/ai_assert.h>
+
 #include <stdint.h>
 
 namespace Assimp    {
Index: include/assimp/version.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  version.h\n *  @brief Functions to query the version of the Assimp runtime, check\n *    compile flags, ...\n */\n#pragma once\n#ifndef AI_VERSION_H_INC\n#define AI_VERSION_H_INC\n\n#include \"defs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n/** @brief Returns a string with legal copyright and licensing information\n *  about Assimp. The string may include multiple lines.\n *  @return Pointer to static string.\n */\nASSIMP_API const char*  aiGetLegalString  (void);\n\n// ---------------------------------------------------------------------------\n/** @brief Returns the current minor version number of Assimp.\n *  @return Minor version of the Assimp runtime the application was\n *    linked/built against\n */\nASSIMP_API unsigned int aiGetVersionMinor (void);\n\n// ---------------------------------------------------------------------------\n/** @brief Returns the current major version number of Assimp.\n *  @return Major version of the Assimp runtime the application was\n *    linked/built against\n */\nASSIMP_API unsigned int aiGetVersionMajor (void);\n\n// ---------------------------------------------------------------------------\n/** @brief Returns the repository revision of the Assimp runtime.\n *  @return SVN Repository revision number of the Assimp runtime the\n *          application was linked/built against.\n */\nASSIMP_API unsigned int aiGetVersionRevision (void);\n\n// ---------------------------------------------------------------------------\n/** @brief Returns the branchname of the Assimp runtime.\n *  @return The current branch name.\n */\nASSIMP_API const char *aiGetBranchName();\n\n//! Assimp was compiled as a shared object (Windows: DLL)\n#define ASSIMP_CFLAGS_SHARED  0x1\n//! Assimp was compiled against STLport\n#define ASSIMP_CFLAGS_STLPORT 0x2\n//! Assimp was compiled as a debug build\n#define ASSIMP_CFLAGS_DEBUG   0x4\n\n//! Assimp was compiled with ASSIMP_BUILD_BOOST_WORKAROUND defined\n#define ASSIMP_CFLAGS_NOBOOST           0x8\n//! Assimp was compiled with ASSIMP_BUILD_SINGLETHREADED defined\n#define ASSIMP_CFLAGS_SINGLETHREADED    0x10\n\n// ---------------------------------------------------------------------------\n/** @brief Returns assimp's compile flags\n *  @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.\n */\nASSIMP_API unsigned int aiGetCompileFlags (void);\n\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n\n#endif // !! #ifndef AI_VERSION_H_INC\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/version.h b/include/assimp/version.h
--- a/include/assimp/version.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/version.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -49,7 +49,7 @@
 #ifndef AI_VERSION_H_INC
 #define AI_VERSION_H_INC
 
-#include "defs.h"
+#include <assimp/defs.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -62,6 +62,13 @@
  */
 ASSIMP_API const char*  aiGetLegalString  (void);
 
+// ---------------------------------------------------------------------------
+/** @brief Returns the current patch version number of Assimp.
+ *  @return Patch version of the Assimp runtime the application was
+ *    linked/built against
+ */
+ASSIMP_API unsigned int aiGetVersionPatch(void);
+
 // ---------------------------------------------------------------------------
 /** @brief Returns the current minor version number of Assimp.
  *  @return Minor version of the Assimp runtime the application was
Index: include/assimp/camera.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file camera.h\n *  @brief Defines the aiCamera data structure\n */\n\n#pragma once\n#ifndef AI_CAMERA_H_INC\n#define AI_CAMERA_H_INC\n\n#include \"types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n/** Helper structure to describe a virtual camera.\n *\n * Cameras have a representation in the node graph and can be animated.\n * An important aspect is that the camera itself is also part of the\n * scene-graph. This means, any values such as the look-at vector are not\n * *absolute*, they're <b>relative</b> to the coordinate system defined\n * by the node which corresponds to the camera. This allows for camera\n * animations. For static cameras parameters like the 'look-at' or 'up' vectors\n * are usually specified directly in aiCamera, but beware, they could also\n * be encoded in the node transformation. The following (pseudo)code sample\n * shows how to do it: <br><br>\n * @code\n * // Get the camera matrix for a camera at a specific time\n * // if the node hierarchy for the camera does not contain\n * // at least one animated node this is a static computation\n * get-camera-matrix (node sceneRoot, camera cam) : matrix\n * {\n *    node   cnd = find-node-for-camera(cam)\n *    matrix cmt = identity()\n *\n *    // as usual - get the absolute camera transformation for this frame\n *    for each node nd in hierarchy from sceneRoot to cnd\n *      matrix cur\n *      if (is-animated(nd))\n *         cur = eval-animation(nd)\n *      else cur = nd->mTransformation;\n *      cmt = mult-matrices( cmt, cur )\n *    end for\n *\n *    // now multiply with the camera's own local transform\n *    cam = mult-matrices (cam, get-camera-matrix(cmt) )\n * }\n * @endcode\n *\n * @note some file formats (such as 3DS, ASE) export a \"target point\" -\n * the point the camera is looking at (it can even be animated). Assimp\n * writes the target point as a subnode of the camera's main node,\n * called \"<camName>.Target\". However this is just additional information\n * then the transformation tracks of the camera main node make the\n * camera already look in the right direction.\n *\n*/\nstruct aiCamera\n{\n    /** The name of the camera.\n     *\n     *  There must be a node in the scenegraph with the same name.\n     *  This node specifies the position of the camera in the scene\n     *  hierarchy and can be animated.\n     */\n    C_STRUCT aiString mName;\n\n    /** Position of the camera relative to the coordinate space\n     *  defined by the corresponding node.\n     *\n     *  The default value is 0|0|0.\n     */\n    C_STRUCT aiVector3D mPosition;\n\n    /** 'Up' - vector of the camera coordinate system relative to\n     *  the coordinate space defined by the corresponding node.\n     *\n     *  The 'right' vector of the camera coordinate system is\n     *  the cross product of  the up and lookAt vectors.\n     *  The default value is 0|1|0. The vector\n     *  may be normalized, but it needn't.\n     */\n    C_STRUCT aiVector3D mUp;\n\n\n    /** 'LookAt' - vector of the camera coordinate system relative to\n     *  the coordinate space defined by the corresponding node.\n     *\n     *  This is the viewing direction of the user.\n     *  The default value is 0|0|1. The vector\n     *  may be normalized, but it needn't.\n     */\n    C_STRUCT aiVector3D mLookAt;\n\n    /** Half horizontal field of view angle, in radians.\n     *\n     *  The field of view angle is the angle between the center\n     *  line of the screen and the left or right border.\n     *  The default value is 1/4PI.\n     */\n    float mHorizontalFOV;\n\n    /** Distance of the near clipping plane from the camera.\n     *\n     * The value may not be 0.f (for arithmetic reasons to prevent\n     * a division through zero). The default value is 0.1f.\n     */\n    float mClipPlaneNear;\n\n    /** Distance of the far clipping plane from the camera.\n     *\n     * The far clipping plane must, of course, be further away than the\n     * near clipping plane. The default value is 1000.f. The ratio\n     * between the near and the far plane should not be too\n     * large (between 1000-10000 should be ok) to avoid floating-point\n     * inaccuracies which could lead to z-fighting.\n     */\n    float mClipPlaneFar;\n\n    /** Screen aspect ratio.\n     *\n     * This is the ration between the width and the height of the\n     * screen. Typical values are 4/3, 1/2 or 1/1. This value is\n     * 0 if the aspect ratio is not defined in the source file.\n     * 0 is also the default value.\n     */\n    float mAspect;\n\n#ifdef __cplusplus\n\n    aiCamera() AI_NO_EXCEPT\n        : mUp               (0.f,1.f,0.f)\n        , mLookAt           (0.f,0.f,1.f)\n        , mHorizontalFOV    (0.25f * (float)AI_MATH_PI)\n        , mClipPlaneNear    (0.1f)\n        , mClipPlaneFar     (1000.f)\n        , mAspect           (0.f)\n    {}\n\n    /** @brief Get a *right-handed* camera matrix from me\n     *  @param out Camera matrix to be filled\n     */\n    void GetCameraMatrix (aiMatrix4x4& out) const\n    {\n        /** todo: test ... should work, but i'm not absolutely sure */\n\n        /** We don't know whether these vectors are already normalized ...*/\n        aiVector3D zaxis = mLookAt;     zaxis.Normalize();\n        aiVector3D yaxis = mUp;         yaxis.Normalize();\n        aiVector3D xaxis = mUp^mLookAt; xaxis.Normalize();\n\n        out.a4 = -(xaxis * mPosition);\n        out.b4 = -(yaxis * mPosition);\n        out.c4 = -(zaxis * mPosition);\n\n        out.a1 = xaxis.x;\n        out.a2 = xaxis.y;\n        out.a3 = xaxis.z;\n\n        out.b1 = yaxis.x;\n        out.b2 = yaxis.y;\n        out.b3 = yaxis.z;\n\n        out.c1 = zaxis.x;\n        out.c2 = zaxis.y;\n        out.c3 = zaxis.z;\n\n        out.d1 = out.d2 = out.d3 = 0.f;\n        out.d4 = 1.f;\n    }\n\n#endif\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // AI_CAMERA_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/camera.h b/include/assimp/camera.h
--- a/include/assimp/camera.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/camera.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -47,6 +47,10 @@
 #ifndef AI_CAMERA_H_INC
 #define AI_CAMERA_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include "types.h"
 
 #ifdef __cplusplus
Index: include/assimp/LineSplitter.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file  LineSplitter.h\n *  @brief LineSplitter, a helper class to iterate through all lines\n *    of a file easily. Works with StreamReader.\n */\n#pragma once\n#ifndef INCLUDED_LINE_SPLITTER_H\n#define INCLUDED_LINE_SPLITTER_H\n\n#include <stdexcept>\n#include \"StreamReader.h\"\n#include \"ParsingUtils.h\"\n\nnamespace Assimp {\n\n// ------------------------------------------------------------------------------------------------\n/** Usage:\n@code\nfor(LineSplitter splitter(stream);splitter;++splitter) {\n\n    if (*splitter == \"hi!\") {\n       ...\n    }\n    else if (splitter->substr(0,5) == \"hello\") {\n       ...\n       // access the third token in the line (tokens are space-separated)\n       if (strtol(splitter[2]) > 5) { .. }\n    }\n\n    std::cout << \"Current line is: \" << splitter.get_index() << std::endl;\n}\n@endcode\n*/\n// ------------------------------------------------------------------------------------------------\nclass LineSplitter {\npublic:\n    typedef size_t line_idx;\n\n    // -----------------------------------------\n    /** construct from existing stream reader\n    note: trim is *always* assumed true if skyp_empty_lines==true\n    */\n    LineSplitter(StreamReaderLE& stream, bool skip_empty_lines = true, bool trim = true);\n\n    ~LineSplitter();\n\n    // -----------------------------------------\n    /** pseudo-iterator increment */\n    LineSplitter& operator++();\n\n    // -----------------------------------------\n    LineSplitter& operator++(int);\n\n    // -----------------------------------------\n    /** get a pointer to the beginning of a particular token */\n    const char* operator[] (size_t idx) const;\n\n    // -----------------------------------------\n    /** extract the start positions of N tokens from the current line*/\n    template <size_t N>\n    void get_tokens(const char* (&tokens)[N]) const;\n\n    // -----------------------------------------\n    /** member access */\n    const std::string* operator -> () const;\n\n    std::string operator* () const;\n\n    // -----------------------------------------\n    /** boolean context */\n    operator bool() const;\n\n    // -----------------------------------------\n    /** line indices are zero-based, empty lines are included */\n    operator line_idx() const;\n\n    line_idx get_index() const;\n\n    // -----------------------------------------\n    /** access the underlying stream object */\n    StreamReaderLE& get_stream();\n\n    // -----------------------------------------\n    /** !strcmp((*this)->substr(0,strlen(check)),check) */\n    bool match_start(const char* check);\n\n    // -----------------------------------------\n    /** swallow the next call to ++, return the previous value. */\n    void swallow_next_increment();\n\n    LineSplitter( const LineSplitter & ) = delete;\n    LineSplitter(LineSplitter &&) = delete;\n    LineSplitter &operator = ( const LineSplitter & ) = delete;\n\nprivate:\n    line_idx mIdx;\n    std::string mCur;\n    StreamReaderLE& mStream;\n    bool mSwallow, mSkip_empty_lines, mTrim;\n};\n\ninline\nLineSplitter::LineSplitter(StreamReaderLE& stream, bool skip_empty_lines, bool trim )\n: mIdx(0)\n, mCur()\n, mStream(stream)\n, mSwallow()\n, mSkip_empty_lines(skip_empty_lines)\n, mTrim(trim) {\n    mCur.reserve(1024);\n    operator++();\n    mIdx = 0;\n}\n\ninline\nLineSplitter::~LineSplitter() {\n    // empty\n}\n\ninline\nLineSplitter& LineSplitter::operator++() {\n    if (mSwallow) {\n        mSwallow = false;\n        return *this;\n    }\n\n    if (!*this) {\n        throw std::logic_error(\"End of file, no more lines to be retrieved.\");\n    }\n\n    char s;\n    mCur.clear();\n    while (mStream.GetRemainingSize() && (s = mStream.GetI1(), 1)) {\n        if (s == '\\n' || s == '\\r') {\n            if (mSkip_empty_lines) {\n                while (mStream.GetRemainingSize() && ((s = mStream.GetI1()) == ' ' || s == '\\r' || s == '\\n'));\n                if (mStream.GetRemainingSize()) {\n                    mStream.IncPtr(-1);\n                }\n            } else {\n                // skip both potential line terminators but don't read past this line.\n                if (mStream.GetRemainingSize() && (s == '\\r' && mStream.GetI1() != '\\n')) {\n                    mStream.IncPtr(-1);\n                }\n                if (mTrim) {\n                    while (mStream.GetRemainingSize() && ((s = mStream.GetI1()) == ' ' || s == '\\t'));\n                    if (mStream.GetRemainingSize()) {\n                        mStream.IncPtr(-1);\n                    }\n                }\n            }\n            break;\n        }\n        mCur += s;\n    }\n    ++mIdx;\n\n    return *this;\n}\n\ninline\nLineSplitter &LineSplitter::operator++(int) {\n    return ++(*this);\n}\n\ninline\nconst char *LineSplitter::operator[] (size_t idx) const {\n    const char* s = operator->()->c_str();\n\n    SkipSpaces(&s);\n    for (size_t i = 0; i < idx; ++i) {\n\n        for (; !IsSpace(*s); ++s) {\n            if (IsLineEnd(*s)) {\n                throw std::range_error(\"Token index out of range, EOL reached\");\n            }\n        }\n        SkipSpaces(&s);\n    }\n    return s;\n}\n\ntemplate <size_t N>\ninline\nvoid LineSplitter::get_tokens(const char* (&tokens)[N]) const {\n    const char* s = operator->()->c_str();\n\n    SkipSpaces(&s);\n    for (size_t i = 0; i < N; ++i) {\n        if (IsLineEnd(*s)) {\n            throw std::range_error(\"Token count out of range, EOL reached\");\n        }\n        tokens[i] = s;\n\n        for (; *s && !IsSpace(*s); ++s);\n        SkipSpaces(&s);\n    }\n}\n\ninline\nconst std::string* LineSplitter::operator -> () const {\n    return &mCur;\n}\n\ninline\nstd::string LineSplitter::operator* () const {\n    return mCur;\n}\n\ninline\nLineSplitter::operator bool() const {\n    return mStream.GetRemainingSize() > 0;\n}\n\ninline\nLineSplitter::operator line_idx() const {\n    return mIdx;\n}\n\ninline\nLineSplitter::line_idx LineSplitter::get_index() const {\n    return mIdx;\n}\n\ninline\nStreamReaderLE &LineSplitter::get_stream() {\n    return mStream;\n}\n\ninline\nbool LineSplitter::match_start(const char* check) {\n    const size_t len = ::strlen(check);\n\n    return len <= mCur.length() && std::equal(check, check + len, mCur.begin());\n}\n\ninline\nvoid LineSplitter::swallow_next_increment() {\n    mSwallow = true;\n}\n\n} // Namespace Assimp\n\n#endif // INCLUDED_LINE_SPLITTER_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/LineSplitter.h b/include/assimp/LineSplitter.h
--- a/include/assimp/LineSplitter.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/LineSplitter.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -48,9 +48,13 @@
 #ifndef INCLUDED_LINE_SPLITTER_H
 #define INCLUDED_LINE_SPLITTER_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <stdexcept>
-#include "StreamReader.h"
-#include "ParsingUtils.h"
+#include <assimp/StreamReader.h>
+#include <assimp/ParsingUtils.h>
 
 namespace Assimp {
 
@@ -68,7 +72,7 @@
        if (strtol(splitter[2]) > 5) { .. }
     }
 
-    std::cout << "Current line is: " << splitter.get_index() << std::endl;
+    ASSIMP_LOG_DEBUG_F("Current line is: ", splitter.get_index());
 }
 @endcode
 */
@@ -140,7 +144,7 @@
     bool mSwallow, mSkip_empty_lines, mTrim;
 };
 
-inline
+AI_FORCE_INLINE
 LineSplitter::LineSplitter(StreamReaderLE& stream, bool skip_empty_lines, bool trim )
 : mIdx(0)
 , mCur()
@@ -153,12 +157,12 @@
     mIdx = 0;
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter::~LineSplitter() {
     // empty
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter& LineSplitter::operator++() {
     if (mSwallow) {
         mSwallow = false;
@@ -199,12 +203,12 @@
     return *this;
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter &LineSplitter::operator++(int) {
     return ++(*this);
 }
 
-inline
+AI_FORCE_INLINE
 const char *LineSplitter::operator[] (size_t idx) const {
     const char* s = operator->()->c_str();
 
@@ -222,7 +226,7 @@
 }
 
 template <size_t N>
-inline
+AI_FORCE_INLINE
 void LineSplitter::get_tokens(const char* (&tokens)[N]) const {
     const char* s = operator->()->c_str();
 
@@ -238,44 +242,44 @@
     }
 }
 
-inline
+AI_FORCE_INLINE
 const std::string* LineSplitter::operator -> () const {
     return &mCur;
 }
 
-inline
+AI_FORCE_INLINE
 std::string LineSplitter::operator* () const {
     return mCur;
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter::operator bool() const {
     return mStream.GetRemainingSize() > 0;
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter::operator line_idx() const {
     return mIdx;
 }
 
-inline
+AI_FORCE_INLINE
 LineSplitter::line_idx LineSplitter::get_index() const {
     return mIdx;
 }
 
-inline
+AI_FORCE_INLINE
 StreamReaderLE &LineSplitter::get_stream() {
     return mStream;
 }
 
-inline
+AI_FORCE_INLINE
 bool LineSplitter::match_start(const char* check) {
     const size_t len = ::strlen(check);
 
     return len <= mCur.length() && std::equal(check, check + len, mCur.begin());
 }
 
-inline
+AI_FORCE_INLINE
 void LineSplitter::swallow_next_increment() {
     mSwallow = true;
 }
Index: include/assimp/LogAux.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file  LogAux.h\n *  @brief Common logging usage patterns for importer implementations\n */\n#ifndef INCLUDED_AI_LOGAUX_H\n#define INCLUDED_AI_LOGAUX_H\n\n#include <assimp/TinyFormatter.h>\n#include <assimp/Exceptional.h>\n#include <assimp/DefaultLogger.hpp>\n\nnamespace Assimp {\n\ntemplate<class TDeriving>\nclass LogFunctions {\npublic:\n    // ------------------------------------------------------------------------------------------------\n    static void ThrowException(const std::string& msg)\n    {\n        throw DeadlyImportError(Prefix()+msg);\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogWarn(const Formatter::format& message)   {\n        if (!DefaultLogger::isNullLogger()) {\n            ASSIMP_LOG_WARN(Prefix()+(std::string)message);\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogError(const Formatter::format& message)  {\n        if (!DefaultLogger::isNullLogger()) {\n            ASSIMP_LOG_ERROR(Prefix()+(std::string)message);\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogInfo(const Formatter::format& message)   {\n        if (!DefaultLogger::isNullLogger()) {\n            ASSIMP_LOG_INFO(Prefix()+(std::string)message);\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogDebug(const Formatter::format& message)  {\n        if (!DefaultLogger::isNullLogger()) {\n            ASSIMP_LOG_DEBUG(Prefix()+(std::string)message);\n        }\n    }\n\n    // https://sourceforge.net/tracker/?func=detail&atid=1067632&aid=3358562&group_id=226462\n#if !defined(__GNUC__) || !defined(__APPLE__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogWarn  (const char* message) {\n        if (!DefaultLogger::isNullLogger()) {\n            LogWarn(Formatter::format(message));\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogError  (const char* message) {\n        if (!DefaultLogger::isNullLogger()) {\n            LogError(Formatter::format(message));\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogInfo  (const char* message) {\n        if (!DefaultLogger::isNullLogger()) {\n            LogInfo(Formatter::format(message));\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------\n    static void LogDebug  (const char* message) {\n        if (!DefaultLogger::isNullLogger()) {\n            LogDebug(Formatter::format(message));\n        }\n    }\n\n#endif\n\nprivate:\n    static const char* Prefix();\n\n};\n} // ! Assimp\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/LogAux.h b/include/assimp/LogAux.h
--- a/include/assimp/LogAux.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/LogAux.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -43,9 +43,14 @@
 /** @file  LogAux.h
  *  @brief Common logging usage patterns for importer implementations
  */
+#pragma once
 #ifndef INCLUDED_AI_LOGAUX_H
 #define INCLUDED_AI_LOGAUX_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/TinyFormatter.h>
 #include <assimp/Exceptional.h>
 #include <assimp/DefaultLogger.hpp>
Index: include/assimp/mesh.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file mesh.h\n *  @brief Declares the data structures in which the imported geometry is\n    returned by ASSIMP: aiMesh, aiFace and aiBone data structures.\n */\n#pragma once\n#ifndef AI_MESH_H_INC\n#define AI_MESH_H_INC\n\n#include <assimp/types.h>\n#include <assimp/aabb.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ---------------------------------------------------------------------------\n// Limits. These values are required to match the settings Assimp was\n// compiled against. Therefore, do not redefine them unless you build the\n// library from source using the same definitions.\n// ---------------------------------------------------------------------------\n\n/** @def AI_MAX_FACE_INDICES\n *  Maximum number of indices per face (polygon). */\n\n#ifndef AI_MAX_FACE_INDICES\n#   define AI_MAX_FACE_INDICES 0x7fff\n#endif\n\n/** @def AI_MAX_BONE_WEIGHTS\n *  Maximum number of indices per face (polygon). */\n\n#ifndef AI_MAX_BONE_WEIGHTS\n#   define AI_MAX_BONE_WEIGHTS 0x7fffffff\n#endif\n\n/** @def AI_MAX_VERTICES\n *  Maximum number of vertices per mesh.  */\n\n#ifndef AI_MAX_VERTICES\n#   define AI_MAX_VERTICES 0x7fffffff\n#endif\n\n/** @def AI_MAX_FACES\n *  Maximum number of faces per mesh. */\n\n#ifndef AI_MAX_FACES\n#   define AI_MAX_FACES 0x7fffffff\n#endif\n\n/** @def AI_MAX_NUMBER_OF_COLOR_SETS\n *  Supported number of vertex color sets per mesh. */\n\n#ifndef AI_MAX_NUMBER_OF_COLOR_SETS\n#   define AI_MAX_NUMBER_OF_COLOR_SETS 0x8\n#endif // !! AI_MAX_NUMBER_OF_COLOR_SETS\n\n/** @def AI_MAX_NUMBER_OF_TEXTURECOORDS\n *  Supported number of texture coord sets (UV(W) channels) per mesh */\n\n#ifndef AI_MAX_NUMBER_OF_TEXTURECOORDS\n#   define AI_MAX_NUMBER_OF_TEXTURECOORDS 0x8\n#endif // !! AI_MAX_NUMBER_OF_TEXTURECOORDS\n\n// ---------------------------------------------------------------------------\n/** @brief A single face in a mesh, referring to multiple vertices.\n *\n * If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3\n * it's called 'polygon' (hey, that's just a definition!).\n * <br>\n * aiMesh::mPrimitiveTypes can be queried to quickly examine which types of\n * primitive are actually present in a mesh. The #aiProcess_SortByPType flag\n * executes a special post-processing algorithm which splits meshes with\n * *different* primitive types mixed up (e.g. lines and triangles) in several\n * 'clean' submeshes. Furthermore there is a configuration option (\n * #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove\n * specific kinds of primitives from the imported scene, completely and forever.\n * In many cases you'll probably want to set this setting to\n * @code\n * aiPrimitiveType_LINE|aiPrimitiveType_POINT\n * @endcode\n * Together with the #aiProcess_Triangulate flag you can then be sure that\n * #aiFace::mNumIndices is always 3.\n * @note Take a look at the @link data Data Structures page @endlink for\n * more information on the layout and winding order of a face.\n */\nstruct aiFace\n{\n    //! Number of indices defining this face.\n    //! The maximum value for this member is #AI_MAX_FACE_INDICES.\n    unsigned int mNumIndices;\n\n    //! Pointer to the indices array. Size of the array is given in numIndices.\n    unsigned int* mIndices;\n\n#ifdef __cplusplus\n\n    //! Default constructor\n    aiFace() AI_NO_EXCEPT\n    : mNumIndices( 0 )\n    , mIndices( nullptr ) {\n        // empty\n    }\n\n    //! Default destructor. Delete the index array\n    ~aiFace()\n    {\n        delete [] mIndices;\n    }\n\n    //! Copy constructor. Copy the index array\n    aiFace( const aiFace& o)\n    : mNumIndices(0)\n    , mIndices( nullptr ) {\n        *this = o;\n    }\n\n    //! Assignment operator. Copy the index array\n    aiFace& operator = ( const aiFace& o) {\n        if (&o == this) {\n            return *this;\n        }\n\n        delete[] mIndices;\n        mNumIndices = o.mNumIndices;\n        if (mNumIndices) {\n            mIndices = new unsigned int[mNumIndices];\n            ::memcpy( mIndices, o.mIndices, mNumIndices * sizeof( unsigned int));\n        } else {\n            mIndices = nullptr;\n        }\n\n        return *this;\n    }\n\n    //! Comparison operator. Checks whether the index array\n    //! of two faces is identical\n    bool operator== (const aiFace& o) const {\n        if (mIndices == o.mIndices) {\n            return true;\n        }\n\n        if (nullptr != mIndices && mNumIndices != o.mNumIndices) {\n            return false;\n        }\n\n        if (nullptr == mIndices) {\n            return false;\n        }\n\n        for (unsigned int i = 0; i < this->mNumIndices; ++i) {\n            if (mIndices[i] != o.mIndices[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    //! Inverse comparison operator. Checks whether the index\n    //! array of two faces is NOT identical\n    bool operator != (const aiFace& o) const {\n        return !(*this == o);\n    }\n#endif // __cplusplus\n}; // struct aiFace\n\n\n// ---------------------------------------------------------------------------\n/** @brief A single influence of a bone on a vertex.\n */\nstruct aiVertexWeight {\n    //! Index of the vertex which is influenced by the bone.\n    unsigned int mVertexId;\n\n    //! The strength of the influence in the range (0...1).\n    //! The influence from all bones at one vertex amounts to 1.\n    float mWeight;\n\n#ifdef __cplusplus\n\n    //! Default constructor\n    aiVertexWeight() AI_NO_EXCEPT\n    : mVertexId(0)\n    , mWeight(0.0f) {\n        // empty\n    }\n\n    //! Initialization from a given index and vertex weight factor\n    //! \\param pID ID\n    //! \\param pWeight Vertex weight factor\n    aiVertexWeight( unsigned int pID, float pWeight )\n    : mVertexId( pID )\n    , mWeight( pWeight ) {\n        // empty\n    }\n\n    bool operator == ( const aiVertexWeight &rhs ) const {\n        return ( mVertexId == rhs.mVertexId && mWeight == rhs.mWeight );\n    }\n\n    bool operator != ( const aiVertexWeight &rhs ) const {\n        return ( *this == rhs );\n    }\n\n#endif // __cplusplus\n};\n\n\n// ---------------------------------------------------------------------------\n/** @brief A single bone of a mesh.\n *\n *  A bone has a name by which it can be found in the frame hierarchy and by\n *  which it can be addressed by animations. In addition it has a number of\n *  influences on vertices, and a matrix relating the mesh position to the\n *  position of the bone at the time of binding.\n */\nstruct aiBone {\n    //! The name of the bone.\n    C_STRUCT aiString mName;\n\n    //! The number of vertices affected by this bone.\n    //! The maximum value for this member is #AI_MAX_BONE_WEIGHTS.\n    unsigned int mNumWeights;\n\n    //! The influence weights of this bone, by vertex index.\n    C_STRUCT aiVertexWeight* mWeights;\n\n    /** Matrix that transforms from bone space to mesh space in bind pose.\n     *\n     * This matrix describes the position of the mesh\n     * in the local space of this bone when the skeleton was bound.\n     * Thus it can be used directly to determine a desired vertex position,\n     * given the world-space transform of the bone when animated,\n     * and the position of the vertex in mesh space.\n     *\n     * It is sometimes called an inverse-bind matrix,\n     * or inverse bind pose matrix.\n     */\n    C_STRUCT aiMatrix4x4 mOffsetMatrix;\n\n#ifdef __cplusplus\n\n    //! Default constructor\n    aiBone() AI_NO_EXCEPT\n    : mName()\n    , mNumWeights( 0 )\n    , mWeights( nullptr )\n    , mOffsetMatrix() {\n        // empty\n    }\n\n    //! Copy constructor\n    aiBone(const aiBone& other)\n    : mName( other.mName )\n    , mNumWeights( other.mNumWeights )\n    , mWeights(nullptr)\n    , mOffsetMatrix( other.mOffsetMatrix ) {\n        if (other.mWeights && other.mNumWeights) {\n            mWeights = new aiVertexWeight[mNumWeights];\n            ::memcpy(mWeights,other.mWeights,mNumWeights * sizeof(aiVertexWeight));\n        }\n    }\n\n\n    //! Assignment operator\n    aiBone &operator=(const aiBone& other) {\n        if (this == &other) {\n            return *this;\n        }\n\n        mName         = other.mName;\n        mNumWeights   = other.mNumWeights;\n        mOffsetMatrix = other.mOffsetMatrix;\n\n        if (other.mWeights && other.mNumWeights)\n        {\n            if (mWeights) {\n                delete[] mWeights;\n            }\n\n            mWeights = new aiVertexWeight[mNumWeights];\n            ::memcpy(mWeights,other.mWeights,mNumWeights * sizeof(aiVertexWeight));\n        }\n\n        return *this;\n    }\n\n    bool operator == ( const aiBone &rhs ) const {\n        if ( mName != rhs.mName || mNumWeights != rhs.mNumWeights ) {\n            return false;\n        }\n\n        for ( size_t i = 0; i < mNumWeights; ++i ) {\n            if ( mWeights[ i ] != rhs.mWeights[ i ] ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    //! Destructor - deletes the array of vertex weights\n    ~aiBone() {\n        delete [] mWeights;\n    }\n#endif // __cplusplus\n};\n\n\n// ---------------------------------------------------------------------------\n/** @brief Enumerates the types of geometric primitives supported by Assimp.\n *\n *  @see aiFace Face data structure\n *  @see aiProcess_SortByPType Per-primitive sorting of meshes\n *  @see aiProcess_Triangulate Automatic triangulation\n *  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.\n */\nenum aiPrimitiveType\n{\n    /** A point primitive.\n     *\n     * This is just a single vertex in the virtual world,\n     * #aiFace contains just one index for such a primitive.\n     */\n    aiPrimitiveType_POINT       = 0x1,\n\n    /** A line primitive.\n     *\n     * This is a line defined through a start and an end position.\n     * #aiFace contains exactly two indices for such a primitive.\n     */\n    aiPrimitiveType_LINE        = 0x2,\n\n    /** A triangular primitive.\n     *\n     * A triangle consists of three indices.\n     */\n    aiPrimitiveType_TRIANGLE    = 0x4,\n\n    /** A higher-level polygon with more than 3 edges.\n     *\n     * A triangle is a polygon, but polygon in this context means\n     * \"all polygons that are not triangles\". The \"Triangulate\"-Step\n     * is provided for your convenience, it splits all polygons in\n     * triangles (which are much easier to handle).\n     */\n    aiPrimitiveType_POLYGON     = 0x8,\n\n\n    /** This value is not used. It is just here to force the\n     *  compiler to map this enum to a 32 Bit integer.\n     */\n#ifndef SWIG\n    _aiPrimitiveType_Force32Bit = INT_MAX\n#endif\n}; //! enum aiPrimitiveType\n\n// Get the #aiPrimitiveType flag for a specific number of face indices\n#define AI_PRIMITIVE_TYPE_FOR_N_INDICES(n) \\\n    ((n) > 3 ? aiPrimitiveType_POLYGON : (aiPrimitiveType)(1u << ((n)-1)))\n\n\n\n// ---------------------------------------------------------------------------\n/** @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex\n *  animations for a particular frame.\n *\n *  You may think of an #aiAnimMesh as a `patch` for the host mesh, which\n *  replaces only certain vertex data streams at a particular time.\n *  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).\n *  The actual relationship between the time line and anim meshes is\n *  established by #aiMeshAnim, which references singular mesh attachments\n *  by their ID and binds them to a time offset.\n*/\nstruct aiAnimMesh\n{\n    /**Anim Mesh name */\n    C_STRUCT aiString mName;\n\n    /** Replacement for aiMesh::mVertices. If this array is non-NULL,\n     *  it *must* contain mNumVertices entries. The corresponding\n     *  array in the host mesh must be non-NULL as well - animation\n     *  meshes may neither add or nor remove vertex components (if\n     *  a replacement array is NULL and the corresponding source\n     *  array is not, the source data is taken instead)*/\n    C_STRUCT aiVector3D* mVertices;\n\n    /** Replacement for aiMesh::mNormals.  */\n    C_STRUCT aiVector3D* mNormals;\n\n    /** Replacement for aiMesh::mTangents. */\n    C_STRUCT aiVector3D* mTangents;\n\n    /** Replacement for aiMesh::mBitangents. */\n    C_STRUCT aiVector3D* mBitangents;\n\n    /** Replacement for aiMesh::mColors */\n    C_STRUCT aiColor4D* mColors[AI_MAX_NUMBER_OF_COLOR_SETS];\n\n    /** Replacement for aiMesh::mTextureCoords */\n    C_STRUCT aiVector3D* mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n\n    /** The number of vertices in the aiAnimMesh, and thus the length of all\n     * the member arrays.\n     *\n     * This has always the same value as the mNumVertices property in the\n     * corresponding aiMesh. It is duplicated here merely to make the length\n     * of the member arrays accessible even if the aiMesh is not known, e.g.\n     * from language bindings.\n     */\n    unsigned int mNumVertices;\n    \n    /** \n     * Weight of the AnimMesh. \n     */\n    float mWeight;\n\n#ifdef __cplusplus\n\n    aiAnimMesh() AI_NO_EXCEPT\n        : mVertices( nullptr )\n        , mNormals(nullptr)\n        , mTangents(nullptr)\n        , mBitangents(nullptr)\n        , mColors()\n        , mTextureCoords()\n        , mNumVertices( 0 )\n        , mWeight( 0.0f )\n    {\n        // fixme consider moving this to the ctor initializer list as well\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++){\n            mTextureCoords[a] = nullptr;\n        }\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; a++) {\n            mColors[a] = nullptr;\n        }\n    }\n\n    ~aiAnimMesh()\n    {\n        delete [] mVertices;\n        delete [] mNormals;\n        delete [] mTangents;\n        delete [] mBitangents;\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++) {\n            delete [] mTextureCoords[a];\n        }\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; a++) {\n            delete [] mColors[a];\n        }\n    }\n\n    /** Check whether the anim mesh overrides the vertex positions\n     *  of its host mesh*/\n    bool HasPositions() const {\n        return mVertices != nullptr;\n    }\n\n    /** Check whether the anim mesh overrides the vertex normals\n     *  of its host mesh*/\n    bool HasNormals() const {\n        return mNormals != nullptr;\n    }\n\n    /** Check whether the anim mesh overrides the vertex tangents\n     *  and bitangents of its host mesh. As for aiMesh,\n     *  tangents and bitangents always go together. */\n    bool HasTangentsAndBitangents() const {\n        return mTangents != nullptr;\n    }\n\n    /** Check whether the anim mesh overrides a particular\n     * set of vertex colors on his host mesh.\n     *  @param pIndex 0<index<AI_MAX_NUMBER_OF_COLOR_SETS */\n    bool HasVertexColors( unsigned int pIndex) const    {\n        return pIndex >= AI_MAX_NUMBER_OF_COLOR_SETS ? false : mColors[pIndex] != nullptr;\n    }\n\n    /** Check whether the anim mesh overrides a particular\n     * set of texture coordinates on his host mesh.\n     *  @param pIndex 0<index<AI_MAX_NUMBER_OF_TEXTURECOORDS */\n    bool HasTextureCoords( unsigned int pIndex) const   {\n        return pIndex >= AI_MAX_NUMBER_OF_TEXTURECOORDS ? false : mTextureCoords[pIndex] != nullptr;\n    }\n\n#endif\n};\n\n// ---------------------------------------------------------------------------\n/** @brief Enumerates the methods of mesh morphing supported by Assimp.\n */\nenum aiMorphingMethod\n{\n    /** Interpolation between morph targets */\n    aiMorphingMethod_VERTEX_BLEND       = 0x1,\n\n    /** Normalized morphing between morph targets  */\n    aiMorphingMethod_MORPH_NORMALIZED   = 0x2,\n\n    /** Relative morphing between morph targets  */\n    aiMorphingMethod_MORPH_RELATIVE     = 0x3,\n\n    /** This value is not used. It is just here to force the\n     *  compiler to map this enum to a 32 Bit integer.\n     */\n#ifndef SWIG\n    _aiMorphingMethod_Force32Bit = INT_MAX\n#endif\n}; //! enum aiMorphingMethod\n\n// ---------------------------------------------------------------------------\n/** @brief A mesh represents a geometry or model with a single material.\n*\n* It usually consists of a number of vertices and a series of primitives/faces\n* referencing the vertices. In addition there might be a series of bones, each\n* of them addressing a number of vertices with a certain weight. Vertex data\n* is presented in channels with each channel containing a single per-vertex\n* information such as a set of texture coords or a normal vector.\n* If a data pointer is non-null, the corresponding data stream is present.\n* From C++-programs you can also use the comfort functions Has*() to\n* test for the presence of various data streams.\n*\n* A Mesh uses only a single material which is referenced by a material ID.\n* @note The mPositions member is usually not optional. However, vertex positions\n* *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in\n* @code\n* aiScene::mFlags\n* @endcode\n*/\nstruct aiMesh\n{\n    /** Bitwise combination of the members of the #aiPrimitiveType enum.\n     * This specifies which types of primitives are present in the mesh.\n     * The \"SortByPrimitiveType\"-Step can be used to make sure the\n     * output meshes consist of one primitive type each.\n     */\n    unsigned int mPrimitiveTypes;\n\n    /** The number of vertices in this mesh.\n    * This is also the size of all of the per-vertex data arrays.\n    * The maximum value for this member is #AI_MAX_VERTICES.\n    */\n    unsigned int mNumVertices;\n\n    /** The number of primitives (triangles, polygons, lines) in this  mesh.\n    * This is also the size of the mFaces array.\n    * The maximum value for this member is #AI_MAX_FACES.\n    */\n    unsigned int mNumFaces;\n\n    /** Vertex positions.\n    * This array is always present in a mesh. The array is\n    * mNumVertices in size.\n    */\n    C_STRUCT aiVector3D* mVertices;\n\n    /** Vertex normals.\n    * The array contains normalized vectors, NULL if not present.\n    * The array is mNumVertices in size. Normals are undefined for\n    * point and line primitives. A mesh consisting of points and\n    * lines only may not have normal vectors. Meshes with mixed\n    * primitive types (i.e. lines and triangles) may have normals,\n    * but the normals for vertices that are only referenced by\n    * point or line primitives are undefined and set to QNaN (WARN:\n    * qNaN compares to inequal to *everything*, even to qNaN itself.\n    * Using code like this to check whether a field is qnan is:\n    * @code\n    * #define IS_QNAN(f) (f != f)\n    * @endcode\n    * still dangerous because even 1.f == 1.f could evaluate to false! (\n    * remember the subtleties of IEEE754 artithmetics). Use stuff like\n    * @c fpclassify instead.\n    * @note Normal vectors computed by Assimp are always unit-length.\n    * However, this needn't apply for normals that have been taken\n    *   directly from the model file.\n    */\n    C_STRUCT aiVector3D* mNormals;\n\n    /** Vertex tangents.\n    * The tangent of a vertex points in the direction of the positive\n    * X texture axis. The array contains normalized vectors, NULL if\n    * not present. The array is mNumVertices in size. A mesh consisting\n    * of points and lines only may not have normal vectors. Meshes with\n    * mixed primitive types (i.e. lines and triangles) may have\n    * normals, but the normals for vertices that are only referenced by\n    * point or line primitives are undefined and set to qNaN.  See\n    * the #mNormals member for a detailed discussion of qNaNs.\n    * @note If the mesh contains tangents, it automatically also\n    * contains bitangents.\n    */\n    C_STRUCT aiVector3D* mTangents;\n\n    /** Vertex bitangents.\n    * The bitangent of a vertex points in the direction of the positive\n    * Y texture axis. The array contains normalized vectors, NULL if not\n    * present. The array is mNumVertices in size.\n    * @note If the mesh contains tangents, it automatically also contains\n    * bitangents.\n    */\n    C_STRUCT aiVector3D* mBitangents;\n\n    /** Vertex color sets.\n    * A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex\n    * colors per vertex. NULL if not present. Each array is\n    * mNumVertices in size if present.\n    */\n    C_STRUCT aiColor4D* mColors[AI_MAX_NUMBER_OF_COLOR_SETS];\n\n    /** Vertex texture coords, also known as UV channels.\n    * A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS per\n    * vertex. NULL if not present. The array is mNumVertices in size.\n    */\n    C_STRUCT aiVector3D* mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n\n    /** Specifies the number of components for a given UV channel.\n    * Up to three channels are supported (UVW, for accessing volume\n    * or cube maps). If the value is 2 for a given channel n, the\n    * component p.z of mTextureCoords[n][p] is set to 0.0f.\n    * If the value is 1 for a given channel, p.y is set to 0.0f, too.\n    * @note 4D coords are not supported\n    */\n    unsigned int mNumUVComponents[AI_MAX_NUMBER_OF_TEXTURECOORDS];\n\n    /** The faces the mesh is constructed from.\n    * Each face refers to a number of vertices by their indices.\n    * This array is always present in a mesh, its size is given\n    * in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT\n    * is NOT set each face references an unique set of vertices.\n    */\n    C_STRUCT aiFace* mFaces;\n\n    /** The number of bones this mesh contains.\n    * Can be 0, in which case the mBones array is NULL.\n    */\n    unsigned int mNumBones;\n\n    /** The bones of this mesh.\n    * A bone consists of a name by which it can be found in the\n    * frame hierarchy and a set of vertex weights.\n    */\n    C_STRUCT aiBone** mBones;\n\n    /** The material used by this mesh.\n     * A mesh uses only a single material. If an imported model uses\n     * multiple materials, the import splits up the mesh. Use this value\n     * as index into the scene's material list.\n     */\n    unsigned int mMaterialIndex;\n\n    /** Name of the mesh. Meshes can be named, but this is not a\n     *  requirement and leaving this field empty is totally fine.\n     *  There are mainly three uses for mesh names:\n     *   - some formats name nodes and meshes independently.\n     *   - importers tend to split meshes up to meet the\n     *      one-material-per-mesh requirement. Assigning\n     *      the same (dummy) name to each of the result meshes\n     *      aids the caller at recovering the original mesh\n     *      partitioning.\n     *   - Vertex animations refer to meshes by their names.\n     **/\n    C_STRUCT aiString mName;\n\n\n    /** The number of attachment meshes. Note! Currently only works with Collada loader. */\n    unsigned int mNumAnimMeshes;\n\n    /** Attachment meshes for this mesh, for vertex-based animation.\n     *  Attachment meshes carry replacement data for some of the\n     *  mesh'es vertex components (usually positions, normals).\n     *  Note! Currently only works with Collada loader.*/\n    C_STRUCT aiAnimMesh** mAnimMeshes;\n\n    /** \n     *  Method of morphing when animeshes are specified. \n     */\n    unsigned int mMethod;\n\n    /**\n     *\n     */\n    C_STRUCT aiAABB mAABB;\n\t\n#ifdef __cplusplus\n\n    //! Default constructor. Initializes all members to 0\n    aiMesh() AI_NO_EXCEPT\n    : mPrimitiveTypes( 0 )\n    , mNumVertices( 0 )\n    , mNumFaces( 0 )\n    , mVertices( nullptr )\n    , mNormals(nullptr)\n    , mTangents(nullptr)\n    , mBitangents(nullptr)\n    , mColors()\n    , mTextureCoords()\n    , mNumUVComponents()\n    , mFaces(nullptr)\n    , mNumBones( 0 )\n    , mBones(nullptr)\n    , mMaterialIndex( 0 )\n    , mNumAnimMeshes( 0 )\n    , mAnimMeshes(nullptr)\n    , mMethod( 0 )\n    , mAABB() {\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++a ) {\n            mNumUVComponents[a] = 0;\n            mTextureCoords[a] = nullptr;\n        }\n\n        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; ++a) {\n            mColors[a] = nullptr;\n        }\n    }\n\n    //! Deletes all storage allocated for the mesh\n    ~aiMesh() {\n        delete [] mVertices;\n        delete [] mNormals;\n        delete [] mTangents;\n        delete [] mBitangents;\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++) {\n            delete [] mTextureCoords[a];\n        }\n        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; a++) {\n            delete [] mColors[a];\n        }\n\n        // DO NOT REMOVE THIS ADDITIONAL CHECK\n        if (mNumBones && mBones)    {\n            for( unsigned int a = 0; a < mNumBones; a++) {\n                delete mBones[a];\n            }\n            delete [] mBones;\n        }\n\n        if (mNumAnimMeshes && mAnimMeshes)  {\n            for( unsigned int a = 0; a < mNumAnimMeshes; a++) {\n                delete mAnimMeshes[a];\n            }\n            delete [] mAnimMeshes;\n        }\n\n        delete [] mFaces;\n    }\n\n    //! Check whether the mesh contains positions. Provided no special\n    //! scene flags are set, this will always be true\n    bool HasPositions() const\n        { return mVertices != nullptr && mNumVertices > 0; }\n\n    //! Check whether the mesh contains faces. If no special scene flags\n    //! are set this should always return true\n    bool HasFaces() const\n        { return mFaces != nullptr && mNumFaces > 0; }\n\n    //! Check whether the mesh contains normal vectors\n    bool HasNormals() const\n        { return mNormals != nullptr && mNumVertices > 0; }\n\n    //! Check whether the mesh contains tangent and bitangent vectors\n    //! It is not possible that it contains tangents and no bitangents\n    //! (or the other way round). The existence of one of them\n    //! implies that the second is there, too.\n    bool HasTangentsAndBitangents() const\n        { return mTangents != nullptr && mBitangents != nullptr && mNumVertices > 0; }\n\n    //! Check whether the mesh contains a vertex color set\n    //! \\param pIndex Index of the vertex color set\n    bool HasVertexColors( unsigned int pIndex) const {\n        if (pIndex >= AI_MAX_NUMBER_OF_COLOR_SETS) {\n            return false;\n        } else {\n            return mColors[pIndex] != nullptr && mNumVertices > 0;\n        }\n    }\n\n    //! Check whether the mesh contains a texture coordinate set\n    //! \\param pIndex Index of the texture coordinates set\n    bool HasTextureCoords( unsigned int pIndex) const {\n        if (pIndex >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {\n            return false;\n        } else {\n            return mTextureCoords[pIndex] != nullptr && mNumVertices > 0;\n        }\n    }\n\n    //! Get the number of UV channels the mesh contains\n    unsigned int GetNumUVChannels() const {\n        unsigned int n( 0 );\n        while (n < AI_MAX_NUMBER_OF_TEXTURECOORDS && mTextureCoords[n]) {\n            ++n;\n        }\n\n        return n;\n    }\n\n    //! Get the number of vertex color channels the mesh contains\n    unsigned int GetNumColorChannels() const {\n        unsigned int n(0);\n        while (n < AI_MAX_NUMBER_OF_COLOR_SETS && mColors[n]) {\n            ++n;\n        }\n        return n;\n    }\n\n    //! Check whether the mesh contains bones\n    bool HasBones() const {\n        return mBones != nullptr && mNumBones > 0;\n    }\n\n#endif // __cplusplus\n};\n\n#ifdef __cplusplus\n}\n#endif //! extern \"C\"\n#endif // AI_MESH_H_INC\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/mesh.h b/include/assimp/mesh.h
--- a/include/assimp/mesh.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/mesh.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -48,6 +48,10 @@
 #ifndef AI_MESH_H_INC
 #define AI_MESH_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/types.h>
 #include <assimp/aabb.h>
 
@@ -248,6 +252,9 @@
 };
 
 
+// Forward declare aiNode (pointer use only)
+struct aiNode;
+
 // ---------------------------------------------------------------------------
 /** @brief A single bone of a mesh.
  *
@@ -264,6 +271,16 @@
     //! The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
     unsigned int mNumWeights;
 
+#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
+    // The bone armature node - used for skeleton conversion
+    // you must enable aiProcess_PopulateArmatureData to populate this
+    C_STRUCT aiNode* mArmature;
+
+    // The bone node in the scene - used for skeleton conversion
+    // you must enable aiProcess_PopulateArmatureData to populate this
+    C_STRUCT aiNode* mNode;
+
+#endif
     //! The influence weights of this bone, by vertex index.
     C_STRUCT aiVertexWeight* mWeights;
 
@@ -418,11 +435,11 @@
     /**Anim Mesh name */
     C_STRUCT aiString mName;
 
-    /** Replacement for aiMesh::mVertices. If this array is non-NULL,
+    /** Replacement for aiMesh::mVertices. If this array is non-nullptr,
      *  it *must* contain mNumVertices entries. The corresponding
-     *  array in the host mesh must be non-NULL as well - animation
+     *  array in the host mesh must be non-nullptr as well - animation
      *  meshes may neither add or nor remove vertex components (if
-     *  a replacement array is NULL and the corresponding source
+     *  a replacement array is nullptr and the corresponding source
      *  array is not, the source data is taken instead)*/
     C_STRUCT aiVector3D* mVertices;
 
@@ -596,7 +613,7 @@
     C_STRUCT aiVector3D* mVertices;
 
     /** Vertex normals.
-    * The array contains normalized vectors, NULL if not present.
+    * The array contains normalized vectors, nullptr if not present.
     * The array is mNumVertices in size. Normals are undefined for
     * point and line primitives. A mesh consisting of points and
     * lines only may not have normal vectors. Meshes with mixed
@@ -619,7 +636,7 @@
 
     /** Vertex tangents.
     * The tangent of a vertex points in the direction of the positive
-    * X texture axis. The array contains normalized vectors, NULL if
+    * X texture axis. The array contains normalized vectors, nullptr if
     * not present. The array is mNumVertices in size. A mesh consisting
     * of points and lines only may not have normal vectors. Meshes with
     * mixed primitive types (i.e. lines and triangles) may have
@@ -633,7 +650,7 @@
 
     /** Vertex bitangents.
     * The bitangent of a vertex points in the direction of the positive
-    * Y texture axis. The array contains normalized vectors, NULL if not
+    * Y texture axis. The array contains normalized vectors, nullptr if not
     * present. The array is mNumVertices in size.
     * @note If the mesh contains tangents, it automatically also contains
     * bitangents.
@@ -642,14 +659,14 @@
 
     /** Vertex color sets.
     * A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex
-    * colors per vertex. NULL if not present. Each array is
+    * colors per vertex. nullptr if not present. Each array is
     * mNumVertices in size if present.
     */
     C_STRUCT aiColor4D* mColors[AI_MAX_NUMBER_OF_COLOR_SETS];
 
     /** Vertex texture coords, also known as UV channels.
     * A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS per
-    * vertex. NULL if not present. The array is mNumVertices in size.
+    * vertex. nullptr if not present. The array is mNumVertices in size.
     */
     C_STRUCT aiVector3D* mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];
 
@@ -671,7 +688,7 @@
     C_STRUCT aiFace* mFaces;
 
     /** The number of bones this mesh contains.
-    * Can be 0, in which case the mBones array is NULL.
+    * Can be 0, in which case the mBones array is nullptr.
     */
     unsigned int mNumBones;
 
@@ -769,7 +786,10 @@
         // DO NOT REMOVE THIS ADDITIONAL CHECK
         if (mNumBones && mBones)    {
             for( unsigned int a = 0; a < mNumBones; a++) {
-                delete mBones[a];
+                if(mBones[a])
+                {
+                    delete mBones[a];
+                }
             }
             delete [] mBones;
         }
Index: include/assimp/Bitmap.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Bitmap.h\n *  @brief Defines bitmap format helper for textures\n *\n * Used for file formats which embed their textures into the model file.\n */\n\n#ifndef AI_BITMAP_H_INC\n#define AI_BITMAP_H_INC\n\n#include \"defs.h\"\n#include <stdint.h>\n#include <cstddef>\n\nstruct aiTexture;\n\nnamespace Assimp {\n\nclass IOStream;\n\nclass ASSIMP_API Bitmap {\nprotected:\n\n    struct Header {\n        uint16_t type;\n        uint32_t size;\n        uint16_t reserved1;\n        uint16_t reserved2;\n        uint32_t offset;\n\n        // We define the struct size because sizeof(Header) might return a wrong result because of structure padding.\n        // Moreover, we must use this ugly and error prone syntax because Visual Studio neither support constexpr or sizeof(name_of_field).\n        static const std::size_t header_size =\n            sizeof(uint16_t) + // type\n            sizeof(uint32_t) + // size\n            sizeof(uint16_t) + // reserved1\n            sizeof(uint16_t) + // reserved2\n            sizeof(uint32_t);  // offset\n    };\n\n    struct DIB {\n        uint32_t size;\n        int32_t width;\n        int32_t height;\n        uint16_t planes;\n        uint16_t bits_per_pixel;\n        uint32_t compression;\n        uint32_t image_size;\n        int32_t x_resolution;\n        int32_t y_resolution;\n        uint32_t nb_colors;\n        uint32_t nb_important_colors;\n\n        // We define the struct size because sizeof(DIB) might return a wrong result because of structure padding.\n        // Moreover, we must use this ugly and error prone syntax because Visual Studio neither support constexpr or sizeof(name_of_field).\n        static const std::size_t dib_size =\n            sizeof(uint32_t) + // size\n            sizeof(int32_t) +  // width\n            sizeof(int32_t) +  // height\n            sizeof(uint16_t) + // planes\n            sizeof(uint16_t) + // bits_per_pixel\n            sizeof(uint32_t) + // compression\n            sizeof(uint32_t) + // image_size\n            sizeof(int32_t) +  // x_resolution\n            sizeof(int32_t) +  // y_resolution\n            sizeof(uint32_t) + // nb_colors\n            sizeof(uint32_t);  // nb_important_colors\n    };\n\n    static const std::size_t mBytesPerPixel = 4;\n\npublic:\n    static void Save(aiTexture* texture, IOStream* file);\n\nprotected:\n    static void WriteHeader(Header& header, IOStream* file);\n    static void WriteDIB(DIB& dib, IOStream* file);\n    static void WriteData(aiTexture* texture, IOStream* file);\n};\n\n}\n\n#endif // AI_BITMAP_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/Bitmap.h b/include/assimp/Bitmap.h
--- a/include/assimp/Bitmap.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/Bitmap.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -46,10 +46,14 @@
  *
  * Used for file formats which embed their textures into the model file.
  */
-
+#pragma once
 #ifndef AI_BITMAP_H_INC
 #define AI_BITMAP_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include "defs.h"
 #include <stdint.h>
 #include <cstddef>
Index: include/assimp/ParsingUtils.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n\n/** @file ParsingUtils.h\n *  @brief Defines helper functions for text parsing\n */\n#ifndef AI_PARSING_UTILS_H_INC\n#define AI_PARSING_UTILS_H_INC\n\n#include \"StringComparison.h\"\n#include \"StringUtils.h\"\n#include <assimp/defs.h>\n\nnamespace Assimp {\n\n// NOTE: the functions below are mostly intended as replacement for\n// std::upper, std::lower, std::isupper, std::islower, std::isspace.\n// we don't bother of locales. We don't want them. We want reliable\n// (i.e. identical) results across all locales.\n\n// The functions below accept any character type, but know only\n// about ASCII. However, UTF-32 is the only safe ASCII superset to\n// use since it doesn't have multi-byte sequences.\n\nstatic const unsigned int BufferSize = 4096;\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nchar_t ToLower( char_t in ) {\n    return (in >= (char_t)'A' && in <= (char_t)'Z') ? (char_t)(in+0x20) : in;\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nchar_t ToUpper( char_t in) {\n    return (in >= (char_t)'a' && in <= (char_t)'z') ? (char_t)(in-0x20) : in;\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool IsUpper( char_t in) {\n    return (in >= (char_t)'A' && in <= (char_t)'Z');\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool IsLower( char_t in) {\n    return (in >= (char_t)'a' && in <= (char_t)'z');\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool IsSpace( char_t in) {\n    return (in == (char_t)' ' || in == (char_t)'\\t');\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool IsLineEnd( char_t in) {\n    return (in==(char_t)'\\r'||in==(char_t)'\\n'||in==(char_t)'\\0'||in==(char_t)'\\f');\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool IsSpaceOrNewLine( char_t in) {\n    return IsSpace<char_t>(in) || IsLineEnd<char_t>(in);\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipSpaces( const char_t* in, const char_t** out) {\n    while( *in == ( char_t )' ' || *in == ( char_t )'\\t' ) {\n        ++in;\n    }\n    *out = in;\n    return !IsLineEnd<char_t>(*in);\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipSpaces( const char_t** inout) {\n    return SkipSpaces<char_t>(*inout,inout);\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipLine( const char_t* in, const char_t** out) {\n    while( *in != ( char_t )'\\r' && *in != ( char_t )'\\n' && *in != ( char_t )'\\0' ) {\n        ++in;\n    }\n\n    // files are opened in binary mode. Ergo there are both NL and CR\n    while( *in == ( char_t )'\\r' || *in == ( char_t )'\\n' ) {\n        ++in;\n    }\n    *out = in;\n    return *in != (char_t)'\\0';\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipLine( const char_t** inout) {\n    return SkipLine<char_t>(*inout,inout);\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipSpacesAndLineEnd( const char_t* in, const char_t** out) {\n    while( *in == ( char_t )' ' || *in == ( char_t )'\\t' || *in == ( char_t )'\\r' || *in == ( char_t )'\\n' ) {\n        ++in;\n    }\n    *out = in;\n    return *in != '\\0';\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool SkipSpacesAndLineEnd( const char_t** inout) {\n    return SkipSpacesAndLineEnd<char_t>(*inout,inout);\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool GetNextLine( const char_t*& buffer, char_t out[ BufferSize ] ) {\n    if( ( char_t )'\\0' == *buffer ) {\n        return false;\n    }\n\n    char* _out = out;\n    char* const end = _out + BufferSize;\n    while( !IsLineEnd( *buffer ) && _out < end ) {\n        *_out++ = *buffer++;\n    }\n    *_out = (char_t)'\\0';\n\n    while( IsLineEnd( *buffer ) && '\\0' != *buffer ) {\n        ++buffer;\n    }\n\n    return true;\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE bool IsNumeric( char_t in) {\n    return ( in >= '0' && in <= '9' ) || '-' == in || '+' == in;\n}\n\n// ---------------------------------------------------------------------------------\ntemplate <class char_t>\nAI_FORCE_INLINE\nbool TokenMatch(char_t*& in, const char* token, unsigned int len)\n{\n    if (!::strncmp(token,in,len) && IsSpaceOrNewLine(in[len])) {\n        if (in[len] != '\\0') {\n            in += len+1;\n        } else {\n            // If EOF after the token make sure we don't go past end of buffer\n            in += len;\n        }\n        return true;\n    }\n\n    return false;\n}\n// ---------------------------------------------------------------------------------\n/** @brief Case-ignoring version of TokenMatch\n *  @param in Input\n *  @param token Token to check for\n *  @param len Number of characters to check\n */\nAI_FORCE_INLINE\nbool TokenMatchI(const char*& in, const char* token, unsigned int len) {\n    if (!ASSIMP_strincmp(token,in,len) && IsSpaceOrNewLine(in[len])) {\n        in += len+1;\n        return true;\n    }\n    return false;\n}\n\n// ---------------------------------------------------------------------------------\nAI_FORCE_INLINE\nvoid SkipToken(const char*& in) {\n    SkipSpaces(&in);\n    while ( !IsSpaceOrNewLine( *in ) ) {\n        ++in;\n    }\n}\n\n// ---------------------------------------------------------------------------------\nAI_FORCE_INLINE\nstd::string GetNextToken(const char*& in) {\n    SkipSpacesAndLineEnd(&in);\n    const char* cur = in;\n    while ( !IsSpaceOrNewLine( *in ) ) {\n        ++in;\n    }\n    return std::string(cur,(size_t)(in-cur));\n}\n\n// ---------------------------------------------------------------------------------\n\n} // ! namespace Assimp\n\n#endif // ! AI_PARSING_UTILS_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/ParsingUtils.h b/include/assimp/ParsingUtils.h
--- a/include/assimp/ParsingUtils.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/ParsingUtils.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -44,11 +44,16 @@
 /** @file ParsingUtils.h
  *  @brief Defines helper functions for text parsing
  */
+#pragma once
 #ifndef AI_PARSING_UTILS_H_INC
 #define AI_PARSING_UTILS_H_INC
 
-#include "StringComparison.h"
-#include "StringUtils.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/StringComparison.h>
+#include <assimp/StringUtils.h>
 #include <assimp/defs.h>
 
 namespace Assimp {
Index: include/assimp/quaternion.inl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  quaternion.inl\n *  @brief Inline implementation of aiQuaterniont<TReal> operators\n */\n#pragma once\n#ifndef AI_QUATERNION_INL_INC\n#define AI_QUATERNION_INL_INC\n\n#ifdef __cplusplus\n#include \"quaternion.h\"\n\n#include <cmath>\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\nbool aiQuaterniont<TReal>::operator== (const aiQuaterniont& o) const\n{\n    return x == o.x && y == o.y && z == o.z && w == o.w;\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\nbool aiQuaterniont<TReal>::operator!= (const aiQuaterniont& o) const\n{\n    return !(*this == o);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline bool aiQuaterniont<TReal>::Equal(const aiQuaterniont& o, TReal epsilon) const {\n    return\n        std::abs(x - o.x) <= epsilon &&\n        std::abs(y - o.y) <= epsilon &&\n        std::abs(z - o.z) <= epsilon &&\n        std::abs(w - o.w) <= epsilon;\n}\n\n// ---------------------------------------------------------------------------\n// Constructs a quaternion from a rotation matrix\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>::aiQuaterniont( const aiMatrix3x3t<TReal> &pRotMatrix)\n{\n    TReal t = pRotMatrix.a1 + pRotMatrix.b2 + pRotMatrix.c3;\n\n    // large enough\n    if( t > static_cast<TReal>(0))\n    {\n        TReal s = std::sqrt(1 + t) * static_cast<TReal>(2.0);\n        x = (pRotMatrix.c2 - pRotMatrix.b3) / s;\n        y = (pRotMatrix.a3 - pRotMatrix.c1) / s;\n        z = (pRotMatrix.b1 - pRotMatrix.a2) / s;\n        w = static_cast<TReal>(0.25) * s;\n    } // else we have to check several cases\n    else if( pRotMatrix.a1 > pRotMatrix.b2 && pRotMatrix.a1 > pRotMatrix.c3 )\n    {\n        // Column 0:\n        TReal s = std::sqrt( static_cast<TReal>(1.0) + pRotMatrix.a1 - pRotMatrix.b2 - pRotMatrix.c3) * static_cast<TReal>(2.0);\n        x = static_cast<TReal>(0.25) * s;\n        y = (pRotMatrix.b1 + pRotMatrix.a2) / s;\n        z = (pRotMatrix.a3 + pRotMatrix.c1) / s;\n        w = (pRotMatrix.c2 - pRotMatrix.b3) / s;\n    }\n    else if( pRotMatrix.b2 > pRotMatrix.c3)\n    {\n        // Column 1:\n        TReal s = std::sqrt( static_cast<TReal>(1.0) + pRotMatrix.b2 - pRotMatrix.a1 - pRotMatrix.c3) * static_cast<TReal>(2.0);\n        x = (pRotMatrix.b1 + pRotMatrix.a2) / s;\n        y = static_cast<TReal>(0.25) * s;\n        z = (pRotMatrix.c2 + pRotMatrix.b3) / s;\n        w = (pRotMatrix.a3 - pRotMatrix.c1) / s;\n    } else\n    {\n        // Column 2:\n        TReal s = std::sqrt( static_cast<TReal>(1.0) + pRotMatrix.c3 - pRotMatrix.a1 - pRotMatrix.b2) * static_cast<TReal>(2.0);\n        x = (pRotMatrix.a3 + pRotMatrix.c1) / s;\n        y = (pRotMatrix.c2 + pRotMatrix.b3) / s;\n        z = static_cast<TReal>(0.25) * s;\n        w = (pRotMatrix.b1 - pRotMatrix.a2) / s;\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Construction from euler angles\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>::aiQuaterniont( TReal fPitch, TReal fYaw, TReal fRoll )\n{\n    const TReal fSinPitch(std::sin(fPitch*static_cast<TReal>(0.5)));\n    const TReal fCosPitch(std::cos(fPitch*static_cast<TReal>(0.5)));\n    const TReal fSinYaw(std::sin(fYaw*static_cast<TReal>(0.5)));\n    const TReal fCosYaw(std::cos(fYaw*static_cast<TReal>(0.5)));\n    const TReal fSinRoll(std::sin(fRoll*static_cast<TReal>(0.5)));\n    const TReal fCosRoll(std::cos(fRoll*static_cast<TReal>(0.5)));\n    const TReal fCosPitchCosYaw(fCosPitch*fCosYaw);\n    const TReal fSinPitchSinYaw(fSinPitch*fSinYaw);\n    x = fSinRoll * fCosPitchCosYaw     - fCosRoll * fSinPitchSinYaw;\n    y = fCosRoll * fSinPitch * fCosYaw + fSinRoll * fCosPitch * fSinYaw;\n    z = fCosRoll * fCosPitch * fSinYaw - fSinRoll * fSinPitch * fCosYaw;\n    w = fCosRoll * fCosPitchCosYaw     + fSinRoll * fSinPitchSinYaw;\n}\n\n// ---------------------------------------------------------------------------\n// Returns a matrix representation of the quaternion\ntemplate<typename TReal>\ninline aiMatrix3x3t<TReal> aiQuaterniont<TReal>::GetMatrix() const\n{\n    aiMatrix3x3t<TReal> resMatrix;\n    resMatrix.a1 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (y * y + z * z);\n    resMatrix.a2 = static_cast<TReal>(2.0) * (x * y - z * w);\n    resMatrix.a3 = static_cast<TReal>(2.0) * (x * z + y * w);\n    resMatrix.b1 = static_cast<TReal>(2.0) * (x * y + z * w);\n    resMatrix.b2 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (x * x + z * z);\n    resMatrix.b3 = static_cast<TReal>(2.0) * (y * z - x * w);\n    resMatrix.c1 = static_cast<TReal>(2.0) * (x * z - y * w);\n    resMatrix.c2 = static_cast<TReal>(2.0) * (y * z + x * w);\n    resMatrix.c3 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (x * x + y * y);\n\n    return resMatrix;\n}\n\n// ---------------------------------------------------------------------------\n// Construction from an axis-angle pair\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>::aiQuaterniont( aiVector3t<TReal> axis, TReal angle)\n{\n    axis.Normalize();\n\n    const TReal sin_a = std::sin( angle / 2 );\n    const TReal cos_a = std::cos( angle / 2 );\n    x    = axis.x * sin_a;\n    y    = axis.y * sin_a;\n    z    = axis.z * sin_a;\n    w    = cos_a;\n}\n// ---------------------------------------------------------------------------\n// Construction from am existing, normalized quaternion\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>::aiQuaterniont( aiVector3t<TReal> normalized)\n{\n    x = normalized.x;\n    y = normalized.y;\n    z = normalized.z;\n\n    const TReal t = static_cast<TReal>(1.0) - (x*x) - (y*y) - (z*z);\n\n    if (t < static_cast<TReal>(0.0)) {\n        w = static_cast<TReal>(0.0);\n    }\n    else w = std::sqrt (t);\n}\n\n// ---------------------------------------------------------------------------\n// Performs a spherical interpolation between two quaternions\n// Implementation adopted from the gmtl project. All others I found on the net fail in some cases.\n// Congrats, gmtl!\ntemplate<typename TReal>\ninline void aiQuaterniont<TReal>::Interpolate( aiQuaterniont& pOut, const aiQuaterniont& pStart, const aiQuaterniont& pEnd, TReal pFactor)\n{\n    // calc cosine theta\n    TReal cosom = pStart.x * pEnd.x + pStart.y * pEnd.y + pStart.z * pEnd.z + pStart.w * pEnd.w;\n\n    // adjust signs (if necessary)\n    aiQuaterniont end = pEnd;\n    if( cosom < static_cast<TReal>(0.0))\n    {\n        cosom = -cosom;\n        end.x = -end.x;   // Reverse all signs\n        end.y = -end.y;\n        end.z = -end.z;\n        end.w = -end.w;\n    }\n\n    // Calculate coefficients\n    TReal sclp, sclq;\n    if( (static_cast<TReal>(1.0) - cosom) > static_cast<TReal>(0.0001)) // 0.0001 -> some epsillon\n    {\n        // Standard case (slerp)\n        TReal omega, sinom;\n        omega = std::acos( cosom); // extract theta from dot product's cos theta\n        sinom = std::sin( omega);\n        sclp  = std::sin( (static_cast<TReal>(1.0) - pFactor) * omega) / sinom;\n        sclq  = std::sin( pFactor * omega) / sinom;\n    } else\n    {\n        // Very close, do linear interp (because it's faster)\n        sclp = static_cast<TReal>(1.0) - pFactor;\n        sclq = pFactor;\n    }\n\n    pOut.x = sclp * pStart.x + sclq * end.x;\n    pOut.y = sclp * pStart.y + sclq * end.y;\n    pOut.z = sclp * pStart.z + sclq * end.z;\n    pOut.w = sclp * pStart.w + sclq * end.w;\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>& aiQuaterniont<TReal>::Normalize()\n{\n    // compute the magnitude and divide through it\n    const TReal mag = std::sqrt(x*x + y*y + z*z + w*w);\n    if (mag)\n    {\n        const TReal invMag = static_cast<TReal>(1.0)/mag;\n        x *= invMag;\n        y *= invMag;\n        z *= invMag;\n        w *= invMag;\n    }\n    return *this;\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline aiQuaterniont<TReal> aiQuaterniont<TReal>::operator* (const aiQuaterniont& t) const\n{\n    return aiQuaterniont(w*t.w - x*t.x - y*t.y - z*t.z,\n        w*t.x + x*t.w + y*t.z - z*t.y,\n        w*t.y + y*t.w + z*t.x - x*t.z,\n        w*t.z + z*t.w + x*t.y - y*t.x);\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline aiQuaterniont<TReal>& aiQuaterniont<TReal>::Conjugate ()\n{\n    x = -x;\n    y = -y;\n    z = -z;\n    return *this;\n}\n\n// ---------------------------------------------------------------------------\ntemplate<typename TReal>\ninline aiVector3t<TReal> aiQuaterniont<TReal>::Rotate (const aiVector3t<TReal>& v)\n{\n    aiQuaterniont q2(0.f,v.x,v.y,v.z), q = *this, qinv = q;\n    qinv.Conjugate();\n\n    q = q*q2*qinv;\n    return aiVector3t<TReal>(q.x,q.y,q.z);\n}\n\n#endif\n#endif // AI_QUATERNION_INL_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/quaternion.inl b/include/assimp/quaternion.inl
--- a/include/assimp/quaternion.inl	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/quaternion.inl	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,8 +48,12 @@
 #ifndef AI_QUATERNION_INL_INC
 #define AI_QUATERNION_INL_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #ifdef __cplusplus
-#include "quaternion.h"
+#include <assimp/quaternion.h>
 
 #include <cmath>
 
Index: include/assimp/texture.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file texture.h\n *  @brief Defines texture helper structures for the library\n *\n * Used for file formats which embed their textures into the model file.\n * Supported are both normal textures, which are stored as uncompressed\n * pixels, and \"compressed\" textures, which are stored in a file format\n * such as PNG or TGA.\n */\n#pragma once\n#ifndef AI_TEXTURE_H_INC\n#define AI_TEXTURE_H_INC\n\n#include \"types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// --------------------------------------------------------------------------------\n\n/** \\def AI_EMBEDDED_TEXNAME_PREFIX\n * \\ref AI_MAKE_EMBEDDED_TEXNAME\n */\n#ifndef AI_EMBEDDED_TEXNAME_PREFIX\n#   define AI_EMBEDDED_TEXNAME_PREFIX\t\"*\"\n#endif\n\n/** @def AI_MAKE_EMBEDDED_TEXNAME\n *  Used to build the reserved path name used by the material system to\n *  reference textures that are embedded into their corresponding\n *  model files. The parameter specifies the index of the texture\n *  (zero-based, in the aiScene::mTextures array)\n */\n#if (!defined AI_MAKE_EMBEDDED_TEXNAME)\n#   define AI_MAKE_EMBEDDED_TEXNAME(_n_) AI_EMBEDDED_TEXNAME_PREFIX # _n_\n#endif\n\n\n#include \"./Compiler/pushpack1.h\"\n\n// --------------------------------------------------------------------------------\n/** @brief Helper structure to represent a texel in a ARGB8888 format\n*\n*  Used by aiTexture.\n*/\nstruct aiTexel\n{\n    unsigned char b,g,r,a;\n\n#ifdef __cplusplus\n    //! Comparison operator\n    bool operator== (const aiTexel& other) const\n    {\n        return b == other.b && r == other.r &&\n               g == other.g && a == other.a;\n    }\n\n    //! Inverse comparison operator\n    bool operator!= (const aiTexel& other) const\n    {\n        return b != other.b || r != other.r ||\n               g != other.g || a != other.a;\n    }\n\n    //! Conversion to a floating-point 4d color\n    operator aiColor4D() const\n    {\n        return aiColor4D(r/255.f,g/255.f,b/255.f,a/255.f);\n    }\n#endif // __cplusplus\n\n} PACK_STRUCT;\n\n#include \"./Compiler/poppack1.h\"\n\n#define HINTMAXTEXTURELEN 9\n\n// --------------------------------------------------------------------------------\n/** Helper structure to describe an embedded texture\n *\n * Normally textures are contained in external files but some file formats embed\n * them directly in the model file. There are two types of embedded textures:\n * 1. Uncompressed textures. The color data is given in an uncompressed format.\n * 2. Compressed textures stored in a file format like png or jpg. The raw file\n * bytes are given so the application must utilize an image decoder (e.g. DevIL) to\n * get access to the actual color data.\n *\n * Embedded textures are referenced from materials using strings like \"*0\", \"*1\", etc.\n * as the texture paths (a single asterisk character followed by the\n * zero-based index of the texture in the aiScene::mTextures array).\n */\nstruct aiTexture {\n    /** Width of the texture, in pixels\n     *\n     * If mHeight is zero the texture is compressed in a format\n     * like JPEG. In this case mWidth specifies the size of the\n     * memory area pcData is pointing to, in bytes.\n     */\n    unsigned int mWidth;\n\n    /** Height of the texture, in pixels\n     *\n     * If this value is zero, pcData points to an compressed texture\n     * in any format (e.g. JPEG).\n     */\n    unsigned int mHeight;\n\n    /** A hint from the loader to make it easier for applications\n     *  to determine the type of embedded textures.\n     *\n     * If mHeight != 0 this member is show how data is packed. Hint will consist of\n     * two parts: channel order and channel bitness (count of the bits for every\n     * color channel). For simple parsing by the viewer it's better to not omit\n     * absent color channel and just use 0 for bitness. For example:\n     * 1. Image contain RGBA and 8 bit per channel, achFormatHint == \"rgba8888\";\n     * 2. Image contain ARGB and 8 bit per channel, achFormatHint == \"argb8888\";\n     * 3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == \"rgba5650\";\n     * 4. One color image with B channel and 1 bit for it, achFormatHint == \"rgba0010\";\n     * If mHeight == 0 then achFormatHint is set set to '\\\\0\\\\0\\\\0\\\\0' if the loader has no additional\n     * information about the texture file format used OR the\n     * file extension of the format without a trailing dot. If there\n     * are multiple file extensions for a format, the shortest\n     * extension is chosen (JPEG maps to 'jpg', not to 'jpeg').\n     * E.g. 'dds\\\\0', 'pcx\\\\0', 'jpg\\\\0'.  All characters are lower-case.\n     * The fourth character will always be '\\\\0'.\n     */\n    char achFormatHint[ HINTMAXTEXTURELEN ];// 8 for string + 1 for terminator.\n\n    /** Data of the texture.\n     *\n     * Points to an array of mWidth * mHeight aiTexel's.\n     * The format of the texture data is always ARGB8888 to\n     * make the implementation for user of the library as easy\n     * as possible. If mHeight = 0 this is a pointer to a memory\n     * buffer of size mWidth containing the compressed texture\n     * data. Good luck, have fun!\n     */\n    C_STRUCT aiTexel* pcData;\n\n    /** Texture original filename\n    *\n    * Used to get the texture reference\n    */\n    C_STRUCT aiString mFilename;\n\n#ifdef __cplusplus\n\n    //! For compressed textures (mHeight == 0): compare the\n    //! format hint against a given string.\n    //! @param s Input string. 3 characters are maximally processed.\n    //!        Example values: \"jpg\", \"png\"\n    //! @return true if the given string matches the format hint\n    bool CheckFormat(const char* s) const {\n        if (nullptr == s) {\n            return false;\n        }\n\n\t\treturn (0 == ::strncmp(achFormatHint, s, sizeof(achFormatHint)));\n    }\n\n    // Construction\n    aiTexture() AI_NO_EXCEPT\n    : mWidth(0)\n    , mHeight(0)\n    , pcData(nullptr)\n    , mFilename() {\n        achFormatHint[0] = achFormatHint[1] = 0;\n        achFormatHint[2] = achFormatHint[3] = 0;\n    }\n\n    // Destruction\n    ~aiTexture () {\n        delete[] pcData;\n    }\n#endif\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // AI_TEXTURE_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/texture.h b/include/assimp/texture.h
--- a/include/assimp/texture.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/texture.h	(date 1617519895000)
@@ -3,9 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -53,13 +51,16 @@
 #ifndef AI_TEXTURE_H_INC
 #define AI_TEXTURE_H_INC
 
-#include "types.h"
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
+#include <assimp/types.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-
 // --------------------------------------------------------------------------------
 
 /** \def AI_EMBEDDED_TEXNAME_PREFIX
@@ -79,7 +80,6 @@
 #   define AI_MAKE_EMBEDDED_TEXNAME(_n_) AI_EMBEDDED_TEXNAME_PREFIX # _n_
 #endif
 
-
 #include "./Compiler/pushpack1.h"
 
 // --------------------------------------------------------------------------------
@@ -87,8 +87,7 @@
 *
 *  Used by aiTexture.
 */
-struct aiTexel
-{
+struct aiTexel {
     unsigned char b,g,r,a;
 
 #ifdef __cplusplus
@@ -208,8 +207,7 @@
     , mHeight(0)
     , pcData(nullptr)
     , mFilename() {
-        achFormatHint[0] = achFormatHint[1] = 0;
-        achFormatHint[2] = achFormatHint[3] = 0;
+        memset(achFormatHint, 0, sizeof(achFormatHint));
     }
 
     // Destruction
Index: ICT397-Project-Engine/GladSkybox.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"GladSkybox.h\"\n\n#include \"skybox.h\"\n#include \"stb_image.h\"\n#include <glad/glad.h>\n#include <iostream>\n\nvoid GladSkybox::Terminate()\n{\n\tglDeleteVertexArrays(1, &skyboxVAO);\n\tglDeleteBuffers(1, &skyboxVAO);\n}\n\nvoid GladSkybox::Init(std::string right, std::string left, std::string top, std::string bottom, std::string front, std::string back, std::string vertexShader, std::string fragmentShader)\n{\n\n\tglGenVertexArrays(1, &skyboxVAO);\n\tglGenBuffers(1, &skyboxVBO);\n\tglBindVertexArray(skyboxVAO);\n\tglBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);\n\tglBufferData(GL_ARRAY_BUFFER, sizeof(skyBoxVertices), &skyBoxVertices, GL_STATIC_DRAW);\n\tglEnableVertexAttribArray(0);\n\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n\n\tcubeFaces.emplace_back(right);\n\tcubeFaces.emplace_back(left);\n\tcubeFaces.emplace_back(top);\n\tcubeFaces.emplace_back(bottom);\n\tcubeFaces.emplace_back(front);\n\tcubeFaces.emplace_back(back);\n\n\n\tcubeTexture = loadCubemap(cubeFaces);\n\n\n\tShader s(vertexShader.c_str(), fragmentShader.c_str());\n\tskyShader = s;\n\tskyShader.use();\n\tskyShader.setInt(\"skybox\", 0);\n\n}\n\nunsigned int GladSkybox::loadCubemap(std::vector<std::string> faces)\n{\n\tunsigned int textureID;\n\tglGenTextures(1, &textureID);\n\tglBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\n\n\tint width, height, nrChannels;\n\tfor (unsigned int i = 0; i < faces.size(); i++) {\n\t\tunsigned char* data =\n\t\t\tstbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);\n\t\tif (data) {\n\t\t\tglTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width,\n\t\t\t\theight, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n\t\t\tstbi_image_free(data);\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Cubemap texture failed to load at path: \" << faces[i]\n\t\t\t\t<< std::endl;\n\t\t\tstbi_image_free(data);\n\t\t}\n\t}\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n\treturn textureID;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICT397-Project-Engine/GladSkybox.cpp b/ICT397-Project-Engine/GladSkybox.cpp
--- a/ICT397-Project-Engine/GladSkybox.cpp	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/ICT397-Project-Engine/GladSkybox.cpp	(date 1617529873000)
@@ -22,13 +22,21 @@
 	glEnableVertexAttribArray(0);
 	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
 
+#if _WIN32
 	cubeFaces.emplace_back(right);
 	cubeFaces.emplace_back(left);
 	cubeFaces.emplace_back(top);
 	cubeFaces.emplace_back(bottom);
 	cubeFaces.emplace_back(front);
 	cubeFaces.emplace_back(back);
-
+#else
+    cubeFaces.__emplace_back(right);
+    cubeFaces.__emplace_back(left);
+    cubeFaces.__emplace_back(top);
+    cubeFaces.__emplace_back(bottom);
+    cubeFaces.__emplace_back(front);
+    cubeFaces.__emplace_back(back);
+#endif
 
 	cubeTexture = loadCubemap(cubeFaces);
 
Index: include/assimp/importerdesc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file importerdesc.h\n *  @brief #aiImporterFlags, aiImporterDesc implementation.\n */\n#pragma once\n#ifndef AI_IMPORTER_DESC_H_INC\n#define AI_IMPORTER_DESC_H_INC\n\n\n/** Mixed set of flags for #aiImporterDesc, indicating some features\n  *  common to many importers*/\nenum aiImporterFlags\n{\n    /** Indicates that there is a textual encoding of the\n     *  file format; and that it is supported.*/\n    aiImporterFlags_SupportTextFlavour = 0x1,\n\n    /** Indicates that there is a binary encoding of the\n     *  file format; and that it is supported.*/\n    aiImporterFlags_SupportBinaryFlavour = 0x2,\n\n    /** Indicates that there is a compressed encoding of the\n     *  file format; and that it is supported.*/\n    aiImporterFlags_SupportCompressedFlavour = 0x4,\n\n    /** Indicates that the importer reads only a very particular\n      * subset of the file format. This happens commonly for\n      * declarative or procedural formats which cannot easily\n      * be mapped to #aiScene */\n    aiImporterFlags_LimitedSupport = 0x8,\n\n    /** Indicates that the importer is highly experimental and\n      * should be used with care. This only happens for trunk\n      * (i.e. SVN) versions, experimental code is not included\n      * in releases. */\n    aiImporterFlags_Experimental = 0x10\n};\n\n\n/** Meta information about a particular importer. Importers need to fill\n *  this structure, but they can freely decide how talkative they are.\n *  A common use case for loader meta info is a user interface\n *  in which the user can choose between various import/export file\n *  formats. Building such an UI by hand means a lot of maintenance\n *  as importers/exporters are added to Assimp, so it might be useful\n *  to have a common mechanism to query some rough importer\n *  characteristics. */\nstruct aiImporterDesc\n{\n    /** Full name of the importer (i.e. Blender3D importer)*/\n    const char* mName;\n\n    /** Original author (left blank if unknown or whole assimp team) */\n    const char* mAuthor;\n\n    /** Current maintainer, left blank if the author maintains */\n    const char* mMaintainer;\n\n    /** Implementation comments, i.e. unimplemented features*/\n    const char* mComments;\n\n    /** These flags indicate some characteristics common to many\n        importers. */\n    unsigned int mFlags;\n\n    /** Minimum format version that can be loaded im major.minor format,\n        both are set to 0 if there is either no version scheme\n        or if the loader doesn't care. */\n    unsigned int mMinMajor;\n    unsigned int mMinMinor;\n\n    /** Maximum format version that can be loaded im major.minor format,\n        both are set to 0 if there is either no version scheme\n        or if the loader doesn't care. Loaders that expect to be\n        forward-compatible to potential future format versions should\n        indicate  zero, otherwise they should specify the current\n        maximum version.*/\n    unsigned int mMaxMajor;\n    unsigned int mMaxMinor;\n\n    /** List of file extensions this importer can handle.\n        List entries are separated by space characters.\n        All entries are lower case without a leading dot (i.e.\n        \"xml dae\" would be a valid value. Note that multiple\n        importers may respond to the same file extension -\n        assimp calls all importers in the order in which they\n        are registered and each importer gets the opportunity\n        to load the file until one importer \"claims\" the file. Apart\n        from file extension checks, importers typically use\n        other methods to quickly reject files (i.e. magic\n        words) so this does not mean that common or generic\n        file extensions such as XML would be tediously slow. */\n    const char* mFileExtensions;\n};\n\n/** \\brief  Returns the Importer description for a given extension.\n\nWill return a NULL-pointer if no assigned importer desc. was found for the given extension\n    \\param  extension   [in] The extension to look for\n    \\return A pointer showing to the ImporterDesc, \\see aiImporterDesc.\n*/\nASSIMP_API const C_STRUCT aiImporterDesc* aiGetImporterDesc( const char *extension );\n\n#endif // AI_IMPORTER_DESC_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/importerdesc.h b/include/assimp/importerdesc.h
--- a/include/assimp/importerdesc.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/importerdesc.h	(date 1617519895000)
@@ -3,7 +3,7 @@
 Open Asset Import Library (assimp)
 ---------------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 
@@ -48,11 +48,14 @@
 #ifndef AI_IMPORTER_DESC_H_INC
 #define AI_IMPORTER_DESC_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 
 /** Mixed set of flags for #aiImporterDesc, indicating some features
   *  common to many importers*/
-enum aiImporterFlags
-{
+enum aiImporterFlags {
     /** Indicates that there is a textual encoding of the
      *  file format; and that it is supported.*/
     aiImporterFlags_SupportTextFlavour = 0x1,
@@ -87,8 +90,7 @@
  *  as importers/exporters are added to Assimp, so it might be useful
  *  to have a common mechanism to query some rough importer
  *  characteristics. */
-struct aiImporterDesc
-{
+struct aiImporterDesc {
     /** Full name of the importer (i.e. Blender3D importer)*/
     const char* mName;
 
Index: include/assimp/TinyFormatter.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file  TinyFormatter.h\n *  @brief Utility to format log messages more easily. Introduced\n *    to get rid of the boost::format dependency. Much slinker,\n *    basically just extends stringstream.\n */\n#ifndef INCLUDED_TINY_FORMATTER_H\n#define INCLUDED_TINY_FORMATTER_H\n\n#include <sstream>\n\nnamespace Assimp {\nnamespace Formatter {\n\n// ------------------------------------------------------------------------------------------------\n/** stringstream utility. Usage:\n *  @code\n *  void writelog(const std::string&s);\n *  void writelog(const std::wstring&s);\n *  ...\n *  writelog(format()<< \"hi! this is a number: \" << 4);\n *  writelog(wformat()<< L\"hi! this is a number: \" << 4);\n *\n *  @endcode */\ntemplate < typename T,\n    typename CharTraits = std::char_traits<T>,\n    typename Allocator  = std::allocator<T>\n>\nclass basic_formatter\n{\n\npublic:\n\n    typedef class std::basic_string<\n        T,CharTraits,Allocator\n    > string;\n\n    typedef class std::basic_ostringstream<\n        T,CharTraits,Allocator\n    > stringstream;\n\npublic:\n\n    basic_formatter() {}\n\n    /* Allow basic_formatter<T>'s to be used almost interchangeably\n     * with std::(w)string or const (w)char* arguments because the\n     * conversion c'tor is called implicitly. */\n    template <typename TT>\n    basic_formatter(const TT& sin)  {\n        underlying << sin;\n    }\n\n\n    // The problem described here:\n    // https://sourceforge.net/tracker/?func=detail&atid=1067632&aid=3358562&group_id=226462\n    // can also cause trouble here. Apparently, older gcc versions sometimes copy temporaries\n    // being bound to const ref& function parameters. Copying streams is not permitted, though.\n    // This workaround avoids this by manually specifying a copy ctor.\n#if !defined(__GNUC__) || !defined(__APPLE__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)\n    explicit basic_formatter(const basic_formatter& other) {\n        underlying << (string)other;\n    }\n#endif\n\n\npublic:\n\n    operator string () const {\n        return underlying.str();\n    }\n\n\n    /* note - this is declared const because binding temporaries does only\n     * work for const references, so many function prototypes will\n     * include const basic_formatter<T>& s but might still want to\n     * modify the formatted string without the need for a full copy.*/\n    template <typename TToken>\n    const basic_formatter& operator << (const TToken& s) const {\n        underlying << s;\n        return *this;\n    }\n\n    template <typename TToken>\n    basic_formatter& operator << (const TToken& s) {\n        underlying << s;\n        return *this;\n    }\n\n\n    // comma operator overloaded as well, choose your preferred way.\n    template <typename TToken>\n    const basic_formatter& operator, (const TToken& s) const {\n        underlying << s;\n        return *this;\n    }\n\n    template <typename TToken>\n    basic_formatter& operator, (const TToken& s) {\n        underlying << s;\n        return *this;\n    }\n\n    // Fix for MSVC8\n    // See https://sourceforge.net/projects/assimp/forums/forum/817654/topic/4372824\n    template <typename TToken>\n    basic_formatter& operator, (TToken& s) {\n        underlying << s;\n        return *this;\n    }\n\n\nprivate:\n    mutable stringstream underlying;\n};\n\n\ntypedef basic_formatter< char > format;\ntypedef basic_formatter< wchar_t > wformat;\n\n} // ! namespace Formatter\n\n} // ! namespace Assimp\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/TinyFormatter.h b/include/assimp/TinyFormatter.h
--- a/include/assimp/TinyFormatter.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/TinyFormatter.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -45,9 +45,14 @@
  *    to get rid of the boost::format dependency. Much slinker,
  *    basically just extends stringstream.
  */
+#pragma once
 #ifndef INCLUDED_TINY_FORMATTER_H
 #define INCLUDED_TINY_FORMATTER_H
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <sstream>
 
 namespace Assimp {
@@ -65,24 +70,15 @@
  *  @endcode */
 template < typename T,
     typename CharTraits = std::char_traits<T>,
-    typename Allocator  = std::allocator<T>
->
-class basic_formatter
-{
-
+    typename Allocator  = std::allocator<T> >
+class basic_formatter {
 public:
-
-    typedef class std::basic_string<
-        T,CharTraits,Allocator
-    > string;
+    typedef class std::basic_string<T,CharTraits,Allocator> string;
+    typedef class std::basic_ostringstream<T,CharTraits,Allocator> stringstream;
 
-    typedef class std::basic_ostringstream<
-        T,CharTraits,Allocator
-    > stringstream;
-
-public:
-
-    basic_formatter() {}
+    basic_formatter() {
+        // empty
+    }
 
     /* Allow basic_formatter<T>'s to be used almost interchangeably
      * with std::(w)string or const (w)char* arguments because the
@@ -104,14 +100,10 @@
     }
 #endif
 
-
-public:
-
     operator string () const {
         return underlying.str();
     }
 
-
     /* note - this is declared const because binding temporaries does only
      * work for const references, so many function prototypes will
      * include const basic_formatter<T>& s but might still want to
Index: include/assimp/postprocess.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file postprocess.h\n *  @brief Definitions for import post processing steps\n */\n#pragma once\n#ifndef AI_POSTPROCESS_H_INC\n#define AI_POSTPROCESS_H_INC\n\n#include \"types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// -----------------------------------------------------------------------------------\n/** @enum  aiPostProcessSteps\n *  @brief Defines the flags for all possible post processing steps.\n *\n *  @note Some steps are influenced by properties set on the Assimp::Importer itself\n *\n *  @see Assimp::Importer::ReadFile()\n *  @see Assimp::Importer::SetPropertyInteger()\n *  @see aiImportFile\n *  @see aiImportFileEx\n */\n// -----------------------------------------------------------------------------------\nenum aiPostProcessSteps\n{\n\n    // -------------------------------------------------------------------------\n    /** <hr>Calculates the tangents and bitangents for the imported meshes.\n     *\n     * Does nothing if a mesh does not have normals. You might want this post\n     * processing step to be executed if you plan to use tangent space calculations\n     * such as normal mapping  applied to the meshes. There's an importer property,\n     * <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify\n     * a maximum smoothing angle for the algorithm. However, usually you'll\n     * want to leave it at the default value.\n     */\n    aiProcess_CalcTangentSpace = 0x1,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Identifies and joins identical vertex data sets within all\n     *  imported meshes.\n     *\n     * After this step is run, each mesh contains unique vertices,\n     * so a vertex may be used by multiple faces. You usually want\n     * to use this post processing step. If your application deals with\n     * indexed geometry, this step is compulsory or you'll just waste rendering\n     * time. <b>If this flag is not specified</b>, no vertices are referenced by\n     * more than one face and <b>no index buffer is required</b> for rendering.\n     */\n    aiProcess_JoinIdenticalVertices = 0x2,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Converts all the imported data to a left-handed coordinate space.\n     *\n     * By default the data is returned in a right-handed coordinate space (which\n     * OpenGL prefers). In this space, +X points to the right,\n     * +Z points towards the viewer, and +Y points upwards. In the DirectX\n     * coordinate space +X points to the right, +Y points upwards, and +Z points\n     * away from the viewer.\n     *\n     * You'll probably want to consider this flag if you use Direct3D for\n     * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this\n     * setting and bundles all conversions typically required for D3D-based\n     * applications.\n     */\n    aiProcess_MakeLeftHanded = 0x4,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Triangulates all faces of all meshes.\n     *\n     * By default the imported mesh data might contain faces with more than 3\n     * indices. For rendering you'll usually want all faces to be triangles.\n     * This post processing step splits up faces with more than 3 indices into\n     * triangles. Line and point primitives are *not* modified! If you want\n     * 'triangles only' with no other kinds of primitives, try the following\n     * solution:\n     * <ul>\n     * <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>\n     * <li>Ignore all point and line meshes when you process assimp's output</li>\n     * </ul>\n     */\n    aiProcess_Triangulate = 0x8,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Removes some parts of the data structure (animations, materials,\n     *  light sources, cameras, textures, vertex components).\n     *\n     * The  components to be removed are specified in a separate\n     * importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful\n     * if you don't need all parts of the output structure. Vertex colors\n     * are rarely used today for example... Calling this step to remove unneeded\n     * data from the pipeline as early as possible results in increased\n     * performance and a more optimized output data structure.\n     * This step is also useful if you want to force Assimp to recompute\n     * normals or tangents. The corresponding steps don't recompute them if\n     * they're already there (loaded from the source asset). By using this\n     * step you can make sure they are NOT there.\n     *\n     * This flag is a poor one, mainly because its purpose is usually\n     * misunderstood. Consider the following case: a 3D model has been exported\n     * from a CAD app, and it has per-face vertex colors. Vertex positions can't be\n     * shared, thus the #aiProcess_JoinIdenticalVertices step fails to\n     * optimize the data because of these nasty little vertex colors.\n     * Most apps don't even process them, so it's all for nothing. By using\n     * this step, unneeded components are excluded as early as possible\n     * thus opening more room for internal optimizations.\n     */\n    aiProcess_RemoveComponent = 0x10,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Generates normals for all faces of all meshes.\n     *\n     * This is ignored if normals are already there at the time this flag\n     * is evaluated. Model importers try to load them from the source file, so\n     * they're usually already there. Face normals are shared between all points\n     * of a single face, so a single point can have multiple normals, which\n     * forces the library to duplicate vertices in some cases.\n     * #aiProcess_JoinIdenticalVertices is *senseless* then.\n     *\n     * This flag may not be specified together with #aiProcess_GenSmoothNormals.\n     */\n    aiProcess_GenNormals = 0x20,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Generates smooth normals for all vertices in the mesh.\n    *\n    * This is ignored if normals are already there at the time this flag\n    * is evaluated. Model importers try to load them from the source file, so\n    * they're usually already there.\n    *\n    * This flag may not be specified together with\n    * #aiProcess_GenNormals. There's a importer property,\n    * <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify\n    * an angle maximum for the normal smoothing algorithm. Normals exceeding\n    * this limit are not smoothed, resulting in a 'hard' seam between two faces.\n    * Using a decent angle here (e.g. 80 degrees) results in very good visual\n    * appearance.\n    */\n    aiProcess_GenSmoothNormals = 0x40,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Splits large meshes into smaller sub-meshes.\n    *\n    * This is quite useful for real-time rendering, where the number of triangles\n    * which can be maximally processed in a single draw-call is limited\n    * by the video driver/hardware. The maximum vertex buffer is usually limited\n    * too. Both requirements can be met with this step: you may specify both a\n    * triangle and vertex limit for a single mesh.\n    *\n    * The split limits can (and should!) be set through the\n    * <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>\n    * importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and\n    * <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.\n    *\n    * Note that splitting is generally a time-consuming task, but only if there's\n    * something to split. The use of this step is recommended for most users.\n    */\n    aiProcess_SplitLargeMeshes = 0x80,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Removes the node graph and pre-transforms all vertices with\n    * the local transformation matrices of their nodes.\n    *\n    * The output scene still contains nodes, however there is only a\n    * root node with children, each one referencing only one mesh,\n    * and each mesh referencing one material. For rendering, you can\n    * simply render all meshes in order - you don't need to pay\n    * attention to local transformations and the node hierarchy.\n    * Animations are removed during this step.\n    * This step is intended for applications without a scenegraph.\n    * The step CAN cause some problems: if e.g. a mesh of the asset\n    * contains normals and another, using the same material index, does not,\n    * they will be brought together, but the first meshes's part of\n    * the normal list is zeroed. However, these artifacts are rare.\n    * @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property\n    * can be set to normalize the scene's spatial dimension to the -1...1\n    * range.\n    */\n    aiProcess_PreTransformVertices = 0x100,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Limits the number of bones simultaneously affecting a single vertex\n    *  to a maximum value.\n    *\n    * If any vertex is affected by more than the maximum number of bones, the least\n    * important vertex weights are removed and the remaining vertex weights are\n    * renormalized so that the weights still sum up to 1.\n    * The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in\n    * config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer\n    * property to supply your own limit to the post processing step.\n    *\n    * If you intend to perform the skinning in hardware, this post processing\n    * step might be of interest to you.\n    */\n    aiProcess_LimitBoneWeights = 0x200,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Validates the imported scene data structure.\n     * This makes sure that all indices are valid, all animations and\n     * bones are linked correctly, all material references are correct .. etc.\n     *\n     * It is recommended that you capture Assimp's log output if you use this flag,\n     * so you can easily find out what's wrong if a file fails the\n     * validation. The validator is quite strict and will find *all*\n     * inconsistencies in the data structure... It is recommended that plugin\n     * developers use it to debug their loaders. There are two types of\n     * validation failures:\n     * <ul>\n     * <li>Error: There's something wrong with the imported data. Further\n     *   postprocessing is not possible and the data is not usable at all.\n     *   The import fails. #Importer::GetErrorString() or #aiGetErrorString()\n     *   carry the error message around.</li>\n     * <li>Warning: There are some minor issues (e.g. 1000000 animation\n     *   keyframes with the same time), but further postprocessing and use\n     *   of the data structure is still safe. Warning details are written\n     *   to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set\n     *   in #aiScene::mFlags</li>\n     * </ul>\n     *\n     * This post-processing step is not time-consuming. Its use is not\n     * compulsory, but recommended.\n    */\n    aiProcess_ValidateDataStructure = 0x400,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Reorders triangles for better vertex cache locality.\n     *\n     * The step tries to improve the ACMR (average post-transform vertex cache\n     * miss ratio) for all meshes. The implementation runs in O(n) and is\n     * roughly based on the 'tipsify' algorithm (see <a href=\"\n     * http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf\">this\n     * paper</a>).\n     *\n     * If you intend to render huge models in hardware, this step might\n     * be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>\n     * importer property can be used to fine-tune the cache optimization.\n     */\n    aiProcess_ImproveCacheLocality = 0x800,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Searches for redundant/unreferenced materials and removes them.\n     *\n     * This is especially useful in combination with the\n     * #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.\n     * Both join small meshes with equal characteristics, but they can't do\n     * their work if two meshes have different materials. Because several\n     * material settings are lost during Assimp's import filters,\n     * (and because many exporters don't check for redundant materials), huge\n     * models often have materials which are are defined several times with\n     * exactly the same settings.\n     *\n     * Several material settings not contributing to the final appearance of\n     * a surface are ignored in all comparisons (e.g. the material name).\n     * So, if you're passing additional information through the\n     * content pipeline (probably using *magic* material names), don't\n     * specify this flag. Alternatively take a look at the\n     * <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.\n     */\n    aiProcess_RemoveRedundantMaterials = 0x1000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step tries to determine which meshes have normal vectors\n     * that are facing inwards and inverts them.\n     *\n     * The algorithm is simple but effective:\n     * the bounding box of all vertices + their normals is compared against\n     * the volume of the bounding box of all vertices without their normals.\n     * This works well for most objects, problems might occur with planar\n     * surfaces. However, the step tries to filter such cases.\n     * The step inverts all in-facing normals. Generally it is recommended\n     * to enable this step, although the result is not always correct.\n    */\n    aiProcess_FixInfacingNormals = 0x2000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step splits meshes with more than one primitive type in\n     *  homogeneous sub-meshes.\n     *\n     *  The step is executed after the triangulation step. After the step\n     *  returns, just one bit is set in aiMesh::mPrimitiveTypes. This is\n     *  especially useful for real-time rendering where point and line\n     *  primitives are often ignored or rendered separately.\n     *  You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to\n     *  specify which primitive types you need. This can be used to easily\n     *  exclude lines and points, which are rarely used, from the import.\n    */\n    aiProcess_SortByPType = 0x8000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step searches all meshes for degenerate primitives and\n     *  converts them to proper lines or points.\n     *\n     * A face is 'degenerate' if one or more of its points are identical.\n     * To have the degenerate stuff not only detected and collapsed but\n     * removed, try one of the following procedures:\n     * <br><b>1.</b> (if you support lines and points for rendering but don't\n     *    want the degenerates)<br>\n     * <ul>\n     *   <li>Specify the #aiProcess_FindDegenerates flag.\n     *   </li>\n     *   <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to\n     *       1. This will cause the step to remove degenerate triangles from the\n     *       import as soon as they're detected. They won't pass any further\n     *       pipeline steps.\n     *   </li>\n     * </ul>\n     * <br><b>2.</b>(if you don't support lines and points at all)<br>\n     * <ul>\n     *   <li>Specify the #aiProcess_FindDegenerates flag.\n     *   </li>\n     *   <li>Specify the #aiProcess_SortByPType flag. This moves line and\n     *     point primitives to separate meshes.\n     *   </li>\n     *   <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to\n     *       @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES\n     *       @endcode to cause SortByPType to reject point\n     *       and line meshes from the scene.\n     *   </li>\n     * </ul>\n     *\n     * This step also removes very small triangles with a surface area smaller\n     * than 10^-6. If you rely on having these small triangles, or notice holes\n     * in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to\n     * false.\n     * @note Degenerate polygons are not necessarily evil and that's why\n     * they're not removed by default. There are several file formats which\n     * don't support lines or points, and some exporters bypass the\n     * format specification and write them as degenerate triangles instead.\n    */\n    aiProcess_FindDegenerates = 0x10000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step searches all meshes for invalid data, such as zeroed\n     *  normal vectors or invalid UV coords and removes/fixes them. This is\n     *  intended to get rid of some common exporter errors.\n     *\n     * This is especially useful for normals. If they are invalid, and\n     * the step recognizes this, they will be removed and can later\n     * be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>\n     * The step will also remove meshes that are infinitely small and reduce\n     * animation tracks consisting of hundreds if redundant keys to a single\n     * key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides\n     * the accuracy of the check for duplicate animation tracks.\n    */\n    aiProcess_FindInvalidData = 0x20000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step converts non-UV mappings (such as spherical or\n     *  cylindrical mapping) to proper texture coordinate channels.\n     *\n     * Most applications will support UV mapping only, so you will\n     * probably want to specify this step in every case. Note that Assimp is not\n     * always able to match the original mapping implementation of the\n     * 3D app which produced a model perfectly. It's always better to let the\n     * modelling app compute the UV channels - 3ds max, Maya, Blender,\n     * LightWave, and Modo do this for example.\n     *\n     * @note If this step is not requested, you'll need to process the\n     * <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets\n     * properly.\n     */\n    aiProcess_GenUVCoords = 0x40000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step applies per-texture UV transformations and bakes\n     *  them into stand-alone vtexture coordinate channels.\n     *\n     * UV transformations are specified per-texture - see the\n     * <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.\n     * This step processes all textures with\n     * transformed input UV coordinates and generates a new (pre-transformed) UV channel\n     * which replaces the old channel. Most applications won't support UV\n     * transformations, so you will probably want to specify this step.\n     *\n     * @note UV transformations are usually implemented in real-time apps by\n     * transforming texture coordinates at vertex shader stage with a 3x3\n     * (homogenous) transformation matrix.\n    */\n    aiProcess_TransformUVCoords = 0x80000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step searches for duplicate meshes and replaces them\n     *  with references to the first mesh.\n     *\n     *  This step takes a while, so don't use it if speed is a concern.\n     *  Its main purpose is to workaround the fact that many export\n     *  file formats don't support instanced meshes, so exporters need to\n     *  duplicate meshes. This step removes the duplicates again. Please\n     *  note that Assimp does not currently support per-node material\n     *  assignment to meshes, which means that identical meshes with\n     *  different materials are currently *not* joined, although this is\n     *  planned for future versions.\n     */\n    aiProcess_FindInstances = 0x100000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>A post-processing step to reduce the number of meshes.\n     *\n     *  This will, in fact, reduce the number of draw calls.\n     *\n     *  This is a very effective optimization and is recommended to be used\n     *  together with #aiProcess_OptimizeGraph, if possible. The flag is fully\n     *  compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.\n    */\n    aiProcess_OptimizeMeshes  = 0x200000,\n\n\n    // -------------------------------------------------------------------------\n    /** <hr>A post-processing step to optimize the scene hierarchy.\n     *\n     *  Nodes without animations, bones, lights or cameras assigned are\n     *  collapsed and joined.\n     *\n     *  Node names can be lost during this step. If you use special 'tag nodes'\n     *  to pass additional information through your content pipeline, use the\n     *  <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a\n     *  list of node names you want to be kept. Nodes matching one of the names\n     *  in this list won't be touched or modified.\n     *\n     *  Use this flag with caution. Most simple files will be collapsed to a\n     *  single node, so complex hierarchies are usually completely lost. This is not\n     *  useful for editor environments, but probably a very effective\n     *  optimization if you just want to get the model data, convert it to your\n     *  own format, and render it as fast as possible.\n     *\n     *  This flag is designed to be used with #aiProcess_OptimizeMeshes for best\n     *  results.\n     *\n     *  @note 'Crappy' scenes with thousands of extremely small meshes packed\n     *  in deeply nested nodes exist for almost all file formats.\n     *  #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph\n     *  usually fixes them all and makes them renderable.\n    */\n    aiProcess_OptimizeGraph  = 0x400000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step flips all UV coordinates along the y-axis and adjusts\n     * material settings and bitangents accordingly.\n     *\n     * <b>Output UV coordinate system:</b>\n     * @code\n     * 0y|0y ---------- 1x|0y\n     * |                 |\n     * |                 |\n     * |                 |\n     * 0x|1y ---------- 1x|1y\n     * @endcode\n     *\n     * You'll probably want to consider this flag if you use Direct3D for\n     * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this\n     * setting and bundles all conversions typically required for D3D-based\n     * applications.\n    */\n    aiProcess_FlipUVs = 0x800000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step adjusts the output face winding order to be CW.\n     *\n     * The default face winding order is counter clockwise (CCW).\n     *\n     * <b>Output face order:</b>\n     * @code\n     *       x2\n     *\n     *                         x0\n     *  x1\n     * @endcode\n    */\n    aiProcess_FlipWindingOrder  = 0x1000000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step splits meshes with many bones into sub-meshes so that each\n     * sub-mesh has fewer or as many bones as a given limit.\n    */\n    aiProcess_SplitByBoneCount  = 0x2000000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step removes bones losslessly or according to some threshold.\n     *\n     *  In some cases (i.e. formats that require it) exporters are forced to\n     *  assign dummy bone weights to otherwise static meshes assigned to\n     *  animated meshes. Full, weight-based skinning is expensive while\n     *  animating nodes is extremely cheap, so this step is offered to clean up\n     *  the data in that regard.\n     *\n     *  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.\n     *  Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and\n     *  only if all bones within the scene qualify for removal.\n    */\n    aiProcess_Debone  = 0x4000000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>This step will perform a global scale of the model.\n    *\n    *  Some importers are providing a mechanism to define a scaling unit for the\n    *  model. This post processing step can be used to do so. You need to get the\n    *  global scaling from your importer settings like in FBX. Use the flag\n    *  AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.\n    *\n    *  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.\n    */\n    aiProcess_GlobalScale = 0x8000000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>A postprocessing step to embed of textures.\n     *\n     *  This will remove external data dependencies for textures.\n     *  If a texture's file does not exist at the specified path\n     *  (due, for instance, to an absolute path generated on another system),\n     *  it will check if a file with the same name exists at the root folder\n     *  of the imported model. And if so, it uses that.\n     */\n    aiProcess_EmbedTextures  = 0x10000000,\n        \n    // aiProcess_GenEntityMeshes = 0x100000,\n    // aiProcess_OptimizeAnimations = 0x200000\n    // aiProcess_FixTexturePaths = 0x200000\n\n\n    aiProcess_ForceGenNormals = 0x20000000,\n\n    // -------------------------------------------------------------------------\n    /** <hr>Drops normals for all faces of all meshes.\n     *\n     * This is ignored if no normals are present.\n     * Face normals are shared between all points of a single face,\n     * so a single point can have multiple normals, which\n     * forces the library to duplicate vertices in some cases.\n     * #aiProcess_JoinIdenticalVertices is *senseless* then.\n     * This process gives sense back to aiProcess_JoinIdenticalVertices\n     */\n    aiProcess_DropNormals = 0x40000000,\n\n    // -------------------------------------------------------------------------\n    /**\n     */\n    aiProcess_GenBoundingBoxes = 0x80000000\n};\n\n\n// ---------------------------------------------------------------------------------------\n/** @def aiProcess_ConvertToLeftHanded\n *  @brief Shortcut flag for Direct3D-based applications.\n *\n *  Supersedes the #aiProcess_MakeLeftHanded and #aiProcess_FlipUVs and\n *  #aiProcess_FlipWindingOrder flags.\n *  The output data matches Direct3D's conventions: left-handed geometry, upper-left\n *  origin for UV coordinates and finally clockwise face order, suitable for CCW culling.\n *\n *  @deprecated\n */\n#define aiProcess_ConvertToLeftHanded ( \\\n    aiProcess_MakeLeftHanded     | \\\n    aiProcess_FlipUVs            | \\\n    aiProcess_FlipWindingOrder   | \\\n    0 )\n\n\n// ---------------------------------------------------------------------------------------\n/** @def aiProcessPreset_TargetRealtime_Fast\n *  @brief Default postprocess configuration optimizing the data for real-time rendering.\n *\n *  Applications would want to use this preset to load models on end-user PCs,\n *  maybe for direct use in game.\n *\n * If you're using DirectX, don't forget to combine this value with\n * the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations\n * in your application apply the #aiProcess_TransformUVCoords step, too.\n *  @note Please take the time to read the docs for the steps enabled by this preset.\n *  Some of them offer further configurable properties, while some of them might not be of\n *  use for you so it might be better to not specify them.\n */\n#define aiProcessPreset_TargetRealtime_Fast ( \\\n    aiProcess_CalcTangentSpace      |  \\\n    aiProcess_GenNormals            |  \\\n    aiProcess_JoinIdenticalVertices |  \\\n    aiProcess_Triangulate           |  \\\n    aiProcess_GenUVCoords           |  \\\n    aiProcess_SortByPType           |  \\\n    0 )\n\n // ---------------------------------------------------------------------------------------\n /** @def aiProcessPreset_TargetRealtime_Quality\n  *  @brief Default postprocess configuration optimizing the data for real-time rendering.\n  *\n  *  Unlike #aiProcessPreset_TargetRealtime_Fast, this configuration\n  *  performs some extra optimizations to improve rendering speed and\n  *  to minimize memory usage. It could be a good choice for a level editor\n  *  environment where import speed is not so important.\n  *\n  *  If you're using DirectX, don't forget to combine this value with\n  *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations\n  *  in your application apply the #aiProcess_TransformUVCoords step, too.\n  *  @note Please take the time to read the docs for the steps enabled by this preset.\n  *  Some of them offer further configurable properties, while some of them might not be\n  *  of use for you so it might be better to not specify them.\n  */\n#define aiProcessPreset_TargetRealtime_Quality ( \\\n    aiProcess_CalcTangentSpace              |  \\\n    aiProcess_GenSmoothNormals              |  \\\n    aiProcess_JoinIdenticalVertices         |  \\\n    aiProcess_ImproveCacheLocality          |  \\\n    aiProcess_LimitBoneWeights              |  \\\n    aiProcess_RemoveRedundantMaterials      |  \\\n    aiProcess_SplitLargeMeshes              |  \\\n    aiProcess_Triangulate                   |  \\\n    aiProcess_GenUVCoords                   |  \\\n    aiProcess_SortByPType                   |  \\\n    aiProcess_FindDegenerates               |  \\\n    aiProcess_FindInvalidData               |  \\\n    0 )\n\n // ---------------------------------------------------------------------------------------\n /** @def aiProcessPreset_TargetRealtime_MaxQuality\n  *  @brief Default postprocess configuration optimizing the data for real-time rendering.\n  *\n  *  This preset enables almost every optimization step to achieve perfectly\n  *  optimized data. It's your choice for level editor environments where import speed\n  *  is not important.\n  *\n  *  If you're using DirectX, don't forget to combine this value with\n  *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations\n  *  in your application, apply the #aiProcess_TransformUVCoords step, too.\n  *  @note Please take the time to read the docs for the steps enabled by this preset.\n  *  Some of them offer further configurable properties, while some of them might not be\n  *  of use for you so it might be better to not specify them.\n  */\n#define aiProcessPreset_TargetRealtime_MaxQuality ( \\\n    aiProcessPreset_TargetRealtime_Quality   |  \\\n    aiProcess_FindInstances                  |  \\\n    aiProcess_ValidateDataStructure          |  \\\n    aiProcess_OptimizeMeshes                 |  \\\n    0 )\n\n\n#ifdef __cplusplus\n} // end of extern \"C\"\n#endif\n\n#endif // AI_POSTPROCESS_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/postprocess.h b/include/assimp/postprocess.h
--- a/include/assimp/postprocess.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/postprocess.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -47,7 +47,11 @@
 #ifndef AI_POSTPROCESS_H_INC
 #define AI_POSTPROCESS_H_INC
 
-#include "types.h"
+#include <assimp/types.h>
+
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -316,6 +320,19 @@
     */
     aiProcess_FixInfacingNormals = 0x2000,
 
+
+
+    // -------------------------------------------------------------------------
+    /** 
+     * This step generically populates aiBone->mArmature and aiBone->mNode generically
+     * The point of these is it saves you later having to calculate these elements
+     * This is useful when handling rest information or skin information
+     * If you have multiple armatures on your models we strongly recommend enabling this 
+     * Instead of writing your own multi-root, multi-armature lookups we have done the 
+     * hard work for you :)
+   */
+    aiProcess_PopulateArmatureData = 0x4000,
+
     // -------------------------------------------------------------------------
     /** <hr>This step splits meshes with more than one primitive type in
      *  homogeneous sub-meshes.
@@ -533,6 +550,8 @@
     */
     aiProcess_Debone  = 0x4000000,
 
+
+
     // -------------------------------------------------------------------------
     /** <hr>This step will perform a global scale of the model.
     *
Index: include/assimp/GenericProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n#ifndef AI_GENERIC_PROPERTY_H_INCLUDED\n#define AI_GENERIC_PROPERTY_H_INCLUDED\n\n#include <assimp/Importer.hpp>\n#include <assimp/ai_assert.h>\n#include \"Hash.h\"\n\n#include <map>\n\n// ------------------------------------------------------------------------------------------------\ntemplate <class T>\ninline\nbool SetGenericProperty(std::map< unsigned int, T >& list,\n        const char* szName, const T& value) {\n    ai_assert(nullptr != szName);\n    const uint32_t hash = SuperFastHash(szName);\n\n    typename std::map<unsigned int, T>::iterator it = list.find(hash);\n    if (it == list.end())   {\n        list.insert(std::pair<unsigned int, T>( hash, value ));\n        return false;\n    }\n    (*it).second = value;\n\n    return true;\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <class T>\ninline\nconst T& GetGenericProperty(const std::map< unsigned int, T >& list,\n        const char* szName, const T& errorReturn) {\n    ai_assert(nullptr != szName);\n    const uint32_t hash = SuperFastHash(szName);\n\n    typename std::map<unsigned int, T>::const_iterator it = list.find(hash);\n    if (it == list.end()) {\n        return errorReturn;\n    }\n\n    return (*it).second;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Special version for pointer types - they will be deleted when replaced with another value\n// passing NULL removes the whole property\ntemplate <class T>\ninline\nvoid SetGenericPropertyPtr(std::map< unsigned int, T* >& list,\n        const char* szName, T* value, bool* bWasExisting = nullptr ) {\n    ai_assert(nullptr != szName);\n    const uint32_t hash = SuperFastHash(szName);\n\n    typename std::map<unsigned int, T*>::iterator it = list.find(hash);\n    if (it == list.end())   {\n        if (bWasExisting) {\n            *bWasExisting = false;\n        }\n\n        list.insert(std::pair<unsigned int,T*>( hash, value ));\n        return;\n    }\n    if ((*it).second != value)  {\n        delete (*it).second;\n        (*it).second = value;\n    }\n    if (!value) {\n        list.erase(it);\n    }\n    if (bWasExisting) {\n        *bWasExisting = true;\n    }\n}\n\n// ------------------------------------------------------------------------------------------------\ntemplate <class T>\ninline\nbool HasGenericProperty(const std::map< unsigned int, T >& list,\n        const char* szName) {\n    ai_assert(nullptr != szName);\n    const uint32_t hash = SuperFastHash(szName);\n\n    typename std::map<unsigned int, T>::const_iterator it = list.find(hash);\n    if (it == list.end()) {\n        return false;\n    }\n\n    return true;\n}\n\n#endif // !! AI_GENERIC_PROPERTY_H_INCLUDED\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/GenericProperty.h b/include/assimp/GenericProperty.h
--- a/include/assimp/GenericProperty.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/GenericProperty.h	(date 1617519895000)
@@ -2,8 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
-
+Copyright (c) 2006-2020, assimp team
 
 All rights reserved.
 
@@ -40,26 +39,30 @@
 ----------------------------------------------------------------------
 */
 
+#pragma once
 #ifndef AI_GENERIC_PROPERTY_H_INCLUDED
 #define AI_GENERIC_PROPERTY_H_INCLUDED
 
-#include <assimp/Importer.hpp>
+#ifdef __GNUC__
+#    pragma GCC system_header
+#endif
+
+#include <assimp/Hash.h>
 #include <assimp/ai_assert.h>
-#include "Hash.h"
+#include <assimp/Importer.hpp>
 
 #include <map>
 
 // ------------------------------------------------------------------------------------------------
 template <class T>
-inline
-bool SetGenericProperty(std::map< unsigned int, T >& list,
-        const char* szName, const T& value) {
+inline bool SetGenericProperty(std::map<unsigned int, T> &list,
+        const char *szName, const T &value) {
     ai_assert(nullptr != szName);
     const uint32_t hash = SuperFastHash(szName);
 
     typename std::map<unsigned int, T>::iterator it = list.find(hash);
-    if (it == list.end())   {
-        list.insert(std::pair<unsigned int, T>( hash, value ));
+    if (it == list.end()) {
+        list.insert(std::pair<unsigned int, T>(hash, value));
         return false;
     }
     (*it).second = value;
@@ -69,9 +72,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <class T>
-inline
-const T& GetGenericProperty(const std::map< unsigned int, T >& list,
-        const char* szName, const T& errorReturn) {
+inline const T &GetGenericProperty(const std::map<unsigned int, T> &list,
+        const char *szName, const T &errorReturn) {
     ai_assert(nullptr != szName);
     const uint32_t hash = SuperFastHash(szName);
 
@@ -87,22 +89,21 @@
 // Special version for pointer types - they will be deleted when replaced with another value
 // passing NULL removes the whole property
 template <class T>
-inline
-void SetGenericPropertyPtr(std::map< unsigned int, T* >& list,
-        const char* szName, T* value, bool* bWasExisting = nullptr ) {
+inline void SetGenericPropertyPtr(std::map<unsigned int, T *> &list,
+        const char *szName, T *value, bool *bWasExisting = nullptr) {
     ai_assert(nullptr != szName);
     const uint32_t hash = SuperFastHash(szName);
 
-    typename std::map<unsigned int, T*>::iterator it = list.find(hash);
-    if (it == list.end())   {
+    typename std::map<unsigned int, T *>::iterator it = list.find(hash);
+    if (it == list.end()) {
         if (bWasExisting) {
             *bWasExisting = false;
         }
 
-        list.insert(std::pair<unsigned int,T*>( hash, value ));
+        list.insert(std::pair<unsigned int, T *>(hash, value));
         return;
     }
-    if ((*it).second != value)  {
+    if ((*it).second != value) {
         delete (*it).second;
         (*it).second = value;
     }
@@ -116,9 +117,8 @@
 
 // ------------------------------------------------------------------------------------------------
 template <class T>
-inline
-bool HasGenericProperty(const std::map< unsigned int, T >& list,
-        const char* szName) {
+inline bool HasGenericProperty(const std::map<unsigned int, T> &list,
+        const char *szName) {
     ai_assert(nullptr != szName);
     const uint32_t hash = SuperFastHash(szName);
 
Index: include/assimp/SkeletonMeshBuilder.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/** Helper class to construct a dummy mesh for file formats containing only motion data */\n\n/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file SkeletonMeshBuilder.h\n *  Declares SkeletonMeshBuilder, a tiny utility to build dummy meshes\n *  for animation skeletons.\n */\n\n#ifndef AI_SKELETONMESHBUILDER_H_INC\n#define AI_SKELETONMESHBUILDER_H_INC\n\n#include <vector>\n#include <assimp/mesh.h>\n\nstruct aiMaterial;\nstruct aiScene;\nstruct aiNode;\n\nnamespace Assimp    {\n\n// ---------------------------------------------------------------------------\n/**\n * This little helper class constructs a dummy mesh for a given scene\n * the resembles the node hierarchy. This is useful for file formats\n * that don't carry any mesh data but only animation data.\n */\nclass ASSIMP_API SkeletonMeshBuilder\n{\npublic:\n\n    // -------------------------------------------------------------------\n    /** The constructor processes the given scene and adds a mesh there.\n     *\n     * Does nothing if the scene already has mesh data.\n     * @param pScene The scene for which a skeleton mesh should be constructed.\n     * @param root The node to start with. NULL is the scene root\n     * @param bKnobsOnly Set this to true if you don't want the connectors\n     *   between the knobs representing the nodes.\n     */\n    SkeletonMeshBuilder( aiScene* pScene, aiNode* root = NULL,\n        bool bKnobsOnly = false);\n\nprotected:\n\n    // -------------------------------------------------------------------\n    /** Recursively builds a simple mesh representation for the given node\n     * and also creates a joint for the node that affects this part of\n     * the mesh.\n     * @param pNode The node to build geometry for.\n     */\n    void CreateGeometry( const aiNode* pNode);\n\n    // -------------------------------------------------------------------\n    /** Creates the mesh from the internally accumulated stuff and returns it.\n     */\n    aiMesh* CreateMesh();\n\n    // -------------------------------------------------------------------\n    /** Creates a dummy material and returns it. */\n    aiMaterial* CreateMaterial();\n\nprotected:\n    /** space to assemble the mesh data: points */\n    std::vector<aiVector3D> mVertices;\n\n    /** faces */\n    struct Face\n    {\n        unsigned int mIndices[3];\n        Face();\n        Face( unsigned int p0, unsigned int p1, unsigned int p2)\n        { mIndices[0] = p0; mIndices[1] = p1; mIndices[2] = p2; }\n    };\n    std::vector<Face> mFaces;\n\n    /** bones */\n    std::vector<aiBone*> mBones;\n\n    bool mKnobsOnly;\n};\n\n} // end of namespace Assimp\n\n#endif // AI_SKELETONMESHBUILDER_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SkeletonMeshBuilder.h b/include/assimp/SkeletonMeshBuilder.h
--- a/include/assimp/SkeletonMeshBuilder.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SkeletonMeshBuilder.h	(date 1617519895000)
@@ -4,7 +4,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -47,9 +47,14 @@
  *  for animation skeletons.
  */
 
+#pragma once
 #ifndef AI_SKELETONMESHBUILDER_H_INC
 #define AI_SKELETONMESHBUILDER_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <vector>
 #include <assimp/mesh.h>
 
Index: include/assimp/SmoothingGroups.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nOpen Asset Import Library (assimp)\n----------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the\nfollowing conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----------------------------------------------------------------------\n*/\n\n/** @file Defines the helper data structures for importing 3DS files.\nhttp://www.jalix.org/ressources/graphics/3DS/_unofficials/3ds-unofficial.txt */\n\n#ifndef AI_SMOOTHINGGROUPS_H_INC\n#define AI_SMOOTHINGGROUPS_H_INC\n\n#include <assimp/vector3.h>\n#include <stdint.h>\n#include <vector>\n\n// ---------------------------------------------------------------------------\n/** Helper structure representing a face with smoothing groups assigned */\nstruct FaceWithSmoothingGroup {\n    FaceWithSmoothingGroup() AI_NO_EXCEPT\n    : mIndices()\n    , iSmoothGroup(0) {\n        // in debug builds set all indices to a common magic value\n#ifdef ASSIMP_BUILD_DEBUG\n        this->mIndices[0] = 0xffffffff;\n        this->mIndices[1] = 0xffffffff;\n        this->mIndices[2] = 0xffffffff;\n#endif\n    }\n\n\n    //! Indices. .3ds is using uint16. However, after\n    //! an unique vertex set has been generated,\n    //! individual index values might exceed 2^16\n    uint32_t mIndices[3];\n\n    //! specifies to which smoothing group the face belongs to\n    uint32_t iSmoothGroup;\n};\n\n// ---------------------------------------------------------------------------\n/** Helper structure representing a mesh whose faces have smoothing\n    groups assigned. This allows us to reuse the code for normal computations\n    from smoothings groups for several loaders (3DS, ASE). All of them\n    use face structures which inherit from #FaceWithSmoothingGroup,\n    but as they add extra members and need to be copied by value we\n    need to use a template here.\n    */\ntemplate <class T>\nstruct MeshWithSmoothingGroups\n{\n    //! Vertex positions\n    std::vector<aiVector3D> mPositions;\n\n    //! Face lists\n    std::vector<T> mFaces;\n\n    //! List of normal vectors\n    std::vector<aiVector3D> mNormals;\n};\n\n// ---------------------------------------------------------------------------\n/** Computes normal vectors for the mesh\n */\ntemplate <class T>\nvoid ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh);\n\n\n// include implementations\n#include \"SmoothingGroups.inl\"\n\n#endif // !! AI_SMOOTHINGGROUPS_H_INC\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/assimp/SmoothingGroups.h b/include/assimp/SmoothingGroups.h
--- a/include/assimp/SmoothingGroups.h	(revision 506d65f317182b7c98c31844b9ec60ec92025cda)
+++ b/include/assimp/SmoothingGroups.h	(date 1617519895000)
@@ -2,7 +2,7 @@
 Open Asset Import Library (assimp)
 ----------------------------------------------------------------------
 
-Copyright (c) 2006-2019, assimp team
+Copyright (c) 2006-2020, assimp team
 
 
 All rights reserved.
@@ -43,10 +43,16 @@
 /** @file Defines the helper data structures for importing 3DS files.
 http://www.jalix.org/ressources/graphics/3DS/_unofficials/3ds-unofficial.txt */
 
+#pragma once
 #ifndef AI_SMOOTHINGGROUPS_H_INC
 #define AI_SMOOTHINGGROUPS_H_INC
 
+#ifdef __GNUC__
+#   pragma GCC system_header
+#endif
+
 #include <assimp/vector3.h>
+
 #include <stdint.h>
 #include <vector>
 
diff --git a/cmake-files/FindGLFW.cmake b/cmake-files/FindGLFW.cmake
new file mode 100644
