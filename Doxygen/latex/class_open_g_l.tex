\hypertarget{class_open_g_l}{}\doxysection{Open\+GL Class Reference}
\label{class_open_g_l}\index{OpenGL@{OpenGL}}


The abstract \mbox{\hyperlink{class_open_g_l}{Open\+GL}} version of the renderer. Uses the \mbox{\hyperlink{class_renderer}{Renderer}} parent class to have an abstract opengl class that doesnt directly intereact with the system and is used via facading it into the system.  




{\ttfamily \#include $<$Open\+GL.\+h$>$}



Inheritance diagram for Open\+GL\+:
% FIG 0


Collaboration diagram for Open\+GL\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{class_open_g_l_ad0222ac664fbb5018065732b5ff0f699}{Render\+Terrain}} (unsigned int VAO, int size)
\begin{DoxyCompactList}\small\item\em Renders the games terrain. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_af73c3c12c76274a45f3d4245d2d9d11a}{Render\+Model}} (\mbox{\hyperlink{class_shader}{Shader}} \&shader, glm\+::mat4 new\+Model, \mbox{\hyperlink{class_mesh}{Mesh}} mesh)
\begin{DoxyCompactList}\small\item\em Renders the games model. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a09dc5a5ab1ab540607820efafc9d534d}{Bind\+Texture}} (std\+::vector$<$ unsigned int $>$ textures)
\begin{DoxyCompactList}\small\item\em Binds textures to memory. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_open_g_l_a3fcb6ffd9e2933c821ce79c0402ad211}\label{class_open_g_l_a3fcb6ffd9e2933c821ce79c0402ad211}} 
virtual void \mbox{\hyperlink{class_open_g_l_a3fcb6ffd9e2933c821ce79c0402ad211}{Depth\+Test}} ()
\begin{DoxyCompactList}\small\item\em Calls the depth test. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a78930c5422a4b13cdddd9980a1b5216e}{Render\+Skybox}} (unsigned int VAO, unsigned int texture)
\begin{DoxyCompactList}\small\item\em Renders the sky box. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a9e1ffb565600b03b7fa57f6370ff592b}{Set\+Shader}} (\mbox{\hyperlink{class_shader}{Shader}} shader, \mbox{\hyperlink{class_view}{View}} lens)
\begin{DoxyCompactList}\small\item\em Sets the shader and uses it. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_ad3aff4310ee768707a5813e5133e41aa}{Set\+Shader\+Skybox}} (\mbox{\hyperlink{class_shader}{Shader}} shader, \mbox{\hyperlink{class_view}{View}} lens)
\begin{DoxyCompactList}\small\item\em Sets the shader and uses it for the skybox. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a94ada51533a316920282d45879bde0fc}{Terrain\+Setup}} (std\+::vector$<$ glm\+::vec3 $>$ total\+Data, std\+::vector$<$ unsigned int $>$ Indices, unsigned int \&VAO, unsigned int \&VBO, unsigned int \&EBO)
\begin{DoxyCompactList}\small\item\em Sets up the terrain data. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_affd50e6ec6e2a1cef5f54d08b904f834}{Skybox\+Setup}} (std\+::vector$<$ float $>$ sky\+Verts, std\+::vector$<$ std\+::string $>$ faces, unsigned int \&VAO, unsigned int \&VBO, unsigned int \&texture, \mbox{\hyperlink{class_shader}{Shader}} \&sky\+Shader)
\begin{DoxyCompactList}\small\item\em Sets up the skybox. \end{DoxyCompactList}\item 
virtual unsigned int \mbox{\hyperlink{class_open_g_l_aaea0f9919293a301acbaf5854c2f4f90}{Texture\+From\+File}} (std\+::string path, const std\+::string \&directory)
\begin{DoxyCompactList}\small\item\em grabs a texture from a specified file path \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a0635ac48f5d06ce636e2adca774dd3b5}{Setup\+Mesh}} (unsigned int \&VAO, unsigned int \&VBO, unsigned int \&EBO, std\+::vector$<$ \mbox{\hyperlink{struct_vertex}{Vertex}} $>$ vertices, std\+::vector$<$ unsigned int $>$ indices)
\begin{DoxyCompactList}\small\item\em Sets an objects mesh. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a121c5cdb62e37ae54455f1f799d5c449}{Set\+Shader\+Terrain}} (\mbox{\hyperlink{class_shader}{Shader}} \&shader, \mbox{\hyperlink{class_view}{View}} lens)
\begin{DoxyCompactList}\small\item\em Sets up the shader for the terrain. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_a1aa8e3b718d4635acd8bdbff39920c5a}{Render\+Exit\+Screen}} (unsigned int VAO, unsigned int EBO, unsigned int texture)
\begin{DoxyCompactList}\small\item\em Rends the exit model. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_open_g_l_aebd9611b84f6496a5b075b1714fb3d4b}{Exit\+Screen\+Setup}} (std\+::vector$<$ glm\+::vec3 $>$ vertex\+Data, std\+::vector$<$ unsigned int $>$ indices\+Data, unsigned int \&VAO, unsigned int \&VBO, unsigned int \&EBO)
\begin{DoxyCompactList}\small\item\em Sets up the exit screen. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_open_g_l_a3b91f32179a5911bd4282d25ab303e9b}\label{class_open_g_l_a3b91f32179a5911bd4282d25ab303e9b}} 
unsigned int {\bfseries Texture\+From\+File} (std\+::string path)
\item 
\mbox{\Hypertarget{class_open_g_l_ae91179c1433c7d8a4237cabc7fa2aa87}\label{class_open_g_l_ae91179c1433c7d8a4237cabc7fa2aa87}} 
virtual int {\bfseries Load\+Model} (int num\+Frames, std\+::vector$<$ int $>$ commands, unsigned int \&VAO, v3 anorms\mbox{[}162\mbox{]}, std\+::vector$<$ std\+::vector$<$ glm\+::vec3 $>$$>$ vertices, std\+::vector$<$ std\+::vector$<$ int $>$$>$ normals)
\item 
\mbox{\Hypertarget{class_open_g_l_abd21c569fe2bbdbc80414e8f2dbdc08c}\label{class_open_g_l_abd21c569fe2bbdbc80414e8f2dbdc08c}} 
virtual void {\bfseries Render\+Model} (int number, \mbox{\hyperlink{struct_md2_state}{Md2\+State}} $\ast$anim\+State, glm\+::mat4 proj, glm\+::mat4 view, glm\+::mat4 gen\+Four, float direction, unsigned int \&VAO, unsigned int \&texture\+Id, \mbox{\hyperlink{class_shader}{Shader}} \&shader)
\item 
\mbox{\Hypertarget{class_open_g_l_a6e739507fe6fb9f98641ac3a22629a0d}\label{class_open_g_l_a6e739507fe6fb9f98641ac3a22629a0d}} 
virtual void {\bfseries Render\+Model} (int number, \mbox{\hyperlink{struct_md2_state}{Md2\+State}} $\ast$anim\+State, glm\+::mat4 proj, glm\+::mat4 view, glm\+::vec3 position, glm\+::vec3 rotation, float direction, unsigned int \&VAO, unsigned int \&texture\+Id, \mbox{\hyperlink{class_shader}{Shader}} \&shader)
\item 
\mbox{\Hypertarget{class_open_g_l_a471a096ab21f2552a9a279f25e101e8f}\label{class_open_g_l_a471a096ab21f2552a9a279f25e101e8f}} 
\mbox{\hyperlink{class_glfw_window}{Glfw\+Window}} $\ast$ {\bfseries Get\+Glfw\+Window} ()
\item 
\mbox{\Hypertarget{class_open_g_l_a313973a3e955e2dfbae3089346a93a03}\label{class_open_g_l_a313973a3e955e2dfbae3089346a93a03}} 
void {\bfseries Set\+Glfw\+Window} (\mbox{\hyperlink{class_glfw_window}{Glfw\+Window}} $\ast$g)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The abstract \mbox{\hyperlink{class_open_g_l}{Open\+GL}} version of the renderer. Uses the \mbox{\hyperlink{class_renderer}{Renderer}} parent class to have an abstract opengl class that doesnt directly intereact with the system and is used via facading it into the system. 

\begin{DoxyAuthor}{Author}
Christoper Logan 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
01 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
15/03/2021 Christopher Logan, Started 
\end{DoxyDate}


Definition at line 26 of file Open\+GL.\+h.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_open_g_l_a09dc5a5ab1ab540607820efafc9d534d}\label{class_open_g_l_a09dc5a5ab1ab540607820efafc9d534d}} 
\index{OpenGL@{OpenGL}!BindTexture@{BindTexture}}
\index{BindTexture@{BindTexture}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{BindTexture()}{BindTexture()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Bind\+Texture (\begin{DoxyParamCaption}\item[{std\+::vector$<$ unsigned int $>$}]{textures }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Binds textures to memory. 


\begin{DoxyParams}{Parameters}
{\em textures} & -\/ The list of textures being used \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a259e569689938bea487d31727791b963}{Renderer}}.



Definition at line 25 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{26 \{}
\DoxyCodeLine{27     glActiveTexture(GL\_TEXTURE0);}
\DoxyCodeLine{28     glBindTexture(GL\_TEXTURE\_2D, textures[0]);}
\DoxyCodeLine{29     glActiveTexture(GL\_TEXTURE1);}
\DoxyCodeLine{30     glBindTexture(GL\_TEXTURE\_2D, textures[1]);}
\DoxyCodeLine{31     glActiveTexture(GL\_TEXTURE2);}
\DoxyCodeLine{32     glBindTexture(GL\_TEXTURE\_2D, textures[2]);}
\DoxyCodeLine{33     glActiveTexture(GL\_TEXTURE3);}
\DoxyCodeLine{34     glBindTexture(GL\_TEXTURE\_2D, textures[3]);}
\DoxyCodeLine{35     glActiveTexture(GL\_TEXTURE4);}
\DoxyCodeLine{36     glBindTexture(GL\_TEXTURE\_2D, textures[4]);}
\DoxyCodeLine{37 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_aebd9611b84f6496a5b075b1714fb3d4b}\label{class_open_g_l_aebd9611b84f6496a5b075b1714fb3d4b}} 
\index{OpenGL@{OpenGL}!ExitScreenSetup@{ExitScreenSetup}}
\index{ExitScreenSetup@{ExitScreenSetup}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{ExitScreenSetup()}{ExitScreenSetup()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Exit\+Screen\+Setup (\begin{DoxyParamCaption}\item[{std\+::vector$<$ glm\+::vec3 $>$}]{vertex\+Data,  }\item[{std\+::vector$<$ unsigned int $>$}]{indices\+Data,  }\item[{unsigned int \&}]{VAO,  }\item[{unsigned int \&}]{VBO,  }\item[{unsigned int \&}]{EBO }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets up the exit screen. 


\begin{DoxyParams}{Parameters}
{\em vertex\+Data} & -\/ the positions data \\
\hline
{\em indices} & -\/ The indices data \\
\hline
{\em VAO} & -\/ The vertex array object \\
\hline
{\em VBO} & -\/ The vertex buffer object \\
\hline
{\em EBO} & -\/ Another buffer \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_aff31437b9015103fec2d09b00979aed7}{Renderer}}.



Definition at line 122 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{122                                                                                                                                                     \{}
\DoxyCodeLine{123     glGenVertexArrays(1, \&VAO);}
\DoxyCodeLine{124     glGenBuffers(1, \&VBO);}
\DoxyCodeLine{125     glGenBuffers(1, \&EBO);}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     glBindVertexArray(VAO);}
\DoxyCodeLine{128 }
\DoxyCodeLine{129     glBindBuffer(GL\_ARRAY\_BUFFER, VBO);}
\DoxyCodeLine{130     glBufferData(GL\_ARRAY\_BUFFER, vertexData.size() * \textcolor{keyword}{sizeof}(glm::vec3), \&vertexData[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{131 }
\DoxyCodeLine{132     glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, EBO);}
\DoxyCodeLine{133     glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, indices.size() * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), \&indices[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{134 }
\DoxyCodeLine{135     \textcolor{comment}{//postion attributes}}
\DoxyCodeLine{136     glVertexAttribPointer(0, 3, GL\_FLOAT, GL\_FALSE, 9 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)0);}
\DoxyCodeLine{137     glEnableVertexAttribArray(0);}
\DoxyCodeLine{138 }
\DoxyCodeLine{139     \textcolor{comment}{//texture attributes}}
\DoxyCodeLine{140     glVertexAttribPointer(1, 3, GL\_FLOAT, GL\_FALSE, 9 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)(3 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{141     glEnableVertexAttribArray(1);}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_a1aa8e3b718d4635acd8bdbff39920c5a}\label{class_open_g_l_a1aa8e3b718d4635acd8bdbff39920c5a}} 
\index{OpenGL@{OpenGL}!RenderExitScreen@{RenderExitScreen}}
\index{RenderExitScreen@{RenderExitScreen}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{RenderExitScreen()}{RenderExitScreen()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Render\+Exit\+Screen (\begin{DoxyParamCaption}\item[{unsigned int}]{VAO,  }\item[{unsigned int}]{EBO,  }\item[{unsigned int}]{texture }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Rends the exit model. 


\begin{DoxyParams}{Parameters}
{\em VAO} & -\/ The vertex array object \\
\hline
{\em texture} & -\/ The texture number \\
\hline
{\em EBO} & -\/ Another buffer \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a023aa7491efa15df16a0750cd5ed516a}{Renderer}}.



Definition at line 16 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{16                                                                                      \{}
\DoxyCodeLine{17     glBindVertexArray(VAO);}
\DoxyCodeLine{18     glActiveTexture(GL\_TEXTURE5);}
\DoxyCodeLine{19     glBindTexture(GL\_TEXTURE5, texture);}
\DoxyCodeLine{20     glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, EBO);}
\DoxyCodeLine{21     glDrawElements(GL\_TRIANGLES, 6, GL\_UNSIGNED\_INT, 0);}
\DoxyCodeLine{22     glBindVertexArray(0);}
\DoxyCodeLine{23 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_af73c3c12c76274a45f3d4245d2d9d11a}\label{class_open_g_l_af73c3c12c76274a45f3d4245d2d9d11a}} 
\index{OpenGL@{OpenGL}!RenderModel@{RenderModel}}
\index{RenderModel@{RenderModel}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{RenderModel()}{RenderModel()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Render\+Model (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_shader}{Shader}} \&}]{shader,  }\item[{glm\+::mat4}]{new\+Model,  }\item[{\mbox{\hyperlink{class_mesh}{Mesh}}}]{mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Renders the games model. 


\begin{DoxyParams}{Parameters}
{\em shader} & -\/ The objects shader \\
\hline
{\em new\+Model} & -\/ The matrix4 model infromation for rotation or scaling \\
\hline
{\em The} & mesh -\/ The current mesh of the object \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a50f434d31fea7a8feedd0b7077f8ab1b}{Renderer}}.



Definition at line 55 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{56 \{}
\DoxyCodeLine{57     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}model"{}}, newModel);}
\DoxyCodeLine{58     \textcolor{comment}{// bind appropriate textures}}
\DoxyCodeLine{59     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diffuseNr = 1;}
\DoxyCodeLine{60     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} specularNr = 1;}
\DoxyCodeLine{61     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} normalNr = 1;}
\DoxyCodeLine{62     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} heightNr = 1;}
\DoxyCodeLine{63     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < mesh.textures.size(); i++)}
\DoxyCodeLine{64     \{}
\DoxyCodeLine{65         glActiveTexture(GL\_TEXTURE0 + i); \textcolor{comment}{// active proper texture unit before binding}}
\DoxyCodeLine{66         \textcolor{comment}{// retrieve texture number (the N in diffuse\_textureN)}}
\DoxyCodeLine{67         std::string number;}
\DoxyCodeLine{68         std::string name = mesh.textures[i].type;}
\DoxyCodeLine{69         \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}texture\_diffuse"{}})}
\DoxyCodeLine{70             number = std::to\_string(diffuseNr++);}
\DoxyCodeLine{71         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}texture\_specular"{}})}
\DoxyCodeLine{72             number = std::to\_string(specularNr++); \textcolor{comment}{// transfer unsigned int to stream}}
\DoxyCodeLine{73         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}texture\_normal"{}})}
\DoxyCodeLine{74             number = std::to\_string(normalNr++); \textcolor{comment}{// transfer unsigned int to stream}}
\DoxyCodeLine{75         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}texture\_height"{}})}
\DoxyCodeLine{76             number = std::to\_string(heightNr++); \textcolor{comment}{// transfer unsigned int to stream}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78         \textcolor{comment}{// now set the sampler to the correct texture unit}}
\DoxyCodeLine{79         glUniform1i(glGetUniformLocation(shader.\mbox{\hyperlink{class_shader_a142a08b6fbdfc982d82ca10ee0b0f38d}{ID}}, (name + number).c\_str()), i);}
\DoxyCodeLine{80         \textcolor{comment}{// and finally bind the texture}}
\DoxyCodeLine{81         glBindTexture(GL\_TEXTURE\_2D, mesh.textures[i].id);}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84     \textcolor{comment}{// draw mesh}}
\DoxyCodeLine{85     glBindVertexArray(mesh.VAO);}
\DoxyCodeLine{86     glDrawElements(GL\_TRIANGLES, mesh.indices.size(), GL\_UNSIGNED\_INT, 0);}
\DoxyCodeLine{87     glBindVertexArray(0);}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{comment}{// always good practice to set everything back to defaults once configured.}}
\DoxyCodeLine{90     glActiveTexture(GL\_TEXTURE0);}
\DoxyCodeLine{91 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_a78930c5422a4b13cdddd9980a1b5216e}\label{class_open_g_l_a78930c5422a4b13cdddd9980a1b5216e}} 
\index{OpenGL@{OpenGL}!RenderSkybox@{RenderSkybox}}
\index{RenderSkybox@{RenderSkybox}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{RenderSkybox()}{RenderSkybox()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Render\+Skybox (\begin{DoxyParamCaption}\item[{unsigned int}]{VAO,  }\item[{unsigned int}]{texture }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Renders the sky box. 


\begin{DoxyParams}{Parameters}
{\em VAO} & -\/ The vertex array object \\
\hline
{\em texture} & -\/ The texture number \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a73ad38f16da2f99d3a044b6fc2758694}{Renderer}}.



Definition at line 44 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{45 \{}
\DoxyCodeLine{46     glDepthFunc(GL\_LEQUAL);}
\DoxyCodeLine{47     glBindVertexArray(VAO);}
\DoxyCodeLine{48     glActiveTexture(GL\_TEXTURE0);}
\DoxyCodeLine{49     glBindTexture(GL\_TEXTURE\_CUBE\_MAP, texture);}
\DoxyCodeLine{50     glDrawArrays(GL\_TRIANGLES, 0, 36);}
\DoxyCodeLine{51     glBindVertexArray(0);}
\DoxyCodeLine{52     glDepthFunc(GL\_LESS);}
\DoxyCodeLine{53 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_ad0222ac664fbb5018065732b5ff0f699}\label{class_open_g_l_ad0222ac664fbb5018065732b5ff0f699}} 
\index{OpenGL@{OpenGL}!RenderTerrain@{RenderTerrain}}
\index{RenderTerrain@{RenderTerrain}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{RenderTerrain()}{RenderTerrain()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Render\+Terrain (\begin{DoxyParamCaption}\item[{unsigned int}]{VAO,  }\item[{int}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Renders the games terrain. 


\begin{DoxyParams}{Parameters}
{\em VAO} & -\/ The vertex array object \\
\hline
{\em size} & -\/ the size needed to render \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a959836fa3882bc0941997d7cbdef10c6}{Renderer}}.



Definition at line 5 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{6 \{}
\DoxyCodeLine{7     glPrimitiveRestartIndex(0xFFFFFFFFU);}
\DoxyCodeLine{8     glEnable(GL\_PRIMITIVE\_RESTART);}
\DoxyCodeLine{9 }
\DoxyCodeLine{10     glBindVertexArray(VAO);}
\DoxyCodeLine{11     glDrawElements(GL\_TRIANGLES, size, GL\_UNSIGNED\_INT, 0);}
\DoxyCodeLine{12     glBindVertexArray(0);}
\DoxyCodeLine{13     glActiveTexture(GL\_TEXTURE0);}
\DoxyCodeLine{14 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_a9e1ffb565600b03b7fa57f6370ff592b}\label{class_open_g_l_a9e1ffb565600b03b7fa57f6370ff592b}} 
\index{OpenGL@{OpenGL}!SetShader@{SetShader}}
\index{SetShader@{SetShader}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{SetShader()}{SetShader()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Set\+Shader (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_shader}{Shader}}}]{shader,  }\item[{\mbox{\hyperlink{class_view}{View}}}]{lens }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets the shader and uses it. 


\begin{DoxyParams}{Parameters}
{\em shader} & -\/ The shader used \\
\hline
{\em lens} & -\/ The viewing information \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a0eebf54fd91ea19b54da3bf1ba944a0f}{Renderer}}.



Definition at line 93 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{94 \{}
\DoxyCodeLine{95     shader.\mbox{\hyperlink{class_shader_a870fa9f13d69e558815d6fd351a469dc}{use}}();}
\DoxyCodeLine{96     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}projection"{}}, lens.\mbox{\hyperlink{class_view_aa878a4bc822f2e5c6999e8b4be727a2b}{GetProjection}}());}
\DoxyCodeLine{97     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}view"{}}, lens.\mbox{\hyperlink{class_view_ad8b28c769712d05576aa6e316f04ad32}{GetView}}());}
\DoxyCodeLine{98     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}model"{}}, lens.\mbox{\hyperlink{class_view_a9aa38aadb27fc4f30fc31af7bceeeff2}{GetModel}}());}
\DoxyCodeLine{99 \}}

\end{DoxyCode}


References Shader\+::use().

Here is the call graph for this function\+:
% FIG 2
\mbox{\Hypertarget{class_open_g_l_ad3aff4310ee768707a5813e5133e41aa}\label{class_open_g_l_ad3aff4310ee768707a5813e5133e41aa}} 
\index{OpenGL@{OpenGL}!SetShaderSkybox@{SetShaderSkybox}}
\index{SetShaderSkybox@{SetShaderSkybox}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{SetShaderSkybox()}{SetShaderSkybox()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Set\+Shader\+Skybox (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_shader}{Shader}}}]{shader,  }\item[{\mbox{\hyperlink{class_view}{View}}}]{lens }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets the shader and uses it for the skybox. 


\begin{DoxyParams}{Parameters}
{\em shader} & -\/ The shader used \\
\hline
{\em lens} & -\/ The viewing information \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a224d12fd102ab83e02c768dc7a6dce0d}{Renderer}}.



Definition at line 114 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{115 \{}
\DoxyCodeLine{116     glm::mat4 viewSky = glm::mat4(glm::mat3(lens.\mbox{\hyperlink{class_view_aa827036992f7d21b5ee9341c6a789950}{GetSkyview}}()));}
\DoxyCodeLine{117     shader.\mbox{\hyperlink{class_shader_a870fa9f13d69e558815d6fd351a469dc}{use}}();}
\DoxyCodeLine{118     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}view"{}}, viewSky);}
\DoxyCodeLine{119     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}projection"{}}, lens.\mbox{\hyperlink{class_view_aa878a4bc822f2e5c6999e8b4be727a2b}{GetProjection}}());}
\DoxyCodeLine{120 \}}

\end{DoxyCode}


References Shader\+::use().

Here is the call graph for this function\+:
% FIG 3
\mbox{\Hypertarget{class_open_g_l_a121c5cdb62e37ae54455f1f799d5c449}\label{class_open_g_l_a121c5cdb62e37ae54455f1f799d5c449}} 
\index{OpenGL@{OpenGL}!SetShaderTerrain@{SetShaderTerrain}}
\index{SetShaderTerrain@{SetShaderTerrain}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{SetShaderTerrain()}{SetShaderTerrain()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Set\+Shader\+Terrain (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_shader}{Shader}} \&}]{shader,  }\item[{\mbox{\hyperlink{class_view}{View}}}]{lens }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets up the shader for the terrain. 


\begin{DoxyParams}{Parameters}
{\em shader} & -\/ The shader used \\
\hline
{\em lens} & -\/ The viewing information \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a9c07e92b290c5abcb77941815823943e}{Renderer}}.



Definition at line 101 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{102 \{}
\DoxyCodeLine{103     shader.\mbox{\hyperlink{class_shader_a870fa9f13d69e558815d6fd351a469dc}{use}}();}
\DoxyCodeLine{104     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}projection"{}}, lens.\mbox{\hyperlink{class_view_aa878a4bc822f2e5c6999e8b4be727a2b}{GetProjection}}());}
\DoxyCodeLine{105     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}view"{}}, lens.\mbox{\hyperlink{class_view_ad8b28c769712d05576aa6e316f04ad32}{GetView}}());}
\DoxyCodeLine{106     glm::mat4 m = glm::mat4(1.0f);}
\DoxyCodeLine{107     m = glm::scale(m, glm::vec3(0.2f));}
\DoxyCodeLine{108     shader.\mbox{\hyperlink{class_shader_a8e711c96f3e1722cbfb88fde9478977c}{setMat4}}(\textcolor{stringliteral}{"{}model"{}}, m);}
\DoxyCodeLine{109     shader.\mbox{\hyperlink{class_shader_aeb021061c5d451329d92257b07dbfec3}{setVec3}}(\textcolor{stringliteral}{"{}lightColor"{}}, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{110     shader.\mbox{\hyperlink{class_shader_aeb021061c5d451329d92257b07dbfec3}{setVec3}}(\textcolor{stringliteral}{"{}lightPos"{}}, (256 * 12) / 2.0, 100.0f, (256 * 12) / 2.0);}
\DoxyCodeLine{111     shader.\mbox{\hyperlink{class_shader_aeb021061c5d451329d92257b07dbfec3}{setVec3}}(\textcolor{stringliteral}{"{}viewPos"{}}, lens.\mbox{\hyperlink{class_view_a835202e230f4d672dc2201aed7f60f64}{GetPosition}}());}
\DoxyCodeLine{112 \}}

\end{DoxyCode}


References Shader\+::set\+Vec3(), and Shader\+::use().

Here is the call graph for this function\+:
% FIG 4
\mbox{\Hypertarget{class_open_g_l_a0635ac48f5d06ce636e2adca774dd3b5}\label{class_open_g_l_a0635ac48f5d06ce636e2adca774dd3b5}} 
\index{OpenGL@{OpenGL}!SetupMesh@{SetupMesh}}
\index{SetupMesh@{SetupMesh}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{SetupMesh()}{SetupMesh()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Setup\+Mesh (\begin{DoxyParamCaption}\item[{unsigned int \&}]{VAO,  }\item[{unsigned int \&}]{VBO,  }\item[{unsigned int \&}]{EBO,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_vertex}{Vertex}} $>$}]{vertices,  }\item[{std\+::vector$<$ unsigned int $>$}]{indices }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets an objects mesh. 


\begin{DoxyParams}{Parameters}
{\em VAO} & -\/ The vertex array object \\
\hline
{\em VBO} & -\/ The vertex buffer object \\
\hline
{\em EBO} & -\/ Another buffer \\
\hline
{\em vertices} & -\/ The vertex positions for the mesh \\
\hline
{\em indices} & -\/ The indice positons \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a769619f9c932ffc886052a67b8834f55}{Renderer}}.



Definition at line 262 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{263 \{}
\DoxyCodeLine{264     glGenVertexArrays(1, \&VAO);}
\DoxyCodeLine{265     glGenBuffers(1, \&VBO);}
\DoxyCodeLine{266     glGenBuffers(1, \&EBO);}
\DoxyCodeLine{267 }
\DoxyCodeLine{268     glBindVertexArray(VAO);}
\DoxyCodeLine{269     \textcolor{comment}{// load data into vertex buffers}}
\DoxyCodeLine{270     glBindBuffer(GL\_ARRAY\_BUFFER, VBO);}
\DoxyCodeLine{271     \textcolor{comment}{// A great thing about structs is that their memory layout is sequential for all its items.}}
\DoxyCodeLine{272     \textcolor{comment}{// The effect is that we can simply pass a pointer to the struct and it translates perfectly to a glm::vec3/2 array which}}
\DoxyCodeLine{273     \textcolor{comment}{// again translates to 3/2 floats which translates to a byte array.}}
\DoxyCodeLine{274     glBufferData(GL\_ARRAY\_BUFFER, vertices.size() * \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), \&vertices[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{275 }
\DoxyCodeLine{276     glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, EBO);}
\DoxyCodeLine{277     glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, indices.size() * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), \&indices[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{278 }
\DoxyCodeLine{279     \textcolor{comment}{// set the vertex attribute pointers}}
\DoxyCodeLine{280     \textcolor{comment}{// vertex Positions}}
\DoxyCodeLine{281     glEnableVertexAttribArray(0);}
\DoxyCodeLine{282     glVertexAttribPointer(0, 3, GL\_FLOAT, GL\_FALSE, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), (\textcolor{keywordtype}{void}*)0);}
\DoxyCodeLine{283     \textcolor{comment}{// vertex normals}}
\DoxyCodeLine{284     glEnableVertexAttribArray(1);}
\DoxyCodeLine{285     glVertexAttribPointer(1, 3, GL\_FLOAT, GL\_FALSE, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), (\textcolor{keywordtype}{void}*)offsetof(\mbox{\hyperlink{struct_vertex}{Vertex}}, Normal));}
\DoxyCodeLine{286     \textcolor{comment}{// vertex texture coords}}
\DoxyCodeLine{287     glEnableVertexAttribArray(2);}
\DoxyCodeLine{288     glVertexAttribPointer(2, 2, GL\_FLOAT, GL\_FALSE, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), (\textcolor{keywordtype}{void}*)offsetof(\mbox{\hyperlink{struct_vertex}{Vertex}}, TexCoords));}
\DoxyCodeLine{289     \textcolor{comment}{// vertex tangent}}
\DoxyCodeLine{290     glEnableVertexAttribArray(3);}
\DoxyCodeLine{291     glVertexAttribPointer(3, 3, GL\_FLOAT, GL\_FALSE, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), (\textcolor{keywordtype}{void}*)offsetof(\mbox{\hyperlink{struct_vertex}{Vertex}}, Tangent));}
\DoxyCodeLine{292     \textcolor{comment}{// vertex bitangent}}
\DoxyCodeLine{293     glEnableVertexAttribArray(4);}
\DoxyCodeLine{294     glVertexAttribPointer(4, 3, GL\_FLOAT, GL\_FALSE, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{struct_vertex}{Vertex}}), (\textcolor{keywordtype}{void}*)offsetof(\mbox{\hyperlink{struct_vertex}{Vertex}}, Bitangent));}
\DoxyCodeLine{295 }
\DoxyCodeLine{296     glBindVertexArray(0);}
\DoxyCodeLine{297 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_affd50e6ec6e2a1cef5f54d08b904f834}\label{class_open_g_l_affd50e6ec6e2a1cef5f54d08b904f834}} 
\index{OpenGL@{OpenGL}!SkyboxSetup@{SkyboxSetup}}
\index{SkyboxSetup@{SkyboxSetup}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{SkyboxSetup()}{SkyboxSetup()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Skybox\+Setup (\begin{DoxyParamCaption}\item[{std\+::vector$<$ float $>$}]{sky\+Verts,  }\item[{std\+::vector$<$ std\+::string $>$}]{faces,  }\item[{unsigned int \&}]{VAO,  }\item[{unsigned int \&}]{VBO,  }\item[{unsigned int \&}]{texture,  }\item[{\mbox{\hyperlink{class_shader}{Shader}} \&}]{sky\+Shader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets up the skybox. 


\begin{DoxyParams}{Parameters}
{\em sky\+Verts} & -\/ The vertice positions \\
\hline
{\em faces} & -\/ The texture file names \\
\hline
{\em VAO} & -\/ The vertex array object \\
\hline
{\em VBO} & -\/ The vertex buffer object \\
\hline
{\em EBO} & -\/ Another buffer \\
\hline
{\em texture} & -\/ The texture number \\
\hline
{\em sky\+Shader} & -\/ The skybox shader \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a5e3f1919e892bfbcc2b1ab40f4b4d14c}{Renderer}}.



Definition at line 176 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{177 \{}
\DoxyCodeLine{178     \textcolor{keywordflow}{if}(Debugger::GetInstance()-\/>debugToConsole) std::cout << \textcolor{stringliteral}{"{}renderer size: "{}} << skyVerts.size() << std::endl;}
\DoxyCodeLine{179     glGenVertexArrays(1, \&VAO);}
\DoxyCodeLine{180     glGenBuffers(1, \&VBO);}
\DoxyCodeLine{181     glBindVertexArray(VAO);}
\DoxyCodeLine{182     glBindBuffer(GL\_ARRAY\_BUFFER, VBO);}
\DoxyCodeLine{183     glBufferData(GL\_ARRAY\_BUFFER, skyVerts.size() * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), \&skyVerts[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{184     glEnableVertexAttribArray(0);}
\DoxyCodeLine{185     glVertexAttribPointer(0, 3, GL\_FLOAT, GL\_FALSE, 3 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)0);}
\DoxyCodeLine{186 }
\DoxyCodeLine{187     glGenTextures(1, \&texture);}
\DoxyCodeLine{188     glBindTexture(GL\_TEXTURE\_CUBE\_MAP, texture);}
\DoxyCodeLine{189 }
\DoxyCodeLine{190     \textcolor{keywordtype}{int} width, height, nrChannels;}
\DoxyCodeLine{191     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < faces.size(); i++) \{}
\DoxyCodeLine{192         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* data =}
\DoxyCodeLine{193             stbi\_load(faces[i].c\_str(), \&width, \&height, \&nrChannels, 0);}
\DoxyCodeLine{194         \textcolor{keywordflow}{if} (data) \{}
\DoxyCodeLine{195             glTexImage2D(GL\_TEXTURE\_CUBE\_MAP\_POSITIVE\_X + i, 0, GL\_RGB, width,}
\DoxyCodeLine{196                 height, 0, GL\_RGB, GL\_UNSIGNED\_BYTE, data);}
\DoxyCodeLine{197             stbi\_image\_free(data);}
\DoxyCodeLine{198         \}}
\DoxyCodeLine{199         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{200             std::cout << \textcolor{stringliteral}{"{}Cubemap texture failed to load at path: "{}} << faces[i]}
\DoxyCodeLine{201                 << std::endl;}
\DoxyCodeLine{202             stbi\_image\_free(data);}
\DoxyCodeLine{203         \}}
\DoxyCodeLine{204     \}}
\DoxyCodeLine{205 }
\DoxyCodeLine{206     glTexParameteri(GL\_TEXTURE\_CUBE\_MAP, GL\_TEXTURE\_MIN\_FILTER, GL\_LINEAR);}
\DoxyCodeLine{207     glTexParameteri(GL\_TEXTURE\_CUBE\_MAP, GL\_TEXTURE\_MAG\_FILTER, GL\_LINEAR);}
\DoxyCodeLine{208     glTexParameteri(GL\_TEXTURE\_CUBE\_MAP, GL\_TEXTURE\_WRAP\_S, GL\_CLAMP\_TO\_EDGE);}
\DoxyCodeLine{209     glTexParameteri(GL\_TEXTURE\_CUBE\_MAP, GL\_TEXTURE\_WRAP\_T, GL\_CLAMP\_TO\_EDGE);}
\DoxyCodeLine{210     glTexParameteri(GL\_TEXTURE\_CUBE\_MAP, GL\_TEXTURE\_WRAP\_R, GL\_CLAMP\_TO\_EDGE);}
\DoxyCodeLine{211 }
\DoxyCodeLine{212     skyShader.\mbox{\hyperlink{class_shader_a870fa9f13d69e558815d6fd351a469dc}{use}}();}
\DoxyCodeLine{213     skyShader.\mbox{\hyperlink{class_shader_ad362e2b654cd95a3574cd505411e41fd}{setInt}}(\textcolor{stringliteral}{"{}skybox"{}}, 0);}
\DoxyCodeLine{214 \}}

\end{DoxyCode}


References Shader\+::set\+Int(), and Shader\+::use().

Here is the call graph for this function\+:
% FIG 5
\mbox{\Hypertarget{class_open_g_l_a94ada51533a316920282d45879bde0fc}\label{class_open_g_l_a94ada51533a316920282d45879bde0fc}} 
\index{OpenGL@{OpenGL}!TerrainSetup@{TerrainSetup}}
\index{TerrainSetup@{TerrainSetup}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{TerrainSetup()}{TerrainSetup()}}
{\footnotesize\ttfamily void Open\+GL\+::\+Terrain\+Setup (\begin{DoxyParamCaption}\item[{std\+::vector$<$ glm\+::vec3 $>$}]{total\+Data,  }\item[{std\+::vector$<$ unsigned int $>$}]{Indices,  }\item[{unsigned int \&}]{VAO,  }\item[{unsigned int \&}]{VBO,  }\item[{unsigned int \&}]{EBO }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Sets up the terrain data. 


\begin{DoxyParams}{Parameters}
{\em total\+Data} & -\/ The vec3 data information \\
\hline
{\em indices} & -\/ The list of positions for the total\+Data \\
\hline
{\em VAO} & -\/ The vertex array object \\
\hline
{\em VBO} & -\/ The vertex buffer object \\
\hline
{\em EBO} & -\/ Another buffer \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_renderer_a89a8d1f799a6c1abd2d7af6e510f8999}{Renderer}}.



Definition at line 145 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{146 \{}
\DoxyCodeLine{147     glGenVertexArrays(1, \&VAO);}
\DoxyCodeLine{148     glGenBuffers(1, \&VBO);}
\DoxyCodeLine{149     glGenBuffers(1, \&EBO);}
\DoxyCodeLine{150 }
\DoxyCodeLine{151     glBindVertexArray(VAO);}
\DoxyCodeLine{152 }
\DoxyCodeLine{153     glBindBuffer(GL\_ARRAY\_BUFFER, VBO);}
\DoxyCodeLine{154     glBufferData(GL\_ARRAY\_BUFFER, totalData.size() * \textcolor{keyword}{sizeof}(glm::vec3), \&totalData[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{155 }
\DoxyCodeLine{156     glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, EBO);}
\DoxyCodeLine{157     glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, Indices.size() * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), \&Indices[0], GL\_STATIC\_DRAW);}
\DoxyCodeLine{158 }
\DoxyCodeLine{159     \textcolor{comment}{//postion attributes}}
\DoxyCodeLine{160     glVertexAttribPointer(0, 3, GL\_FLOAT, GL\_FALSE, 12 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)0);}
\DoxyCodeLine{161     glEnableVertexAttribArray(0);}
\DoxyCodeLine{162 }
\DoxyCodeLine{163     \textcolor{comment}{//color attributes}}
\DoxyCodeLine{164     glVertexAttribPointer(1, 3, GL\_FLOAT, GL\_FALSE, 12 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)(3 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{165     glEnableVertexAttribArray(1);}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     \textcolor{comment}{//texture attributes}}
\DoxyCodeLine{168     glVertexAttribPointer(2, 3, GL\_FLOAT, GL\_FALSE, 12 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)(6 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{169     glEnableVertexAttribArray(2);}
\DoxyCodeLine{170 }
\DoxyCodeLine{171     \textcolor{comment}{//normal attributes}}
\DoxyCodeLine{172     glVertexAttribPointer(3, 3, GL\_FLOAT, GL\_FALSE, 12 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), (\textcolor{keywordtype}{void}*)(9 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{173     glEnableVertexAttribArray(3);}
\DoxyCodeLine{174 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_open_g_l_aaea0f9919293a301acbaf5854c2f4f90}\label{class_open_g_l_aaea0f9919293a301acbaf5854c2f4f90}} 
\index{OpenGL@{OpenGL}!TextureFromFile@{TextureFromFile}}
\index{TextureFromFile@{TextureFromFile}!OpenGL@{OpenGL}}
\doxysubsubsection{\texorpdfstring{TextureFromFile()}{TextureFromFile()}}
{\footnotesize\ttfamily unsigned int Open\+GL\+::\+Texture\+From\+File (\begin{DoxyParamCaption}\item[{std\+::string}]{path,  }\item[{const std\+::string \&}]{directory }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



grabs a texture from a specified file path 


\begin{DoxyParams}{Parameters}
{\em path} & -\/ the path to the texture \\
\hline
{\em directory} & -\/ the directory of the file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
unsigned int 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{class_renderer_aa553a67d535a2bbbb530fa225b89f389}{Renderer}}.



Definition at line 216 of file Open\+GL.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{217 \{}
\DoxyCodeLine{218     std::string filename = path;}
\DoxyCodeLine{219 }
\DoxyCodeLine{220     \textcolor{keywordflow}{if}(Debugger::GetInstance()-\/>debugToConsole) std::cout << \textcolor{stringliteral}{"{}OpenGL.cpp::INFO::"{}} << filename << std::endl; \textcolor{comment}{//debug}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222     filename = directory + \textcolor{charliteral}{'/'} + filename;}
\DoxyCodeLine{223 }
\DoxyCodeLine{224     \textcolor{keywordflow}{if}(Debugger::GetInstance()-\/>debugToConsole) std::cout << \textcolor{stringliteral}{"{}OpenGL.cpp::INFO::"{}} << filename << std::endl; \textcolor{comment}{//debug}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226     stbi\_set\_flip\_vertically\_on\_load(\textcolor{keyword}{false});}
\DoxyCodeLine{227     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} textureID;}
\DoxyCodeLine{228     glGenTextures(1, \&textureID);}
\DoxyCodeLine{229 }
\DoxyCodeLine{230     \textcolor{keywordtype}{int} width, height, nrComponents;}
\DoxyCodeLine{231     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* data = stbi\_load(filename.c\_str(), \&width, \&height, \&nrComponents, 0);}
\DoxyCodeLine{232     \textcolor{keywordflow}{if} (data)}
\DoxyCodeLine{233     \{}
\DoxyCodeLine{234         GLenum format;}
\DoxyCodeLine{235         \textcolor{keywordflow}{if} (nrComponents == 1)}
\DoxyCodeLine{236             format = GL\_RED;}
\DoxyCodeLine{237         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nrComponents == 3)}
\DoxyCodeLine{238             format = GL\_RGB;}
\DoxyCodeLine{239         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nrComponents == 4)}
\DoxyCodeLine{240             format = GL\_RGBA;}
\DoxyCodeLine{241 }
\DoxyCodeLine{242         glBindTexture(GL\_TEXTURE\_2D, textureID);}
\DoxyCodeLine{243         glTexImage2D(GL\_TEXTURE\_2D, 0, (\textcolor{keywordtype}{int})format, width, height, 0, format, GL\_UNSIGNED\_BYTE, data);}
\DoxyCodeLine{244         glGenerateMipmap(GL\_TEXTURE\_2D);}
\DoxyCodeLine{245 }
\DoxyCodeLine{246         glTexParameteri(GL\_TEXTURE\_2D, GL\_TEXTURE\_WRAP\_S, GL\_REPEAT);}
\DoxyCodeLine{247         glTexParameteri(GL\_TEXTURE\_2D, GL\_TEXTURE\_WRAP\_T, GL\_REPEAT);}
\DoxyCodeLine{248         glTexParameteri(GL\_TEXTURE\_2D, GL\_TEXTURE\_MIN\_FILTER, GL\_LINEAR\_MIPMAP\_LINEAR);}
\DoxyCodeLine{249         glTexParameteri(GL\_TEXTURE\_2D, GL\_TEXTURE\_MAG\_FILTER, GL\_LINEAR);}
\DoxyCodeLine{250 }
\DoxyCodeLine{251         stbi\_image\_free(data);}
\DoxyCodeLine{252     \}}
\DoxyCodeLine{253     \textcolor{keywordflow}{else}}
\DoxyCodeLine{254     \{}
\DoxyCodeLine{255         std::cout << \textcolor{stringliteral}{"{}OpenGL.cpp::ERROR::Texture failed to load at path: "{}} << path << std::endl;}
\DoxyCodeLine{256         stbi\_image\_free(data);}
\DoxyCodeLine{257     \}}
\DoxyCodeLine{258 }
\DoxyCodeLine{259     \textcolor{keywordflow}{return} textureID;}
\DoxyCodeLine{260 \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/chris/\+Documents/\+UNI/\+ICT397-\/\+Project/\+ICT397-\/\+Project-\/\+Engine/Open\+GL.\+h\item 
C\+:/\+Users/chris/\+Documents/\+UNI/\+ICT397-\/\+Project/\+ICT397-\/\+Project-\/\+Engine/Open\+GL.\+cpp\end{DoxyCompactItemize}
